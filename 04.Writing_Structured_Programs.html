<html lang="ru" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii"></meta>
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/"></meta>
<title></title>
<style type="text/css">/* :Author: Edward Loper, James Curran:Copyright: This stylesheet has been placed in the public domain.Stylesheet for use with Docutils.This stylesheet defines new css classes used by NLTK.It uses a Python syntax highlighting scheme that matchesthe colour scheme used by IDLE, which makes it easier forbeginners to check they are typing things in correctly. */
/* Include the standard docutils stylesheet. */
</style>
</head>
<body dir="ltr">
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words &#39;inside&#39; a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<div class="compound">
</div>
<!-- standard global imports

>>> import nltk, re, pprint
>>> from nltk import word_tokenize -->
<!-- TODO: recipes for flattening a list of lists into a list, and for the reverse grouping a list into a list of lists -->
<!-- TODO: discuss duck typing -->
<!-- TODO: check ch06-extras for further content -->
<!-- TODO: shared values between multiple dictionaries -->
<!-- TODO: general technique for computing transitive closures, e.g.
adjectives connected by synonymy to a particular word, cf.
http://www.aclweb.org/anthology/W04-3253 -->
<!-- TODO: explain function vs method -->
<!-- TODO: say more about performance tuning of a Python program -->
<!-- TODO: add exercises on string formatting -->
<!-- TODO: this chapter presumes knowledge of dictionaries, not defined until ch05 -->
<!-- TODO: the "b" flag for read(), when to use "rb"; also the "rU" flag -->
<div class="section" id="writing-structured-programs">
<span id="chap-structured-programming"></span><h1>4 Написание структурированных программ</h1>
<p>К настоящему времени вы будете иметь представление о возможностях языка программирования Python для обработки естественного языка.  Однако, если вы новичок в Python или в программировании, вы все равно можете все еще бороться с Python и не чувствовать, что вы имеете полный контроль над ним.  В этой главе мы будем рассматривать следующие вопросы:</p>
<ol class="arabic simple">
<li>Как вы можете писать хорошо структурированные, читываемые программы, которые вы и другие пользователи смогут легко повторно использовать?</li>
<li>Как работают такие фундаментальные строительные блоки, как циклы, функции и присвоение?</li>
<li>Какие существуют подводные камни программирования на языке Python и как вы можете их избежать?</li>
</ol>
<p>По ходу вы будете консолидировать свои знания о фундаментальных конструкциях программирования, узнаете больше об использовании возможностей языка Python в естественной и краткой форме, а также узнаете некоторые полезные приемы визуализации данных естественного языка.
Как и прежде, эта глава содержит множество примеров и упражнений (как и ранее, некоторые упражнения вводят новый материал).
Читатели-новички в программировании должны прорабатывать их тщательно и обращаться к другим введениям в программирование в случае необходимости; опытные программисты могут быстро пролистать эту главу.</p>
<p>В других главах этой книги мы организовали концепции программирования так, как это продиктовано потребностями NLP.  Здесь мы вернемся к более традиционному подходу, когда материал более тесно связан со структурой языка программирования.  Здесь нет места для полного представления языка, так что мы просто сосредоточимся на языковых конструкциях и идиомах (Python), которые являются наиболее важными для NLP.</p>
<div class="section" id="back-to-the-basics">
<span id="sec-back-to-the-basics"></span><h2>4.1 Назад к основам</h2>
<div class="section" id="assignment">
<h3>Присваивание</h3>
<p>Присваивание могло бы показаться самым элементарным понятием программирования, не заслуживающим отдельного разговора.  Тем не менее, здесь есть некоторые неожиданные тонкости.  Рассмотрим следующий фрагмент кода:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; foo = 'Monty'
&gt;&gt;&gt; bar = foo 
&gt;&gt;&gt; foo = 'Python' 
&gt;&gt;&gt; bar
'Monty'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Этот код ведет себя точно так, как и ожидалось.  Когда мы пишем <tt class="doctest"><span class="pre">bar = foo</span></tt> в приведенном выше коде <a class="reference internal" href="http://www.nltk.org/book/ch04.html#assignment1"><span id="ref-assignment1"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, значение <tt class="doctest"><span class="pre">foo</span></tt> (строка <tt class="doctest"><span class="pre"><span class="pysrc-string">'Monty'</span></span></tt>) присваивается переменной <tt class="doctest"><span class="pre">bar</span></tt>.
То есть, <tt class="doctest"><span class="pre">bar</span></tt> является <a name="copy_index_term"></a><span class="termdef">копией</span> <tt class="doctest"><span class="pre">foo</span></tt>, поэтому, когда мы перезаписываем <tt class="doctest"><span class="pre">foo</span></tt> новой строкой <tt class="doctest"><span class="pre"><span class="pysrc-string">'Python'</span></span></tt> в строке <a class="reference internal" href="http://www.nltk.org/book/ch04.html#assignment2"><span id="ref-assignment2"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>, значение <tt class="doctest"><span class="pre">bar</span></tt> не затрагивается.</p>
<p>Однако операторы присвоения не всегда влекут за собой копирование таким образом.
Назначение всегда копирует значение выражения, но значение не всегда то, что вы могли бы ожидать.  В частности, "значение" структурированного объекта, такого как список, на самом деле, просто <span class="emphasis">ссылка</span> на объект.  В следующем примере <a class="reference internal" href="http://www.nltk.org/book/ch04.html#assignment3"><span id="ref-assignment3"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> присваивает ссылку на <tt class="doctest"><span class="pre">foo</span></tt> новой переменной <tt class="doctest"><span class="pre">bar</span></tt>.
Теперь, когда мы изменим что-то внутри <tt class="doctest"><span class="pre">foo</span></tt> в строке <a class="reference internal" href="http://www.nltk.org/book/ch04.html#assignment4"><span id="ref-assignment4"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>, мы можем видеть, что содержимое <tt class="doctest"><span class="pre">bar</span></tt> также было изменено.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; foo = ['Monty', 'Python']
&gt;&gt;&gt; bar = foo 
&gt;&gt;&gt; foo[1] = 'Bodkin' 
&gt;&gt;&gt; bar
['Monty', 'Bodkin']</pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-array-memory"></span><div class="figure" id="fig-array-memory">
<img alt="../images/array-memory.png" src="http://www.nltk.org/images/array-memory.png" style="width:527.25px;height:187.5px">
<p class="caption"><span class="caption-label">Рисунок 4.1:</span> Присвоение списка и память компьютера: два списковых объекта <tt class="doctest"><span class="pre">foo</span></tt> и <tt class="doctest"><span class="pre">bar</span></tt> ссылаются на одно и то же место в памяти компьютера; обновление <tt class="doctest"><span class="pre">foo</span></tt> будет также изменять <tt class="doctest"><span class="pre">bar</span></tt> и наоборот.</p>
</div>
<p>Строка <tt class="doctest"><span class="pre">bar = foo</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#assignment3"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></a> не копирует содержимое переменной, только его "ссылку на объект".
Чтобы понять, что здесь происходит, мы должны знать, как списки хранятся в памяти компьютера.
На рисунке <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fig-array-memory">4.1</a>, мы видим, что список <tt class="doctest"><span class="pre">foo</span></tt> является ссылкой на объект, который хранится на месте 3133 (который сам является рядом указателей на другие места, содержащие строки).
Когда мы назначаем <tt class="doctest"><span class="pre">bar = foo</span></tt>, копируется просто объектная ссылка 3133.
Такое поведение распространяется и на другие аспекты языка, такие как передача параметров (<a class="reference internal" href="http://www.nltk.org/book/ch04.html#sec-functions">4.4</a>).</p>
<!-- XXX add a further sentence spelling out the consequences of this -->
<p>Давайте еще немного поэкспериментируем, создав переменную <tt class="doctest"><span class="pre">empty</span></tt> хранящую пустой список, а затем повторим ее три раза на следующей строке.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; nested = [empty, empty, empty]
&gt;&gt;&gt; nested
[[], [], []]
&gt;&gt;&gt; nested[1].append('Python')
&gt;&gt;&gt; nested
[['Python'], ['Python'], ['Python']]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Заметим, что изменение одного из элементов внутри нашего вложенного списка списков изменили их всех.
Это происходит потому, что каждый из трех элементов, на самом деле, просто ссылка на один и тот же список в памяти.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Используйте умножение, чтобы создать список списков: <tt class="doctest"><span class="pre">nested = [[]] * 3</span></tt>.
Теперь измените один из элементов списка и увидите, что все элементы изменились.  Используйте функцию Python <tt class="doctest"><span class="pre">id()</span></tt>, чтобы узнать числовой идентификатор для любого объекта и убедиться, что <tt class="doctest"><span class="pre">id(nested[0])</span></tt>, <tt class="doctest"><span class="pre">id(nested[1])</span></tt> и <tt class="doctest"><span class="pre">id(nested[2])</span></tt> одинаковые.</p>
</div>
<p>Теперь обратите внимание, что, когда мы присваиваем новое значение одному из элементов такого списка, оно не распространяется на другие:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; nested = [[]] * 3
&gt;&gt;&gt; nested[1].append('Python')
&gt;&gt;&gt; nested[1] = ['Monty']
&gt;&gt;&gt; nested
[['Python'], ['Monty'], ['Python']]</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX use callouts? The way that in-place methods work on lists isn&#39;t really -->
<!-- explained anywhere as far as I can see. E.g why doesn&#39;t ``l2 = l1.append(3)`` do -->
<!-- anything useful. There&#39;s a reference below to in-place sorting, but it isn&#39;t -->
<!-- explained. -->
<p>Мы начали со списка, содержащего три ссылки на единственный пустой список.  Затем мы изменили этот объект, добавив <tt class="doctest"><span class="pre"><span class="pysrc-string">'Python'</span></span></tt> к пустому списку, в результате чего список, содержащий три ссылки на единственный список <tt class="doctest"><span class="pre">[ <span class="pysrc-string">'Python'</span>]</span></tt>.
Далее, мы <em>перезаписали</em> одну из этих ссылок ссылкой на новый объект <tt class="doctest"><span class="pre">[ <span class="pysrc-string">'Monty'</span>]</span></tt>.
Этот последний шаг изменил одну из трех объектных ссылок внутри вложенного списка.
Однако объект <tt class="doctest"><span class="pre">[<span class="pysrc-string">'Python'</span>]</span></tt> не был изменен, и до сих пор на него есть ссылки из двух мест в нашем вложенном списке списков.  Крайне важно осознать эту разницу между изменением объекта с помощью ссылки на объект и перезаписыванием ссылки на объект.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Важно:</strong> 
Для того, чтобы скопировать элементы из списка <tt class="doctest"><span class="pre">foo</span></tt> в новый список <tt class="doctest"><span class="pre">bar</span></tt>, вы можете написать <tt class="doctest"><span class="pre">bar = foo[:]</span></tt>.  Эта команда копирует ссылки на объекты внутри списка.
Чтобы скопировать структуру без копирования каких-либо ссылок на объекты, используйте <tt class="doctest"><span class="pre"><span class="pysrc-builtin">copy</span>.deepcopy()</span></tt>.</p>
</div>
</div>
<div class="section" id="equality">
<h3>Равенство</h3>
<p>Python предоставляет два способа проверить, что пара элементов одинаковы.
Оператор <tt class="doctest"><span class="pre"><span class="pysrc-keyword">is</span></span></tt> проверяет идентичность объектов.  Мы можем использовать его, чтобы проверить наши более ранние наблюдения об объектах.  Сначала мы создадим список, содержащий несколько копий одного и того же объекта, и продемонстрируем, что они не только идентичны согласно <tt class="doctest"><span class="pre">==</span></tt>, но и то, что они являются одним и тем же объектом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; size = 5
&gt;&gt;&gt; python = ['Python']
&gt;&gt;&gt; snake_nest = [python] * size
&gt;&gt;&gt; snake_nest[0] == snake_nest[1] == snake_nest[2] == snake_nest[3] == snake_nest[4]
True
&gt;&gt;&gt; snake_nest[0] is snake_nest[1] is snake_nest[2] is snake_nest[3] is snake_nest[4]
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Теперь давайте подложим нового питона в это гнездо (a new python in this nest).  Мы можем легко показать, что не все объекты одинаковые:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; import random
&gt;&gt;&gt; position = random.choice(range(size))
&gt;&gt;&gt; snake_nest[position] = ['Python']
&gt;&gt;&gt; snake_nest
[['Python'], ['Python'], ['Python'], ['Python'], ['Python']]
&gt;&gt;&gt; snake_nest[0] == snake_nest[1] == snake_nest[2] == snake_nest[3] == snake_nest[4]
True
&gt;&gt;&gt; snake_nest[0] is snake_nest[1] is snake_nest[2] is snake_nest[3] is snake_nest[4]
False</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Вы можете сделать несколько попарных тестов, чтобы выяснить, какая позиция содержит нарушителя, но <tt class="doctest"><span class="pre">id()</span></tt> функция делает обнаружение проще:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; [id(snake) for snake in snake_nest]
[4557855488, 4557854763, 4557855488, 4557855488, 4557855488]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Это показывает, что второй элемент списка имеет отличный идентификатор.  Если вы попробуйте запустить этот фрагмент кода самостоятельно, будьте готовы увидеть различные номера в полученном списке, а также нарушитель может находиться в другом положении.</p>
<!-- XXX following remark is potentially very useful, but would benefit from being -->
<!-- amplified slightly. -->
<p>Иметь два вида равенства может показаться странным.  Однако это на самом деле просто тип-токен различие, знакомое из естественного языка, здесь оно появляется в языке программирования.</p>
</div>
<div class="section" id="conditionals">
<h3>Условные предложения</h3>
<p>В условной части предложения с <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt>, непустая строка или список оцениваются как истинные, тогда как пустая строка или список оцениваются как ложные.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; mixed = ['cat', '', ['dog'], []]
&gt;&gt;&gt; for element in mixed:
...     if element:
...         print(element)
...
cat
['dog']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>То есть, нам <em>не</em> нужно говорить, <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span> len(element)&gt;0:</span></tt> в условии.</p>
<p>В чем разница между использованием <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span>...<span class="pysrc-keyword">elif</span></span></tt> в отличие от использования пары <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> предложений подряд? Что ж, рассмотрим следующую ситуацию:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; animals = ['cat', 'dog']
&gt;&gt;&gt; if 'cat' in animals:
...     print(1)
... elif 'dog' in animals:
...     print(2)
...
<span class="pysrc-output">1</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Если <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> условие предложения удовлетворяется, Python никогда не будет оценивать условие <tt class="doctest"><span class="pre"><span class="pysrc-keyword">elif</span></span></tt>, поэтому мы никогда не напечатаем <tt class="doctest"><span class="pre">2</span></tt>. В противоположность этому, если мы заменили <tt class="doctest"><span class="pre"><span class="pysrc-keyword">elif</span></span></tt> на <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt>, то мы бы напечатали и <tt class="doctest"><span class="pre">1</span></tt>, и <tt class="doctest"><span class="pre">2</span></tt>. Поэтому <tt class="doctest"><span class="pre"><span class="pysrc-keyword">elif</span></span></tt> условие потенциально дает нам больше информации, чем голое <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> условие; когда оно истинно, оно говорит нам не только о том, что условие выполнено, но и о том, что основное <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> условие <em>не</em> было удовлетворено.</p>
<!-- XXX The point above could be made a bit more forcefully like this: -->
<!-- >>> def cond1(l):
...    if &#39;cat&#39; in l:
...        print(1)
...    elif &#39;dog&#39; in l:
...        print(2)

>>> def cond2(l):
...    if &#39;cat&#39; in l:
...        print(1)
...    if &#39;dog&#39; in l:
...        print(2)

>>> animals = [&#39;cat&#39;, &#39;dog&#39;]
>>> cond1(animals)
1
>>> cond2(animals)
1
2 -->
<p>Функции <tt class="doctest"><span class="pre">all()</span></tt> и <tt class="doctest"><span class="pre">any()</span></tt> могут быть применены к списку (или другой последовательности), чтобы проверить, соответствуют ли все или какие - либо элементы некоторому условию:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sent = ['No', 'good', 'fish', 'goes', 'anywhere', 'without', 'a', 'porpoise', '.']
&gt;&gt;&gt; all(len(w) &gt; 4 for w in sent)
False
&gt;&gt;&gt; any(len(w) &gt; 4 for w in sent)
True</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="sequences">
<span id="sec-sequences"></span><h2>4.2 Последовательности</h2>
<!-- XXX next sentence is confusing, since you don&#39;t in fact use parentheses -->
<!-- Although the point about ("foo") not being a tuple is a good one, I would be -->
<!-- inclined to advise students to use parentheses as well as comma. Cf your -->
<!-- example of the precedence problem in the debugging section later on: -->
<!-- For example, ``"%s.%s.%02d" % "ph.d.", "n", 1`` produces a run-time error -->
<!-- ``TypeError: not enough arguments for format string``.  This is because the -->
<!-- percent operator has higher precedence than -->
<!-- the comma operator.  The fix is to add parentheses in order to -->
<!-- force the required scope. -->
<!-- Just checked the Python Tutorial: -->
<!-- As you see, on output tuples are always enclosed in parentheses, so that nested -->
<!-- tuples are interpreted correctly; they may be input with or without surrounding -->
<!-- parentheses, although often parentheses are necessary anyway (if the tuple is part -->
<!-- of a larger expression). -->
<p>До сих пор мы видели два вида объектов, представляющих собой последовательность: строки и списки.  Другой вид последовательности называется <a name="tuple_index_term"></a><span class="termdef">кортежом</span>.
Кортежи формируются с помощью запятой <a class="reference internal" href="http://www.nltk.org/book/ch04.html#create-tuple"><span id="ref-create-tuple"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> и, как правило, заключаются в круглые скобки.  Мы, на самом деле, видели их в предыдущих главах и иногда называли их «парами», так как всегда в них было два члена.  Однако кортежи могут иметь любое количество членов.  Как списки и строки, кортежи могут быть проиндексированы <a class="reference internal" href="http://www.nltk.org/book/ch04.html#index-tuple"><span id="ref-index-tuple"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>, из них можно получить срез <a class="reference internal" href="http://www.nltk.org/book/ch04.html#slice-tuple"><span id="ref-slice-tuple"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>, и они имеют длину <a class="reference internal" href="http://www.nltk.org/book/ch04.html#length-tuple"><span id="ref-length-tuple"><img class="callout" alt="[4]" src="http://www.nltk.org/book/callouts/callout4.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; t = 'walk', 'fem', 3 
&gt;&gt;&gt; t
('walk', 'fem', 3)
&gt;&gt;&gt; t[0] 
'walk'
&gt;&gt;&gt; t[1:] 
('fem', 3)
&gt;&gt;&gt; len(t) 
3</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Внимание!</p>
<p class="last">Кортежи строятся с помощью запятая.  Скобки являются более общей чертой синтаксиса Python, предназначенный для группировки.
Кортеж, содержащий единственный элемент <tt class="doctest"><span class="pre"><span class="pysrc-string">'snark'</span></span></tt>, определяется путем добавления в конце запятой следующим образом: <tt class="doctest"><span class="pre"><span class="pysrc-string">"'snark',"</span></span></tt> ".  Пустой кортеж является особым случаем и определяется с помощью пустых круглых скобок <tt class="doctest"><span class="pre">()</span></tt>.</p>
</div>
<!-- XXX how about making the following contrast: -->
<!-- >>> type((&#39;snark&#39;)) -->
<!-- <type &#39;str&#39;> -->
<!-- >>> type((&#39;snark&#39;,)) -->
<!-- <type &#39;tuple&#39;> -->
<!-- XXX this would be a good place to explain tuple assignment / sequence unpacking -->
<!-- (unless you did in a revision of ch03 - - it is mentioned only in an exercise to -->
<!-- this chapter AF -->
<p>Давайте сравним строки, списки и кортежи непосредственно и выполним индексацию, срез и операцию определения длины для каждого типа:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; raw = 'I turned off the spectroroute'
&gt;&gt;&gt; text = ['I', 'turned', 'off', 'the', 'spectroroute']
&gt;&gt;&gt; pair = (6, 'turned')
&gt;&gt;&gt; raw[2], text[3], pair[1]
('t', 'the', 'turned')
&gt;&gt;&gt; raw[-3:], text[-3:], pair[-3:]
('ute', ['off', 'the', 'spectroroute'], (6, 'turned'))
&gt;&gt;&gt; len(raw), len(text), len(pair)
(29, 5, 2)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Обратите внимание в этом примере кода, что мы вычислили несколько значений в одной строке через запятую.  Эти разделенные запятыми выражения фактически всего лишь кортежи - Python позволяет опустить скобки вокруг кортежей, если нет неоднозначности. Когда мы выводим кортеж на экран, круглые скобки всегда отображаются. Используя кортежи таким образом, мы неявно агрегируем элементы вместе.</p>
<div class="section" id="operating-on-sequence-types">
<h3>Работа с типами, представляющими собой последовательности</h3>
<p>Мы можем перебирать элементы в последовательности <tt class="doctest"><span class="pre">s</span></tt> различными полезными способами, как показано в таблице <a class="reference internal" href="http://www.nltk.org/book/ch04.html#tab-python-sequence">4.1</a>.</p>
<span class="target" id="tab-python-sequence"></span><table border="1" class="docutils" id="tab-python-sequence">
<colgroup>
<col width="45%">
<col width="55%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Python выражение</th>
<th class="head">Комментарий</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> s</span></tt></td>
<td>перебрать элементы <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> sorted(s)</span></tt></td>
<td>перебрать элементы <tt class="doctest"><span class="pre">s</span></tt> в порядке</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(s)</span></tt></td>
<td>перебрать уникальные элементы <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> reversed(s)</span></tt></td>
<td>перебрать элементы <tt class="doctest"><span class="pre">s</span></tt> в обратном порядке</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(s).difference(t)</span></tt></td>
<td>перебрать элементы <tt class="doctest"><span class="pre">s</span></tt>, которые не являются элементами <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
</tbody>
<td><p class="caption"><span class="caption-label">Таблица 4.1</span>: <p>Различные способы перебора последовательностей</p>
</p>
</td></table>
<p>Функции последовательностей, показанные в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#tab-python-sequence">4.1</a>, могут быть объединены различными способами; например, чтобы получить уникальные элементы <tt class="doctest"><span class="pre">s</span></tt> отсортированные в обратном порядке, используйте <tt class="doctest"><span class="pre">reversed(sorted(set(s)))</span></tt>.
Мы можем расположить в случайном порядке содержимое списка <tt class="doctest"><span class="pre">s</span></tt>, прежде чем перебирать их с помощью <tt class="doctest"><span class="pre">random.shuffle(s)</span></tt>.</p>
<p>Мы можем преобразовывать эти типы последовательностей между собой.  Например, <tt class="doctest"><span class="pre">tuple(s)</span></tt> преобразует любой вид последовательности в кортеж, а <tt class="doctest"><span class="pre">list(s)</span></tt> преобразует любую последовательность в список.
Мы можем преобразовать список строк в одну строку с помощью функции <tt class="doctest"><span class="pre">join()</span></tt>, например, <tt class="doctest"><span class="pre"><span class="pysrc-string">':'.join</span>(words)</span></tt>.</p>
<p>Некоторые другие объекты, такие как <tt class="doctest"><span class="pre">FreqDist</span></tt>, могут быть преобразованы в последовательность (с помощью <tt class="doctest"><span class="pre">list()</span></tt> или <tt class="doctest"><span class="pre">sorted())</span></tt> и поддерживают перебор членов, например:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; raw = 'Red lorry, yellow lorry, red lorry, yellow lorry.'
&gt;&gt;&gt; text = word_tokenize(raw)
&gt;&gt;&gt; fdist = nltk.FreqDist(text)
&gt;&gt;&gt; sorted(fdist)
[',', '.', 'Red', 'lorry', 'red', 'yellow']
&gt;&gt;&gt; for key in fdist:
...     print(key + ':', fdist[key], end='; ')
...
<span class="pysrc-output">lorry: 4; red: 1; .: 1; ,: 3; Red: 1; yellow: 2</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>В следующем примере мы используем кортежи, чтобы перестроить содержание нашего списка.  (Мы можем опустить скобки, поскольку запятая имеет более высокий приоритет, чем присвоение.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; words = ['I', 'turned', 'off', 'the', 'spectroroute']
&gt;&gt;&gt; words[2], words[3], words[4] = words[3], words[4], words[2]
&gt;&gt;&gt; words
['I', 'turned', 'the', 'spectroroute', 'off']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Это идиоматичный и читаемый способ перемещения элементов внутри списка.
Это эквивалентно следующему традиционному способу выполнения таких задач, который не использует кортежи (обратите внимание, что этот метод требует временной переменной <tt class="doctest"><span class="pre">tmp</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; tmp = words[2]
&gt;&gt;&gt; words[2] = words[3]
&gt;&gt;&gt; words[3] = words[4]
&gt;&gt;&gt; words[4] = tmp</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Как мы видели, Python имеет функции последовательностей, такие как <tt class="doctest"><span class="pre">sorted()</span></tt> и <tt class="doctest"><span class="pre">reversed()</span></tt>, которые переставляют элементы в последовательности.  Есть также функции, которые изменяют <span class="emphasis">структуру</span> последовательности и которые могут быть удобными для обработки языка.  Так, <tt class="doctest"><span class="pre">zip()</span></tt> принимает элементы из двух и более последовательностей и соединяет их в единый список кортежей.
Для данной последовательности <tt class="doctest"><span class="pre">s</span></tt> <tt class="doctest"><span class="pre">enumerate(s)</span></tt> возвращает пары, состоящие из индекса и соответствующего ему элемента.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; words = ['I', 'turned', 'off', 'the', 'spectroroute']
&gt;&gt;&gt; tags = ['noun', 'verb', 'prep', 'det', 'noun']
&gt;&gt;&gt; zip(words, tags)
&lt;zip object at ...&gt;
&gt;&gt;&gt; list(zip(words, tags))
[('I', 'noun'), ('turned', 'verb'), ('off', 'prep'),
('the', 'det'), ('spectroroute', 'noun')]
&gt;&gt;&gt; list(enumerate(words))
[(0, 'I'), (1, 'turned'), (2, 'off'), (3, 'the'), (4, 'spectroroute')]</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Это широко распространенная особенность Python 3 и NLTK 3 выполнять вычисления только, когда это необходимо (функция, известная как "ленивые вычисления").
Если вы когда-нибудь увидите результат <tt class="doctest"><span class="pre">&lt;zip object at 0x10d005448&gt;</span></tt>, когда вы ожидаете увидеть последовательность, вы можете заставить Python вычислить объект просто поставив его в контексте, который ожидает последовательность, как <tt class="doctest"><span class="pre">list<span class="mathit"><tt class="doctest"><span class="pre">(х)</span></tt></span></span></tt> или <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span></span></tt> <span class="mathit">X</span>.</p>
</div>
<p>Для некоторых задач NLP необходимо разделить последовательность на две или более частей.
Например, мы могли бы хотеть "натренировать" систему на 90% данных и проверить ее на оставшихся 10%.  Для этого мы определяем место, где мы хотим разрезать данные <a class="reference internal" href="http://www.nltk.org/book/ch04.html#cut-location"><span id="ref-cut-location"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, а затем разрезаем последовательность в этом месте <a class="reference internal" href="http://www.nltk.org/book/ch04.html#cut-sequence"><span id="ref-cut-sequence"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; text = nltk.corpus.nps_chat.words()
&gt;&gt;&gt; cut = int(0.9 * len(text)) 
&gt;&gt;&gt; training_data, test_data = text[:cut], text[cut:] 
&gt;&gt;&gt; text == training_data + test_data 
True
&gt;&gt;&gt; len(training_data) / len(test_data) 
9.0</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы можем проверить, что ничто из исходных данных ни утеряно, ни дублировано во время этого процесса <a class="reference internal" href="http://www.nltk.org/book/ch04.html#cut-preserve"><span id="ref-cut-preserve"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>.  Мы также можем проверить, что отношение размеров двух частей именно такое, какое мы хотели <a class="reference internal" href="http://www.nltk.org/book/ch04.html#cut-ratio"><span id="ref-cut-ratio"><img class="callout" alt="[4]" src="http://www.nltk.org/book/callouts/callout4.gif"></span></a>.</p>
</div>
<div class="section" id="combining-different-sequence-types">
<h3>Сочетание различных типов последовательностей</h3>
<p>Давайте объединим наши знания этих трех типов последовательностей и списковых включений, чтобы выполнить задачу сортировки слов в строке по их длине.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; words = 'I turned off the spectroroute'.split() 
&gt;&gt;&gt; wordlens = [(len(word), word) for word in words] 
&gt;&gt;&gt; wordlens.sort() 
&gt;&gt;&gt; ' '.join(w for (_, w) in wordlens) 
'I off the turned spectroroute'</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX cf earlier remark about explaining what "in-place" means -->
<p>Каждая из приведенных выше строк кода содержит существенное свойство.
Простая строка, на самом деле, объект с определенными на нем методами, такими как <tt class="doctest"><span class="pre">split()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#string-object"><span id="ref-string-object"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.
Мы используем списковое включение, чтобы создать список кортежей <a class="reference internal" href="http://www.nltk.org/book/ch04.html#tuple-comprehension"><span id="ref-tuple-comprehension"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>, в котором каждый кортеж состоит из числа (длины слова) и самого слова, например <tt class="doctest"><span class="pre">(3, <span class="pysrc-string">'the'</span>)</span></tt>.  Мы используем метод <tt class="doctest"><span class="pre">sort()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#sort-method"><span id="ref-sort-method"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>, чтобы отсортировать элементы внутри списка.  И, наконец, мы отбрасываем информацию о длине и соединяем слова обратно в одну строку <a class="reference internal" href="http://www.nltk.org/book/ch04.html#discard-length"><span id="ref-discard-length"><img class="callout" alt="[4]" src="http://www.nltk.org/book/callouts/callout4.gif"></span></a>.
(Символ нижнего подчеркивания <a class="reference internal" href="http://www.nltk.org/book/ch04.html#discard-length"><img class="callout" alt="[4]" src="http://www.nltk.org/book/callouts/callout4.gif"></a> - это просто обычная переменная Python, но мы можем использовать это подчеркивание по соглашению для указания на то, что мы не будем использовать его значение.)</p>
<p>Мы начали с разговора о сходстве этих типов последовательностей, но приведенный выше код иллюстрирует важные различия в их роли.  Во-первых, строки появляются в начале и в конце: это характерно в условиях, когда наша программа читает какой-то текст и производит для нас вывод, предназначенный для чтения.  Списки и кортежи используются в середине, но для разных целей.  Список обычно представляет собой последовательность объектов имеющих <span class="emphasis">один и тот же тип</span>, но <span class="emphasis">произвольную длину</span>.  Мы часто используем списки, чтобы хранить последовательность слов.  В противоположность этому кортеж обычно представляет собой совокупность объектов <span class="emphasis">различных типов</span>, но <span class="emphasis">фиксированной длины</span>.  Мы часто используем кортеж, чтобы хранить <a name="record_index_term"></a><span class="termdef">запись</span>, коллекцию различных <a name="fields_index_term"></a><span class="termdef">полей</span>, относящуюся к некоторой сущности.
Это различие между использованием списков и кортежей требует некоторого привыкания, поэтому вот еще один пример:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; lexicon = [
...     ('the', 'det', ['Di:', 'D@']),
...     ('off', 'prep', ['Qf', 'O:f'])
... ]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Здесь лексикон представлен в виде списка, так как он является совокупностью объектов одного типа - лексических записей - заранее неизвестной длины.  Отдельная запись представляется в виде кортежа, поскольку она является совокупностью объектов с различными интерпретациями, такими как орфографическая форма, часть речи и произношения (представленные в SAMPA машиночитаемом фонетическом алфавите <tt class="doctest"><span class="pre">http://www.phon.ucl.ac.uk/home/sampa/)</span></tt>. Обратите внимание, что эти произношения хранятся с помощью списка. (Почему?)</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Хороший способ решить, когда использовать кортеж, а когда списки, спросить, зависит ли интерпретация элемента от его позиции.  Например, токен с ярлыком является сочетанием двух строк, имеющих различную интерпретацию, и мы выбираем интерпретировать первый элемент в качестве токена, а второй в качестве ярлыка.  Поэтому мы используем кортежи следующим образом: <tt class="doctest"><span class="pre">(<span class="pysrc-string">'grail'</span>, <span class="pysrc-string">'noun'</span>)</span></tt>; кортеж вида <tt class="doctest"><span class="pre">(<span class="pysrc-string">'noun'</span>, <span class="pysrc-string">'grail'</span>)</span></tt> будет бессмысленным, так как тогда это было бы слово <tt class="doctest"><span class="pre">noun</span></tt> с ярлыком <tt class="doctest"><span class="pre">grail</span></tt>.
В отличие от этого все элементы текста являются токенами, и позиция в данном случае не имеет существенного значения.  Поэтому мы используем списки следующим образом: <tt class="doctest"><span class="pre">[<span class="pysrc-string">'venetian'</span>, <span class="pysrc-string">'blincd'</span>]</span></tt>; список вида <tt class="doctest"><span class="pre">[<span class="pysrc-string">'blind'</span>, <span class="pysrc-string">'venetian'</span>]</span></tt> будет в равной степени допустимым.
Языковой смысл слов может быть другим, но интерпретация элементов списка в качестве токенов не меняется.</p>
</div>
<p>Различие между списками и кортежами было описано с точки зрения использования.  Однако есть более фундаментальное различие: в Python списки <a name="mutable_index_term"></a><span class="termdef">изменяемы</span>, в то время как кортежи <a name="immutable_index_term"></a><span class="termdef">неизменны</span>.  Другими словами, списки могут быть изменены, в то время как кортежи не могут.  Вот некоторые операций со списками, которые делают модификации внутри списка.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; lexicon.sort()
&gt;&gt;&gt; lexicon[1] = ('turned', 'VBD', ['t3:nd', 't3`nd'])
&gt;&gt;&gt; del lexicon[0]</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Преобразуйте <tt class="doctest"><span class="pre">lexicon</span></tt> в кортеж, используя <tt class="doctest"><span class="pre">lexicon = tuple(lexicon)</span></tt>, затем попробуйте каждую из приведенных выше операций, чтобы подтвердить, что ни одна из них допускается для кортежей.</p>
</div>
</div>
<div class="section" id="generator-expressions">
<h3>Выражения-генераторы</h3>
<p>Мы интенсивное использовали списковые включения для компактной и читаемой обработки текстов.  Вот пример, где мы токенизируем и нормализуем текст:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; text = '''"When I use a word," Humpty Dumpty said in rather a scornful tone,
... "it means just what I choose it to mean - neither more nor less."'''
&gt;&gt;&gt; [w.lower() for w in word_tokenize(text)]
['``', 'when', 'i', 'use', 'a', 'word', ',', "''", 'humpty', 'dumpty', 'said', ...]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Предположим, что мы хотим теперь выполнить дальнейшую обработку этих слов.  Мы можем сделать это путем вставки выше приведенного выражения внутрь вызова некоторой другой функции <a class="reference internal" href="http://www.nltk.org/book/ch04.html#max-comprehension"><span id="ref-max-comprehension"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, но Python позволяет опускать скобки <a class="reference internal" href="http://www.nltk.org/book/ch04.html#max-generator"><span id="ref-max-generator"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; max([w.lower() for w in word_tokenize(text)]) 
'word'
&gt;&gt;&gt; max(w.lower() for w in word_tokenize(text)) 
'word'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Вторая строка использует <a name="generator_expression_index_term"></a><span class="termdef">генераторное выражение</span>.  Это больше, чем удобство обозначения: во многих ситуациях обработки языка генераторные выражения будут более эффективными.
В <a class="reference internal" href="http://www.nltk.org/book/ch04.html#max-comprehension"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></a> хранилище спискового объекта должно быть выделено до того, как будет вычислено значение max().  Если текст очень велик, это может занять много времени.  В <a class="reference internal" href="http://www.nltk.org/book/ch04.html#max-generator"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></a> данные передаются в вызывающую функцию.  Так как вызывающая функция просто должна найти максимальное значение - слово, которое идет последним в лексикографическом порядке сортировки - она может обрабатывать поток данных без необходимости хранить нечто большее, чем максимальное значение, которое ей встретилось до сих пор.</p>
</div>
</div>
<div class="section" id="questions-of-style">
<h2>4.3 Вопросы стиля</h2>
<p>Программирование столь же искусство, сколько и наука.  Бесспорная "библия" программирования, 2.500 страничный многотомный труд Дональда Кнута, называется <span class="emphasis">"Искусство программирования"</span>.  Многие книги были написаны о <span class="emphasis">грамотном программировании,</span> признавая, что люди, а не только компьютеры, должны читать и понимать программы.  Здесь мы поднимаем некоторые вопросы стиля программирования, которые имеют важные последствия для читаемости кода, включая макета кода, противопоставление процедурного и декларативного стиля, использование циклических переменных.</p>
<div class="section" id="python-coding-style">
<h3>Стиль для Python кода</h3>
<p>При написании программ вы принимаете много тонких решений относительно имен, отступов, комментарий и так далее.  Когда вы смотрите на код, написанный другими людьми, ненужные различия в стиле делают его труднее интерпретировать.  Поэтому разработчики языка Python опубликовали руководство по стилю для Python кода, доступное на <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0008/</span></tt>. Базовое ценностью в руководстве по стилю признается <span class="emphasis">последовательность</span> с целью максимизации читаемости кода.
Мы кратко рассмотрим некоторые из его ключевых рекомендаций здесь и отсылаем читателей к полному руководство для ознакомления с детальным обсуждением и примерами.</p>
<!-- XXX use pylisting for following example? -->
<p>Макет кода должен использовать четыре пробела на каждый уровень отступа.  Убедитесь, что когда вы записываете код Python в файл, вы не используете табуляцию для отступов, так как она может быть неправильно интерпретирована различными текстовыми редакторами и отступы могут перепутаться.
Строки должны быть меньше 80 символов; при необходимости вы можете разорвать строку внутри скобок, квадратных скобок или фигурных скобок, потому что Python способен обнаружить, что строка продолжается на следующей строке.
Если вам необходимо разорвать линию вне скобок, квадратных скобок или фигурных скобок, вы часто можете добавить дополнительные скобки, а также вы всегда можете добавить обратную косую черту в конце строки, которая разбивается:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; if (len(syllables) &gt; 4 and len(syllables[2]) == 3 and
...    syllables[2][2] in [aeiou] and syllables[2][3] == syllables[1][3]):
...     process(syllables)
&gt;&gt;&gt; if len(syllables) &gt; 4 and len(syllables[2]) == 3 and \
...    syllables[2][2] in [aeiou] and syllables[2][3] == syllables[1][3]:
...     process(syllables)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Набирание пробелов вместо табуляции вскоре становится рутиной.  Многие редакторы имеют встроенную поддержку Python и могут автоматически делать отступы, а также выделять какие-либо синтаксические ошибки (включая ошибки отступа).
Для получения списка Python-редакторов, пожалуйста, ознакомьтесь с информацией на странице <tt class="doctest"><span class="pre">http://wiki.python.org/moin/PythonEditors</span></tt>.</p>
</div>
</div>
<div class="section" id="procedural-vs-declarative-style">
<h3>Процедурный vs. декларативный стиль</h3>
<!-- XXX ?? Is this really referring to coding style, or was it originally in a -->
<!-- different context? Make a more clear contrast between coding style and programming -->
<!-- style? -->
<!-- XXX following snippet is first time they&#39;ve seen += -->
<!-- XXX this section seems to be more oriented towards "Python for C-Programmers" -->
<!-- rather than to novices. -->
<p>Мы только что видели, как одна и та же задача может быть выполнена различными способами с соответствующими последствиями для эффективности.  Другим фактором, влияющим на разработку программы является <em>стиль программирования</em>.  Рассмотрим следующую программу, которая вычисляет среднюю длину слов в корпусе Брауна:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; tokens = nltk.corpus.brown.words(categories='news')
&gt;&gt;&gt; count = 0
&gt;&gt;&gt; total = 0
&gt;&gt;&gt; for token in tokens:
...     count += 1
...     total += len(token)
&gt;&gt;&gt; total / count
4.401545438271973</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX above is first use of +=, so needs explaining -->
<p>В этой программе мы используем переменную <tt class="doctest"><span class="pre">count</span></tt>, чтобы посчитать количество токенов, а <tt class="doctest"><span class="pre">total</span></tt> хранит суммарную длину всех слов.  Это стиль низкого уровня, не далеко ушедший от машинного кода, примитивных операций, выполняемых процессором компьютера. Обе переменные такие же, как регистры центрального процессора, накапливающие значения на многих промежуточных этапах, значения, которые не имеют смысла пока вычисление не дойдет до конца.
Мы говорим, что эта программа написана в <em>процедурном</em> стиле, диктующем машине операции шаг за шагом.  Теперь рассмотрим следующую программу, которая вычисляет то же самое:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; total = sum(len(t) for t in tokens)
&gt;&gt;&gt; print(total / len(tokens))
4.401...</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- Monkey patching so that the next example doesn&#39;t take forever
>>> tokens = "the cat sat on the mat".split() -->
<p>Первая строка использует генераторное выражение для суммирования длин токенов, в то время как вторая строка вычисляет среднее значение, как и раньше.
Каждая строка кода выполняет полную, значимую задачу, которая может быть понята в терминах свойств высокого уровня, таких как: "<tt class="doctest"><span class="pre">total</span></tt> - это сумма длин токенов".
Детали реализации оставлены интерпретатору Python.
Вторая программа использует встроенную функцию и представляет собой программирование на более абстрактном уровне; полученный код более декларативный.  Давайте рассмотрим крайний случай:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; word_list = []
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(tokens):
...     j = 0
...     while j &lt; len(word_list) and word_list[j] &lt;= tokens[i]:
...         j += 1
...     if j == 0 or tokens[i] != word_list[j-1]:
...         word_list.insert(j, tokens[i])
...     i += 1
...</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Эквивалентная декларативная версия использует знакомые встроенные функции и ее цель мгновенно распознаваема:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; word_list = sorted(set(tokens))</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX you are taking for granted that the reader already knows what a loop variable is. -->
<p>Другой случай, когда переменная цикла кажется необходимый, - это печать счетчика с каждой строкой вывода.  Вместо этого мы можем использовать <tt class="doctest"><span class="pre">enumerate()</span></tt>, который обрабатывает последовательность <tt class="doctest"><span class="pre">s</span></tt> и производит кортеж вида <tt class="doctest"><span class="pre">(i, s[i])</span></tt> для каждого элемента в <tt class="doctest"><span class="pre">s</span></tt>, начиная с <tt class="doctest"><span class="pre">(0, s[0])</span></tt>.  Здесь мы перечисляем ключ-значение пары распределения частот, что приводит к вложенным кортежам <tt class="doctest"><span class="pre">(rank, (word, count))</span></tt>.
Мы печатаем <tt class="doctest"><span class="pre">rank + 1</span></tt>, так что подсчет начинается с <tt class="doctest"><span class="pre">1</span></tt>, как это требуется при получении списка ранжируемых элементов.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; fd = nltk.FreqDist(nltk.corpus.brown.words())
&gt;&gt;&gt; cumulative = 0.0
&gt;&gt;&gt; most_common_words = [word for (word, count) in fd.most_common()]
&gt;&gt;&gt; for rank, word in enumerate(most_common_words):
...     cumulative += fd.freq(word)
...     print("%3d %6.2f%% %s" % (rank + 1, cumulative * 100, word))
...     if cumulative &gt; 0.25:
...         break
...
  1   5.40% the
  2  10.42% ,
  3  14.67% .
  4  17.78% of
  5  20.19% and
  6  22.40% to
  7  24.29% a
  8  25.97% in</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Иногда соблазнительно использовать переменные контура для хранения максимального или минимального значения.  Давайте использовать этот метод, чтобы найти самое длинное слово в тексте.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; text = nltk.corpus.gutenberg.words('milton-paradise.txt')
&gt;&gt;&gt; longest = ''
&gt;&gt;&gt; for word in text:
...     if len(word) &gt; len(longest):
...         longest = word
&gt;&gt;&gt; longest
'unextinguishable'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Однако более прозрачное решение использует два списковых включения, оба имеющие формы, которые должны быть вам знакомы к этому моменту:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; maxlen = max(len(word) for word in text)
&gt;&gt;&gt; [word for word in text if len(word) == maxlen]
['unextinguishable', 'transubstantiate', 'inextinguishable', 'incomprehensible']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Обратите внимание, что наше первое решение нашло первое слово, имеющее наибольшую длину, в то время как второе решение нашло <em>все</em> самые длинные слова (что, как правило, нам и требуется).
Несмотря на то, что есть теоретическое различие в эффективности между двумя решениями, главные постоянные затраты - это чтения данных в основную память; как только они там, второй проход через данные фактически осуществляется мгновенно.  Нам также необходимо сбалансировать нашу озабоченность по поводу эффективности программы с эффективностью программиста.  Быстрое, но плохо читаемое решение будет труднее понимать и поддерживать.</p>
</div>
<div class="section" id="some-legitimate-uses-for-counters">
<h3>Некоторые правомерные виды использования счетчиков</h3>
<!-- XXX it just struck me that we don&#39;t seem to explain range() at any point, tho&#39; -->
<!-- it&#39;s used a couple of times in ch03 (added exercise to ch01; also mentioned in ch02). -->
<p>Есть случаи, когда мы все еще хотим использовать циклические переменные в списковом включении.
Например, нам нужно использовать переменную цикла для извлечения последовательных перекрывающихся n-грамм из списка:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sent = ['The', 'dog', 'gave', 'John', 'the', 'newspaper']
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; [sent[i:i+n] for i in range(len(sent)-n+1)]
[['The', 'dog', 'gave'],
 ['dog', 'gave', 'John'],
 ['gave', 'John', 'the'],
 ['John', 'the', 'newspaper']]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Довольно сложно правильно определить диапазон циклической переменной.
Так как это обычная операция в NLP, NLTK поддерживает ее с функциями <tt class="doctest"><span class="pre">bigrams(text)</span></tt>, <tt class="doctest"><span class="pre">trigrams(text)</span></tt> и общего назначения <tt class="doctest"><span class="pre">ngrams(text, n)</span></tt>.</p>
<p>Вот пример того, как мы можем использовать переменные контура в построении многомерных структур.
Например, чтобы создать массив с <em>m</em> строками и <em>n</em> столбцами, где каждая ячейка представляет собой набор, мы могли бы использовать вложенное списковое включение:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m, n = 3, 7
&gt;&gt;&gt; array = [[set() for i in range(n)] for j in range(m)]
&gt;&gt;&gt; array[2][5].add('Alice')
&gt;&gt;&gt; pprint.pprint(array)
[[set(), set(), set(), set(), set(), set(), set()],
 [set(), set(), set(), set(), set(), set(), set()],
 [set(), set(), set(), set(), set(), {'Alice'}, set()]]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Заметим, что переменные контура <tt class="doctest"><span class="pre">i</span></tt> и <tt class="doctest"><span class="pre">j</span></tt> не используются нигде в полученном объекте, они просто необходимы для синтаксически правильного <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> предложения.  В качестве другого примера такого использования, обратите внимание на то, что выражение <tt class="doctest"><span class="pre">[<span class="pysrc-string">'very'</span> <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(3)]</span></tt> создает список, содержащий три экземпляра <tt class="doctest"><span class="pre"><span class="pysrc-string">"very"</span></span></tt>, без каких-либо чисел в поле зрения.</p>
<p>Обратите внимание, что было бы неправильно выполнить эту задачу с помощью умножения по причинам, касающимся копирования объектов, которые обсуждались ранее в этом разделе.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; array = [[set()] * n] * m
&gt;&gt;&gt; array[2][5].add(7)
&gt;&gt;&gt; pprint.pprint(array)
[[{7}, {7}, {7}, {7}, {7}, {7}, {7}],
 [{7}, {7}, {7}, {7}, {7}, {7}, {7}],
 [{7}, {7}, {7}, {7}, {7}, {7}, {7}]]</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this seems to more of an opening statement that a closing one - - since it -->
<!-- assumes the reader already knows some other languages -->
<p>Итерация является важным приемом программирования.
Заманчиво принять идиомы из других языков.
Тем не менее, Python предлагает некоторые элегантные и очень читаемые альтернативы, как мы уже могли увидеть.</p>
</div>
</div>
<div class="section" id="functions-the-foundation-of-structured-programming">
<span id="sec-functions"></span><h2>4.4 Функции: фундамент структурного программирования</h2>
<!-- XXX excessive duplication of information that was already presented in ch02; -->
<!-- e.g. motivation for functions, terminology of &#39;parameter&#39; and &#39;body&#39;, return -->
<!-- statement etc.  (some collapsing) -->
<p>Функции обеспечивают эффективный способ для упаковки и повторного использования программного кода, как уже было объяснено в <a class="reference external" href="http://www.nltk.org/book/ch02.html#sec-reusing-code">3</a>.
Например, предположим, что мы считаем, что нам часто необходимо читать текст из HTML-файла.
Это включает в себя несколько этапов: открытие файла, его чтение, нормализация пробелов и удаление HTML-разметки.  Мы можем собрать эти шаги в функцию и дать ей имя, например, <tt class="doctest"><span class="pre">get_text()</span></tt>, как показано в листинге <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-get-text">4.2</a>.</p>
<span class="target" id="code-get-text"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
import re
def get_text(file):
    """Read text from a file, normalizing whitespace and stripping HTML markup."""
    text = open(file).read()
    text = re.sub(r'&lt;.*?&gt;', ' ', text)
    text = re.sub('\s+', ' ', text)
    return text</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_get_text.py" type="text/x-python"><span class="caption-label">Пример 4.2 (code_get_text.py)</span></a> : <span class="caption-label">Иллюстрация 4.2</span>: Чтение текста из файла</p></td></tr>
</table></div>
<p>Теперь всякий раз, когда мы хотим получить текст из HTML-файла, мы можем просто вызвать <tt class="doctest"><span class="pre">get_text()</span></tt> с именем файла в качестве единственного аргумента.  Она возвращает строку, и мы можем присвоить ее некоторой переменной, например: <tt class="doctest"><span class="pre">contents = get_text(<span class="pysrc-string">"test.html"</span>)</span></tt>.  Каждый раз, когда мы хотим использовать эту последовательность шагов, мы просто должны вызвать эту функцию.</p>
<p>Использование функций экономит пространство в нашей программе.  Что еще более важно, наш выбор имени функции помогает сделать программу  <em>читаемой</em>.
В случае приведенного выше примера, когда наша программа должна читать отчищенный текст из файла, мы не должны загромождать программу четырьмя строками кода, мы просто должны вызвать <tt class="doctest"><span class="pre">get_text()</span></tt>.  Такой выбор имени помогает обеспечить некоторую "семантическую интерпретацию" - это помогает читателю нашей программы увидеть, что программа "означает".</p>
<p>Обратите внимание на то, что приведенное выше определение функции содержит строку.  Первая строка внутри определения функции называется <a name="docstring_index_term"></a><span class="termdef">строкой документации</span>.  Она не только документирует назначение функции для того, кто читает код, но и доступна для программиста, который загрузил код из файла:</p>
<pre class="literal-block">
|   &gt;&gt;&gt; help(get_text)
|   Help on function get_text in module __main__:
|
|   get(text)
|       Read text from a file, normalizing whitespace and stripping HTML markup.
</pre>
<p>Мы видели, что функции помогают сделать нашу работу повторно используемой и читаемой.  Они также помогают сделать ее <em>надежной</em>.  Когда мы повторно используем код, который уже был разработан и испытан, мы можем быть более уверенными в том, что она обрабатывает различные случаи правильно.
Мы также устраняем риск, что мы забыли какой-то важный шаг или допустили ошибку.
Программа, которая вызывает нашу функцию, также повысила свою надежность.  Автор этой программы имеет дело с более короткой программой, и ее компоненты ведут себя прозрачно.</p>
<p>Подводя итог, необходимо сказать, что, как и предполагает название, функция схватывает функциональность.
Это сегмент кода, которому можно дать значимое имя и который выполняет четко определенную задачу.  Функции позволяют абстрагироваться от деталей, чтобы увидеть более широкую картину и более эффективно программировать.</p>
<p>Остальную часть этого раздела занимает более конкретное рассмотрение функций, изучение механики и обсуждение способов, как сделать ваши программы более читаемыми.</p>
<div class="section" id="function-inputs-and-outputs">
<h3>Входы и выходы функции</h3>
<p>Мы передаем информацию функциям с помощью параметров функции, заключенного в скобки списка переменных и констант, следующего за именем функции в определении функции.  Вот полный пример:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def repeat(msg, num):  
...     return ' '.join([msg] * num)
&gt;&gt;&gt; monty = 'Monty Python'
&gt;&gt;&gt; repeat(monty, 3) 
'Monty Python Monty Python Monty Python'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Сначала определим функцию, которая принимает два параметра, <tt class="doctest"><span class="pre">msg</span></tt> и <tt class="doctest"><span class="pre">num</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fun-def"><span id="ref-fun-def"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>. Затем мы вызываем функцию и передаем ей два аргумента, <tt class="doctest"><span class="pre">monty</span></tt> и <tt class="doctest"><span class="pre">3</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fun-call"><span id="ref-fun-call"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>; эти аргументы подставляются на место "заполнителей", предоставляемых параметрами, и обеспечивают значения для <tt class="doctest"><span class="pre">msg</span></tt> и <tt class="doctest"><span class="pre">num</span></tt> в теле функции.</p>
<p>Наличие параметров необязательно, как мы видим в следующем примере:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def monty():
...     return "Monty Python"
&gt;&gt;&gt; monty()
'Monty Python'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Функция обычно передает свои результаты обратно вызывающей программе с помощью оператора <tt class="doctest"><span class="pre">return</span></tt>, как мы только что видели.  Для вызывающей программы это выглядит, как если бы вызов функции был заменен результатом работы функции, например:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; repeat(monty(), 3)
'Monty Python Monty Python Monty Python'
&gt;&gt;&gt; repeat('Monty Python', 3)
'Monty Python Monty Python Monty Python'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Функция Python необязательно должна иметь оператор возврата.
Некоторые функции выполняют свою работу в качестве побочного эффекта, печатая результат, изменяя файл или обновляя содержимое параметра функции (такие функции называются "процедурами" в некоторых других языках программирования).</p>
<!-- XXX these examples would be easier for a novice to grasp if they knew more about -->
<!-- how functions are used in context. For example, they need to first know that you might -->
<!-- want to write ``foo = my_sort2(l)`` or have a function that only produces -->
<!-- side-effects before they see the significance of these. -->
<p>Рассмотрим следующие три функции сортировки.
Третья функция опасна тем, что программист может использовать ее, не понимая, что она изменяет свой ввод.
В общем случае функции должны изменять содержимое параметра <tt class="doctest"><span class="pre">(my_sort1())</span></tt> или возвращать значение <tt class="doctest"><span class="pre">(my_sort2())</span></tt>, но не делать и то, и другое вместе <tt class="doctest"><span class="pre">(my_sort3())</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def my_sort1(mylist):      # good: modifies its argument, no return value
...     mylist.sort()
&gt;&gt;&gt; def my_sort2(mylist):      # good: doesn't touch its argument, returns value
...     return sorted(mylist)
&gt;&gt;&gt; def my_sort3(mylist):      # bad: modifies its argument and also returns it
...     mylist.sort()
...     return mylist</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="parameter-passing">
<h3>Передача параметров</h3>
<p>Еще в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#sec-back-to-the-basics">4.1</a> вы видели, что присвоение работает со значениями, а также что значение структурированного объекта представляет собой <span class="emphasis">ссылку</span> на этот объект.  То же самое справедливо и для функций.  Python интерпретирует параметры функции в качестве значений (это известно как <a name="call_by_value_index_term"></a><span class="termdef">вызов по значению</span>).  В следующем коде, <tt class="doctest"><span class="pre">set_up()</span></tt> имеет два параметра, оба из которых изменяются внутри функции.  Мы начинаем путем присвоения пустой строки <tt class="doctest"><span class="pre">w</span></tt> и пустого списка <tt class="doctest"><span class="pre">p</span></tt>.  После вызова функции переменная <tt class="doctest"><span class="pre">w</span></tt> осталась без изменения, а <tt class="doctest"><span class="pre">р</span></tt> изменилась:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def set_up(word, properties):
...     word = 'lolcat'
...     properties.append('noun')
...     properties = 5
...
&gt;&gt;&gt; w = ''
&gt;&gt;&gt; p = []
&gt;&gt;&gt; set_up(w, p)
&gt;&gt;&gt; w
''
&gt;&gt;&gt; p
['noun']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Обратите внимание на то, что <tt class="doctest"><span class="pre">w</span></tt> не была изменена функцией.
Когда мы вызвали <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, значение <tt class="doctest"><span class="pre">w</span></tt> (пустая строка) был назначено новой переменной <tt class="doctest"><span class="pre">word</span></tt>.  Внутри функции значение <tt class="doctest"><span class="pre">word</span></tt> было изменено.
Тем не менее, это изменение не распространяется на <tt class="doctest"><span class="pre">w</span></tt>.  Эта передача параметра идентична следующей последовательности присвоений:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; w = ''
&gt;&gt;&gt; word = w
&gt;&gt;&gt; word = 'lolcat'
&gt;&gt;&gt; w
''</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Давайте посмотрим на то, что случилось со списком <tt class="doctest"><span class="pre">p</span></tt>.
Когда мы вызвали <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, величина <tt class="doctest"><span class="pre">p</span></tt> (ссылка на пустой список) была назначена новой локальной переменной <tt class="doctest"><span class="pre">properties</span></tt>, поэтому обе переменные в настоящее время ссылаются на ту же ячейку памяти.
Функция изменяет <tt class="doctest"><span class="pre">properties</span></tt>, и это изменение также отражается в значении <tt class="doctest"><span class="pre">p</span></tt>, как мы видели.  Функция также присвоила properties новое значение (число <tt class="doctest"><span class="pre">5</span></tt>); это не изменило содержимое ячейки памяти, но создало новую локальную переменную.
Это поведение такое же, как если бы мы сделали следующую последовательность присвоений:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; p = []
&gt;&gt;&gt; properties = p
&gt;&gt;&gt; properties.append('noun')
&gt;&gt;&gt; properties = 5
&gt;&gt;&gt; p
['noun']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Таким образом, чтобы понять передачу параметров языка Python с помощью вызова по значению, достаточно понять, как работает присвоение.  Помните, что вы можете использовать функцию <tt class="doctest"><span class="pre">id()</span></tt> и оператор <tt class="doctest"><span class="pre"><span class="pysrc-keyword">is</span></span></tt>, чтобы проверить ваше понимание идентичности объекта после каждого предложения.</p>
</div>
<div class="section" id="variable-scope">
<h3>Сфера действия переменных</h3>
<p>Определения функций создают новую, локальную <a name="scope_index_term"></a><span class="termdef">сферу действия</span> для переменных.
Когда вы присваиваете новой переменной внутри тела функции, имя этой переменной определено только в пределах этой функции.  Ее имя не видно вне функции или в других функциях.  Такое поведение означает, что вы можете выбирать имена переменных, не заботясь о столкновениях с именами, которые были использованы в ваших других определениях функций.</p>
<p>Когда вы обращаетесь к существующему имени внутри тела функции, интерпретатор Python сначала пытается найти имя среди имен, которые являются локальными для функции.
Если ничего не найдено, то интерпретатор проверяет, является ли оно глобальным именем внутри модуля.  И, наконец, если предыдущие попытки не увенчались успехом, интерпретатор проверяет, является ли имя встроенным именем Python.  Это так называемая <a name="lgb_rule_index_term"></a><span class="termdef">LGB-правило</span> поиска имен: сначала локально, затем глобально, затем среди встроенных имен.</p>
<div class="caution">
<p class="first admonition-title">Внимание!</p>
<p class="last">Функция может включить доступ к глобальной переменной с использованием декларации <tt class="doctest"><span class="pre"><span class="pysrc-keyword">global</span></span></tt>.  Тем не менее, эту практику следует избегать, насколько это возможно.  Определение глобальных переменных внутри функции создает зависимости от контекста и ограничивает портативность (или возможность повторного использования) функции.
В общем, вы должны использовать параметры для входов функции и возвращаемые значения для выходов.</p>
</div>
</div>
<div class="section" id="checking-parameter-types">
<h3>Проверка типов параметров</h3>
<p>Python не позволяет объявлять тип переменной, когда мы пишем программу, и это позволяет определять функции, которые являются гибкими относительно типа своих аргументов.  Например, функция-таггер может ожидать последовательность слов, но ей было бы все равно, выражена ли эта последовательность в виде списка или кортежа (или итератора, другого типа последовательности, которая выходит за рамки нынешней дискуссии).</p>
<p>Тем не менее, часто мы хотим писать программы для последующего использования другими и хотим программировать в предупредительном стиле, обеспечивая полезные сообщения, когда функции были вызваны некорректно.  Автор следующей функции <tt class="doctest"><span class="pre">tag()</span></tt> предполагал, что ее аргумент всегда будет строкой.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def tag(word):
...     if word in ['a', 'the', 'all']:
...         return 'det'
...     else:
...         return 'noun'
...
&gt;&gt;&gt; tag('the')
'det'
&gt;&gt;&gt; tag('knight')
'noun'
&gt;&gt;&gt; tag(["'Tis", 'but', 'a', 'scratch']) 
'noun'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Функция возвращает разумные значения для аргументов <tt class="doctest"><span class="pre"><span class="pysrc-string">"the"</span></span></tt> и <tt class="doctest"><span class="pre"><span class="pysrc-string">"knight"</span></span></tt>, но посмотрите, что происходит, когда ей передается список <a class="reference internal" href="http://www.nltk.org/book/ch04.html#list-arg"><span id="ref-list-arg"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> - она не жалуется, хотя результат, который она возвращает явно неверный.
Автор этой функции может предпринять некоторые дополнительные шаги, чтобы гарантировать, что параметр <tt class="doctest"><span class="pre">word</span></tt> функции <tt class="doctest"><span class="pre">tag()</span></tt> является строкой.
Наивным подходом было бы проверить тип аргумента, используя <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span> <span class="pysrc-keyword">not</span> type(word) <span class="pysrc-keyword">is</span> str</span></tt>, и если <tt class="doctest"><span class="pre">word</span></tt> не является строкой, просто вернуть специальное пустое значение языка Python <tt class="doctest"><span class="pre">None</span></tt>. Это небольшое улучшение, так как функция проверяет тип аргумента и пытается вернуть "специальное" диагностическое значение для неправильного ввода.
Тем не менее, это также опасно, потому что вызывающая программа может не обнаружить, что <tt class="doctest"><span class="pre">none</span></tt> использовано в качестве "специального" значения, и это диагностическое возвращаемое значение может быть затем передано в другие части программы с непредсказуемыми последствиями.
Такой подход также потерпит неудачу, если слово является Unicode строкой, которая имеет тип <tt class="doctest"><span class="pre">unicode</span></tt>, а не <tt class="doctest"><span class="pre">str</span></tt>.
Вот лучшее решение, использующее предложение <tt class="doctest"><span class="pre">assert</span></tt> вместе с типом данных языка Python <tt class="doctest"><span class="pre">basestring</span></tt>, обобщающая <tt class="doctest"><span class="pre">unicode</span></tt> и <tt class="doctest"><span class="pre">str</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def tag(word):
...     assert isinstance(word, basestring), "argument to tag() must be a string"
...     if word in ['a', 'the', 'all']:
...         return 'det'
...     else:
...         return 'noun'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Если предложение <tt class="doctest"><span class="pre">assert</span></tt> ложно, это приведет к ошибке, которая не может быть проигнорирована, так как она прекращает выполнение программы.
Кроме того, сообщение об ошибке легко интерпретировать.  Добавление утверждений типа assert в программе поможет найти логические ошибки и является чертой <a name="defensive_programming_index_term"></a><span class="termdef">защитного программирования</span>.
Более фундаментальный подход заключается в документировании параметров каждой функции, используя строки документации, как описано далее в этом разделе.</p>
<!-- XXX should we mention try / except here? -->
</div>
<div class="section" id="functional-decomposition">
<h3>Функциональная декомпозиция</h3>
<p>Хорошо структурированные программы, как правило, широко используют функции.
Когда блок программного кода становится больше, чем 10-20 строк, если код разбит на одну или несколько функций, каждая из которых имеет четкую цель, это большая помощь читаемости программы.  Это аналогично тому, как хорошее эссе делится на абзацы, каждый из которых выражает одну главную идею.</p>
<!-- XXX not clear here whether you are really talking about actions (in which case -->
<!-- :lx: role is maybe inappropriate / misleading) or about lexical semantics. -->
<!-- XXX the following code snippet could well occur earlier, e.g in section where you -->
<!-- talk about function inputs and outputs, so as to motivate different kinds of -->
<!-- return values, and then perhaps repeated here. -->
<p>Функции обеспечивают важный вид абстракции.
Они позволяют нам группировать несколько действий в единое комплексное действие и ассоциировать имя с ним.
(Сравните это с тем , как мы объединяем действия <span class="example">пойти</span> и <span class="example">принести обратно что-то</span> в одно более сложное действие <span class="example">сходить за чем-то</span>.)
Когда мы используем функции, основная программа может быть написана на более высоком уровне абстракции, что делает ее структуру прозрачной, например:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; data = load_corpus()
&gt;&gt;&gt; results = analyze(data)
&gt;&gt;&gt; present(results)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Надлежащее использование функций делает программы более читаемыми и ремонтопригодными.
Кроме того, становится возможным по-новому реализовать функцию - заменив тела функции на более эффективный код - без необходимости иметь дело с остальной частью программы.</p>
<p>Рассмотрим функцию <tt class="doctest"><span class="pre">freq_words</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-freq-words1">4.3</a>.
Она обновляет содержимое распределения частот, которое передается в качестве параметра, а также выводит на экран <span class="math">n</span> наиболее часто встречающихся слов.</p>
<span class="target" id="code-freq-words1"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
from urllib import request
from bs4 import BeautifulSoup

def freq_words(url, freqdist, n):
    html = request.urlopen(url).read().decode('utf8')
    raw = BeautifulSoup(html).get_text()
    for word in word_tokenize(raw):
        freqdist[word.lower()] += 1
    result = []
    for word, count in freqdist.most_common(n):
        result = result + [word]
    print(result)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; constitution = "http://www.archives.gov/exhibits/charters/constitution_transcript.html"
&gt;&gt;&gt; fd = nltk.FreqDist()
&gt;&gt;&gt; freq_words(constitution, fd, 30)
['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',
'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',
'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_freq_words1.py" type="text/x-python"><span class="caption-label">Пример 4.3 (code_freq_words1.py)</span></a>: <span class="caption-label">Листинг 4.3:</span> Плохо спроектированная функция для вычисления частых слов</p></td></tr>
</table></div>
<p>Эта функция имеет ряд проблем.
Функция имеет два побочных эффекта: она изменяет содержимое второго параметра и выводит на экран набор результатов, который она определила.
Функцию будет легче понять и повторно использовать в других местах, если мы инициализируем объект <tt class="doctest"><span class="pre">FreqDist()</span></tt> внутри функции (в том же месте, в котором он "заселяется"), и если бы мы переместили выборку и отображение результатов в вызывающую программу. Учитывая, что ее задача состоит в том, чтобы определить частые слова, она, вероятно, должна просто возвращать список, а не все распределение частот.
В <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-freq-words2">4.4</a> мы <a name="refactor_index_term"></a><span class="termdef">реорганизуем</span> эту функцию и упрощаем ее интерфейс, отбрасывая <tt class="doctest"><span class="pre">freqdist</span></tt> параметр.</p>
<span class="target" id="code-freq-words2"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
from urllib import request
from bs4 import BeautifulSoup

def freq_words(url, n):
    html = request.urlopen(url).read().decode('utf8')
    text = BeautifulSoup(html).get_text()
    freqdist = nltk.FreqDist(word.lower() for word in word_tokenize(text))
    return [word for (word, _) in fd.most_common(n)]</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; freq_words(constitution, 30)
['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',
'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',
'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_freq_words2.py" type="text/x-python"><span class="caption-label">Пример 4.4 (code_freq_words2.py)</span></a> : <span class="caption-label">Листинг 4.4:</span> Хорошо спроектированная функция для вычисления частых слов</p></td></tr>
</table></div>
<p>Читаемость и удобство функции <tt class="doctest"><span class="pre">freq_words</span></tt> улучшились.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Мы использовали <tt class="doctest"><span class="pre">_</span></tt> в качестве имени переменной. Эта переменная ничем не отличается от любой другой, кроме того, что она сообщает читателю, что мы не имеем применения для информации, которую она хранит.</p>
</div>
</div>
<div class="section" id="documenting-functions">
<h3>Документирование функций</h3>
<p>Если мы проделали хорошую работу по декомпозиции нашей программы на функции, тогда описать назначения каждой функции на простом языке и поместить это описание в строку документации в верхней части определения функции не должно составить труда.  Строка документации не должна объяснять, каким образом реализована функциональность; на самом деле, должно быть возможно по-новому реализовать функцию, используя другой метод, не изменяя документации.</p>
<p>Для простейших функций, однострочной документации обычно достаточно (см <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-get-text">4.2</a>).
Вы должны предоставить заключенную в тройные кавычки строку, содержащую законченное предложение на одной строке.
Для нетривиальных функций, вы все равно должны предоставить резюме в одно предложение на первой строке, так как многие инструменты обработки строки документации индексируют эту строку.  За первой строкой должна следовать пустая строка, а затем более подробное описание функциональности (см. <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0257/</span></tt> для получения дополнительной информации о соглашениях по поводу строки документации).</p>
<!-- XXX it would be really nice to have a screen dump of the HTML output. -->
<p>Строки документации могут включать в себя <a name="doctest_block_index_term"></a><span class="termdef">блок документации тестов</span>, иллюстрирующий использование функции и ожидаемый результат.  Они могут быть проверены автоматически с помощью модуля Python <tt class="doctest"><span class="pre">Docutils</span></tt>.
Строки документации должны документировать тип каждого параметра функции и тип возвращаемого значения.  Как минимум, это может быть сделано в виде простого текста.  Тем не менее, обратите внимание, что NLTK использует язык разметки Sphinx для документирования параметров.  Этот формат может быть автоматически преобразован в богато структурированную API документацию (см <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>) и включает специальную обработку определенных "полей", таких как <tt class="doctest"><span class="pre">param</span></tt>, что позволяет четко документировать входы и выходы функций.  Листинг <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-sphinx">4.5</a> иллюстрирует законченную строку документации.</p>
<span class="target" id="code-sphinx"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def accuracy(reference, test):
    """
    Calculate the fraction of test items that equal the corresponding reference items.

Given a list of reference values and a corresponding list of test values,
    return the fraction of corresponding values that are equal.
In particular, return the fraction of indexes
    {0&lt;i&lt;=len(test)} such that C{test[i] == reference[i]}.

       &gt;&gt;&gt; accuracy(['ADJ', 'N', 'V', 'N'], ['N', 'N', 'V', 'ADJ'])
        0.5

    :param reference: An ordered list of reference values
    :type reference: list
    :param test: A list of values to compare against the corresponding
        reference values
    :type test: list
    :return: the accuracy score
    :rtype: float
    :raises ValueError: If reference and length do not have the same length
    """

    if len(reference) != len(test):
        raise ValueError("Lists must have the same length.")
    num_correct = 0
    for x, y in zip(reference, test):
        if x == y:
            num_correct += 1
    return float(num_correct) / len(reference)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_sphinx.py" type="text/x-python"><span class="caption-label">Пример 4.5 (code_sphinx.py)</span></a>: <span class="caption-label">Листинг 4.5:</span> Иллюстрация законченной строки документации, состоящей из однострочного резюме, более подробного объяснения, примера теста и разметки Sphinx, указывающей параметры, типы, тип возвращаемого значения и исключения.</p></td></tr>
</table></div>
</div>
</div>
<div class="section" id="doing-more-with-functions">
<span id="sec-doing-more-with-functions"></span><h2>4.5 Что еще можно делать с функциями</h2>
<p>В этом разделе обсуждаются более сложные понятия, которые вы возможно предпочтете пропустить, первый раз читая эту главу.</p>
<div class="section" id="functions-as-arguments">
<h3>Функции в качестве аргументов</h3>
<p>До сих пор аргументы, которые мы передавали в функции, были просто объектами, такими как строки или структурированные объекты, как списки.  Python также позволяет нам передать функцию в качестве аргумента другой функции.  Теперь мы можем абстрагировать операцию и применить <span class="emphasis">другую операцию</span> в отношении <span class="emphasis">тех же данных</span>.  Как показывают следующие примеры, мы можем передать встроенную функцию <tt class="doctest"><span class="pre">len()</span></tt> или определенную пользователем функцию <tt class="doctest"><span class="pre">last_letter()</span></tt> в качестве аргументов другой функции:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sent = ['Take', 'care', 'of', 'the', 'sense', ',', 'and', 'the',
...         'sounds', 'will', 'take', 'care', 'of', 'themselves', '.']
&gt;&gt;&gt; def extract_property(prop):
...     return [prop(word) for word in sent]
...
&gt;&gt;&gt; extract_property(len)
[4, 4, 2, 3, 5, 1, 3, 3, 6, 4, 4, 4, 2, 10, 1]
&gt;&gt;&gt; def last_letter(word):
...     return word[-1]
&gt;&gt;&gt; extract_property(last_letter)
['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Объекты <tt class="doctest"><span class="pre">len</span></tt> и <tt class="doctest"><span class="pre">last_letter</span></tt> могут передаваться как списки и словари.  Обратите внимание, что круглые скобки используются после имени функции только, если мы вызываем эту функцию; когда мы просто ссылаемся на функцию как объект, они опущены.</p>
<p>Python предоставляет нам еще один способ определить функции в качестве аргументов других функций, так называемые <a name="lambda_expressions_index_term"></a><span class="termdef">ламбда-выражения</span>.  Предположив, что не было никакой необходимости использовать выше определенную функцию <tt class="doctest"><span class="pre">last_letter()</span></tt> в нескольких местах и, следовательно, давать ей имя.  Мы можем эквивалентно записать следующее:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; extract_property(lambda w: w[-1])
['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Наш следующий пример иллюстрирует передачу некоторой функции в качестве аргумента функции <tt class="doctest"><span class="pre">sorted()</span></tt>.
Когда мы вызываем последнюю с одним аргументом (список для сортировки), она использует встроенную функцию сравнения <tt class="doctest"><span class="pre">cmp()</span></tt>.
Тем не менее, мы можем поставить нашу собственную функцию сортировки, например, сортировки в порядке уменьшения длины.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sorted(sent)
[',', '.', 'Take', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds',
'take', 'the', 'the', 'themselves', 'will']
&gt;&gt;&gt; sorted(sent, cmp)
[',', '.', 'Take', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds',
'take', 'the', 'the', 'themselves', 'will']
&gt;&gt;&gt; sorted(sent, lambda x, y: cmp(len(y), len(x)))
['themselves', 'sounds', 'sense', 'Take', 'care', 'will', 'take', 'care',
'the', 'and', 'the', 'of', 'of', ',', '.']</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="accumulative-functions">
<h3>Накопительные Функции</h3>
<p>Эти функции начинаются с инициализации некоторого хранилища, затем перебирают вход и заполняют хранилище, прежде чем вернуть некоторый конечный объект (большую структуру или агрегированный результат).  Стандартный способ сделать это заключается в том, чтобы инициализировать пустой список, накапить материал, а затем вернуть список, как показано в функции <tt class="doctest"><span class="pre">search1()</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-search-examples">4.6</a>.</p>
<span class="target" id="code-search-examples"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def search1(substring, words):
    result = []
    for word in words:
        if substring in word:
            result.append(word)
    return result

def search2(substring, words):
    for word in words:
        if substring in word:
            yield word</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; for item in search1('zz', nltk.corpus.brown.words()):
...     print(item, end=" ")
Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...
&gt;&gt;&gt; for item in search2('zz', nltk.corpus.brown.words()):
...     print(item, end=" ")
Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_search_examples.py" type="text/x-python"><span class="caption-label">Пример 4.6 (code_search_examples.py)</span></a> : <span class="caption-label">Листинг 4.6:</span> Аккумулирование результатов в список</p></td></tr>
</table></div>
<p>Функция <tt class="doctest"><span class="pre">search2()</span></tt> представляет собой генератор.
Первый раз, когда эта функция вызывается, она доходит до предложения <tt class="doctest"><span class="pre">yield</span></tt> и останавливается.  Вызывающая программа получает первое слово и делает любую необходимую ей обработку.  После того, как вызывающая программа готова к другим словом, выполнение функции продолжается с места остановки до того места, где она снова сталкивается с предложением <tt class="doctest"><span class="pre">yield</span></tt>.  Такой подход, как правило, более эффективен, так как функция генерирует данные только по мере того, как это требуется вызывающей программе, и ей нужно выделять дополнительную память для хранения вывода (см. обсуждение генераторных выражений выше).</p>
<p>Вот более сложный пример генератора, который производит все перестановки внутри списка слов.  Для того, чтобы заставить функцию <tt class="doctest"><span class="pre">permutations()</span></tt> генерировать весь свой вывод, мы обарачиваем ее с вызовом из функции <tt class="doctest"><span class="pre">list()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#listperm"><span id="ref-listperm"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def permutations(seq):
...     if len(seq) &lt;= 1:
...         yield seq
...     else:
...         for perm in permutations(seq[1:]):
...             for i in range(len(perm)+1):
...                 yield perm[:i] + seq[0:1] + perm[i:]
...
&gt;&gt;&gt; list(permutations(['police', 'fish', 'buffalo'])) 
[['police', 'fish', 'buffalo'], ['fish', 'police', 'buffalo'],
 ['fish', 'buffalo', 'police'], ['police', 'buffalo', 'fish'],
 ['buffalo', 'police', 'fish'], ['buffalo', 'fish', 'police']]</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Функция <tt class="doctest"><span class="pre">permutations()</span></tt> использует технику, называемую рекурсией, обсуждаемую ниже в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#sec-algorithm-design">4.7</a> .
Способность генерировать перестановки множества слов полезна для создания данных для проверки грамматики (<a class="reference external" href="http://www.nltk.org/book/ch08.html#chap-parse">8.</a>).</p>
</div>
</div>
<div class="section" id="higher-order-functions">
<h3>Функции более высокого порядка</h3>
<p>Python предоставляет некоторые функции более высокого порядка, которые являются стандартными функциями функциональных языков программирования, таких как Haskell.
Проиллюстрируем их здесь, наряду с эквивалентным выражением с использованием списковых включений.</p>
<p>Давайте начнем с определения функции <tt class="doctest"><span class="pre">is_content_word()</span></tt>, которая проверяет, относится ли слово к открытому классу содержательных слов.
Мы используем эту функцию в качестве первого параметра функции <tt class="doctest"><span class="pre">filter()</span></tt>, которая применяет эту функцию к каждому элементу в последовательности, содержащейся в ее втором параметре, и сохраняет только те элементы, для которых она возвращает значение <tt class="doctest"><span class="pre">True</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def is_content_word(word):
...     return word.lower() not in ['a', 'of', 'the', 'and', 'will', ',', '.']
&gt;&gt;&gt; sent = ['Take', 'care', 'of', 'the', 'sense', ',', 'and', 'the',
...         'sounds', 'will', 'take', 'care', 'of', 'themselves', '.']
&gt;&gt;&gt; list(filter(is_content_word, sent))
['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']
&gt;&gt;&gt; [w for w in sent if is_content_word(w)]
['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Еще одной функцией более высокого порядка является функция <tt class="doctest"><span class="pre">map()</span></tt>, которая применяет функцию к каждому элементу в последовательности.  Это обобщенная версия функции <tt class="doctest"><span class="pre">extract_property()</span></tt>, которую мы видели в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#sec-doing-more-with-functions">4.5</a>.
Вот простой способ найти среднюю длину предложения в разделе новостей корпуса Брауна, за которым следует эквивалентная версия вычисления с помощью спискового включения:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; lengths = list(map(len, nltk.corpus.brown.sents(categories='news')))
&gt;&gt;&gt; sum(lengths) / len(lengths)
21.75081116158339
&gt;&gt;&gt; lengths = [len(sent) for sent in nltk.corpus.brown.sents(categories='news')]
&gt;&gt;&gt; sum(lengths) / len(lengths)
21.75081116158339</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>В приведенных выше примерах мы указывали пользовательскую функцию <tt class="doctest"><span class="pre">is_content_word()</span></tt> и встроенную функцию <tt class="doctest"><span class="pre">len()</span></tt>.  Мы можем также использовать ламбда-выражение.
Вот пара эквивалентных примеров, которые считают число гласных в каждом слове.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; list(map(lambda w: len(filter(lambda c: c.lower() in "aeiou", w)), sent))
[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]
&gt;&gt;&gt; [len(c for c in w if c.lower() in "aeiou") for w in sent]
[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Решения, основанные на списковых включниях, как правило, более удобны для чтения, чем решения на основе функций высшего порядка, и мы отдавали предпочтение первому подходу в рамках всей этой книги.</p>
</div>
<div class="section" id="named-arguments">
<h3>Именованные аргументы</h3>
<p>Когда есть много параметров легко запутаться в правильном порядке.  Вместо этого мы можем обращаться к параметрам по названию и даже присвоить им значение по умолчанию, в случае если оно не было предоставлено ​​вызывающей программой.  Теперь параметры могут быть заданы в любом порядке и даже опущены.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def repeat(msg='&lt;empty&gt;', num=1):
...     return msg * num
&gt;&gt;&gt; repeat(num=3)
'&lt;empty&gt;&lt;empty&gt;&lt;empty&gt;'
&gt;&gt;&gt; repeat(msg='Alice')
'Alice'
&gt;&gt;&gt; repeat(num=5, msg='Alice')
'AliceAliceAliceAliceAlice'</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this is going to be confusing for the novice. I suggest omitting the kwargs** -->
<!-- parameter for simplicity, and referring the reader to the Python Tutorial. -->
<p>Эти параметры называют <a name="keyword_arguments_index_term"></a><span class="termdef">именованные аргументы</span>.
Если мы смешиваем эти два вида параметров, то мы должны обеспечить, чтобы безымянные параметры предшествовали именованным.
Это необходимо, так как безымянные параметры определяются положением.  Мы можем определить функцию, которая принимает произвольное число безымянных и именованных параметров и обращается к ним с помощью списка аргументов <tt class="doctest"><span class="pre">*args</span></tt> и словаря именованных аргументов <tt class="doctest"><span class="pre">**kwargs</span></tt>.
(Словари будут представлены в <a class="reference external" href="http://www.nltk.org/book/ch05.html#sec-dictionaries">3</a>.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def generic(*args, **kwargs):
...     print(args)
...     print(kwargs)
&gt;&gt;&gt; generic(1, "African swallow", monty="python")
(1, 'African swallow')
{'monty': 'python'}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Когда <tt class="doctest"><span class="pre">*args</span></tt> появляется в качестве параметра функции, он, на самом деле, соответствует всем безымянным параметрам функции.  Вот еще одна иллюстрация этого аспекта синтаксиса Python для функции <tt class="doctest"><span class="pre">zip()</span></tt>, которая действует на переменное число аргументов.  Мы будем использовать имя переменной <tt class="doctest"><span class="pre">*song</span></tt>, чтобы продемонстрировать, что нет ничего особенного в имени <tt class="doctest"><span class="pre">*args</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; song = [['four', 'calling', 'birds'],
...         ['three', 'French', 'hens'],
...         ['two', 'turtle', 'doves']]
&gt;&gt;&gt; list(zip(song[0], song[1], song[2]))
[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]
&gt;&gt;&gt; list(zip(*song))
[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Из приведенного выше примера должно стать ясно, что <tt class="doctest"><span class="pre">*song</span></tt> просто удобное сокращение и эквивалентно <tt class="doctest"><span class="pre">song[0], song[1], song[2]</span></tt>.</p>
<p>Вот еще один пример использования именованных аргументов в определении функции, наряду с тремя эквивалентными способами вызова этой функции:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def freq_words(file, min=1, num=10):
...     text = open(file).read()
...     tokens = word_tokenize(text)
...     freqdist = nltk.FreqDist(t for t in tokens if len(t) &gt;= min)
...     return freqdist.most_common(num)
&gt;&gt;&gt; fw = freq_words('ch01.rst', 4, 10)
&gt;&gt;&gt; fw = freq_words('ch01.rst', min=4, num=10)
&gt;&gt;&gt; fw = freq_words('ch01.rst', num=10, min=4)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Побочный эффект использования именованных аргументов состоит в том, что они допускают необязательность аргументов.  Таким образом, мы можем опустить любые аргументы, для которых нас устраивают значения по умолчанию: <tt class="doctest"><span class="pre">freq_words(<span class="pysrc-string">'ch01.rst'</span>,  min=4)</span></tt>, <tt class="doctest"><span class="pre">freq_words(<span class="pysrc-string">'ch01.rst'</span>, 4)</span></tt>.
Другой распространенный способ использования дополнительных аргументов, чтобы разрешить флаг.
Вот пересмотренный вариант той же функции, который сообщает ее прогресс, если <tt class="doctest"><span class="pre">отладочный</span></tt> флаг установлен:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def freq_words(file, min=1, num=10, verbose=False):
...     freqdist = FreqDist()
...     if verbose: print("Opening", file)
...     text = open(file).read()
...     if verbose: print("Read in %d characters" % len(file))
...     for word in word_tokenize(text):
...         if len(word) &gt;= min:
...             freqdist[word] += 1
...             if verbose and freqdist.N() % 100 == 0: print(".", sep="")
...     if verbose: print
...     return freqdist.most_common(num)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Внимание!</p>
<p class="last">Будьте осторожны, не используйте изменяемый объект в качестве значения по умолчанию для параметра.  Ряд вызовов функции будет использовать один и тот же объект иногда с причудливыми результатами, как мы увидим в обсуждении отладки ниже.</p>
</div>
<div class="caution">
<p class="first admonition-title">Внимание!</p>
<p>Если ваша программа будет работать с большим количеством файлов, хорошая идея - закрыть все открытые файлы, как только они больше не нужны. Python будет закрывать открытые файлы автоматически, если вы используете <tt class="doctest"><span class="pre">with</span></tt> предложение:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; with open("lexicon.txt") as f:
...     data = f.read()
...     # process the data</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
</div>
<div class="section" id="program-development">
<span id="sec-program-development"></span><h2>4.6 Разработка программы</h2>
<p>Программирование это навык, который приобретается в течение нескольких лет опыта работы с различными языками программирования и задачами.  Основные способности высокого уровня - это <em>проектирование алгоритма</em> и его реализация в <em>структурном программировании</em>.  Основные способности низкого уровня включают в себя знакомство с синтаксическими конструкциями языка, а также знание различных диагностических методов для поиска и устранения неисправностей программы, которая не демонстрирует ожидаемое поведение.</p>
<p>В этом разделе описана внутренняя структура программного модуля и то, как организовать программу, состающую из нескольких модулей.  Затем описываются различные виды ошибок, которые возникают в процессе разработки программы, что вы можете сделать, чтобы исправить их, а еще лучше, чтобы избежать их.</p>
<div class="section" id="structure-of-a-python-module">
<h3>Структура модуля в Python</h3>
<p>Целью программного модуля является соединение логически связанных определений и функций вместе для того, чтобы содействовать повторному использованию и абстракции.  Модули Python - это не более, чем отдельные файлы с расширением <tt class="doctest"><span class="pre">.py</span></tt>.  Например, если вы работали с определенным форматом корпуса, функции для чтения и записи в этом формате могут храниться вместе.  Константы, используемые в обоих форматах, такие как разделители полей или <tt class="doctest"><span class="pre">EXTN = <span class="pysrc-string">".inf"</span></span></tt> расширение файла, могут быть общими.  Если формат был обновлен, вы знаете, что только один файл необходимо изменить.  Аналогичным образом модуль может содержать код для создания и работы с конкретной структурой данных, такой как синтаксические деревья, или код для выполнения конкретной задачи обработки, такой как построение статистики корпуса.</p>
<p>Когда вы начнете писать модули Python, полезно иметь некоторые примеры для подражания.  Вы можете найти код для любого модуля NLTK в вашей системе, используя переменную <tt class="doctest"><span class="pre">__file__</span></tt>, например:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; nltk.metrics.distance.__file__
'/usr/lib/python2.5/site-packages/nltk/metrics/distance.pyc'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Этот вызов возвращает расположение скомпилированного <tt class="doctest"><span class="pre">.pyc</span></tt> файла для модуля, и вы, вероятно, увидите другое место на вашей машине. Файл, который вам нужно будет открыть, это соответствующий <tt class="doctest"><span class="pre">.py</span></tt> исходный файл, он будет в том же каталоге, что и файл <tt class="doctest"><span class="pre">.pyc</span></tt>.
В качестве альтернативы вы можете просмотреть последнюю версию этого модуля в Интернете по адресу <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/source/browse/trunk/nltk/nltk/metrics/distance.py</span></tt>.</p>
<p>Как и любой другой модуль NLTK, <tt class="doctest"><span class="pre">distance.py</span></tt> начинается с группы строк комментария, дающих однострочное название модуля и идентифицирующих авторов.
(Так как код распространяется, он также включает в себя URL, где код доступен, заявление об авторских правах и информацию о лицензии.)
Далее идет строка документации уровня модуля, многострочная строка, заключенная в тройные кавычки, содержащая информацию о модуле, которая будет напечатана, когда кто-то наберет <tt class="doctest"><span class="pre">help(nltk.metrics.distance)</span></tt>.</p>
<!-- XXX how about putting this in a pylisting?  (didn&#39;t work) -->
<pre class="literal-block">
# Natural Language Toolkit: Distance Metrics
#
# Copyright (C) 2001-2013 NLTK Project
# Author: Edward Loper &lt;edloper@gmail.com&gt;
#         Steven Bird &lt;stevenbird1@gmail.com&gt;
#         Tom Lippincott &lt;tom@cs.columbia.edu&gt;
# URL: &lt;http://nltk.org/&gt;
# For license information, see LICENSE.TXT
#

"""
Distance Metrics.

Compute the distance between two items (usually strings).
As metrics, they must satisfy the following three requirements:

1. d(a, a) = 0
2. d(a, b) &gt;= 0
3. d(a, c) &lt;= d(a, b) + d(b, c)
"""
</pre>
<p>После этого идут все предложения импорта, необходимые для модуля, затем любые глобальные переменные, за которыми следует ряд определений функций, которые занимают большую часть модуля.  Другие модули определяют "классы", основной строительный блок объектно-ориентированного программирования, который выходит за рамки данной книги.
(Большинство модулей NLTK также включают в себя функцию <tt class="doctest"><span class="pre">demo()</span></tt>, которая может быть использована, чтобы посмотреть примеры использования модуля.)</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Некоторые переменные и функции модуля используются только внутри модуля.
Они должны иметь имена, начинающиеся с подчеркивания, например, <tt class="doctest"><span class="pre">_helper()</span></tt>, так как это скроет имя.  Если другой модуль импортирует этот модель, используя идиому: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> <span class="pysrc-keyword">module</span> import *</span></tt>, эти имена не будут импортированы.
При желании вы можете перечислить внешне доступные имена модуля с помощью специальной встроенной переменной следующим образом: <tt class="doctest"><span class="pre">__all__ = [<span class="pysrc-string">'edit_distance'</span>, <span class="pysrc-string">'jaccard_distance'</span>].</span></tt></p>
</div>
</div>
<div class="section" id="multi-module-programs">
<h3>Мультимодульные программы</h3>
<p>Некоторые программы объединяют широкий спектр задач, таких как загрузка данных из корпуса, выполнение некоторых аналитических задач с этими данными, и наконец визуализация.
Мы, возможно, уже имеем стабильные модули, которые заботятся о загрузке данных и выполнению визуализации.
Наша работа может включать в себя кодирование аналитических задач и просто вызов функций из существующих модулей.  Этот сценарий изображен на <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fig-multi-module">4.7</a>.</p>
<span class="target" id="fig-multi-module"></span><div class="figure" id="fig-multi-module">
<img alt="../images/multi-module.png" src="http://www.nltk.org/images/multi-module.png" style="width:360.0px;height:237.60000000000002px">
<p class="caption"><span class="caption-label">Рисунок 4.7:</span> Структура программы из нескольких модулей: Основная программа <tt class="doctest"><span class="pre">my_program.py</span></tt> импортирует функции из двух других модулей; уникальные аналитические задачи локализованы в основной программе, в то время как общие задачи загрузки и визуализации содержатся отдельно, чтобы облегчить повторное использование и абстракцию.</p>
</div>
<p>Разделив нашу работу на несколько модулей и используя предложения <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> для доступа к функциям, определенным в другом месте, мы можем сохранить простоту и удобство в обслуживании отдельных модулей.  Такой подход приведет к тому, что коллекция модулей будет расти, и позволит нам строить сложные системы с иерархией модулей.  Хорошее проектирование таких систем представляет собой сложную инженерную задачу и выходит за рамки данной книги.</p>
</div>
<div class="section" id="sources-of-error">
<h3>Источники ошибок</h3>
<p>Мастерство программирования определяется также наличием разнообразных навыков решения проблем, когда программа работает не так, как ожидалось.  Нечто тривиальное, как символ не в том месте, может заставить программу вести себя совсем по-другому.
Мы называем это "жучками" (bugs, багами), потому что такие ошибки имеют крошечный размер по сравнению с ущербом, который они могут причинить.  Они проникают в наш код незаметно, и их присутствие обнаруживается гораздо позже, когда мы прогоняем программу на новых данных.
Иногда, исправление одной ошибки обнаруживает другую, тогда у нас складывается впечатление, что жучки двигаются.  Мы единственно уверены в том, что ошибки являются спонтанными, и это не вина программиста.</p>
<p>Легкомыслие в сторону, отладка кода - это трудно, потому что причин неисправности кода может быть очень много.  Наше непонимание входных данных, алгоритма или даже языка программирования может быть причиной.  Давайте посмотрим на примеры каждой из этих причин.</p>
<p>Во-первых, входные данные могут содержать некоторые неожиданные символы.
Например, имена синсетов WordNet имеют вид <tt class="doctest"><span class="pre">tree.n.01</span></tt>, с тремя компонентами, разделенными с помощью точек.  Модуль NLTK WordNet изначально декомпозировал эти имена с помощью <tt class="doctest"><span class="pre">split(<span class="pysrc-string">'.'</span>)</span></tt>.  Однако этот метод поломался, когда кто-то попытался найти слово <span class="example">PhD</span>, которое имеет название синсета <tt class="doctest"><span class="pre">ph.d..n.01</span></tt>, содержащее четыре точки вместо ожидаемых двух.
Решение заключалось в использовании <tt class="doctest"><span class="pre">rsplit(<span class="pysrc-string">'.'</span>, 2)</span></tt>, чтобы получалось не более двух разделений, используя крайние правые точки, и строка <tt class="doctest"><span class="pre">ph.d.</span></tt> осталась нетронутой.
Хотя несколько человек испытывали модуль до того, как он был выпущен, прошло несколько недель, прежде чем кто-то обнаружил проблему (см. <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=297)</span></tt>.</p>
<p>Во-вторых, прилагаемая функция может вести себя не так, как ожидалось.
Например, при тестировании интерфейса NLTK к WordNet, один из авторов заметил, что ни для одного синсета не были определены антонимы, хотя исходная базы данных предоставляла большое количества информации об антонимах.
То, что выглядело как ошибка в интерфейсе WordNet, оказалось непониманием самого WordNet: антонимы определены для лемм, а не для синсетов.  Ошибкой было недопонимание интерфейса (см. <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=98)</span></tt>.</p>
<!-- XXX much easier to get the point of the next example if it is on a single line, so -->
<!-- a doctest block would work better -->
<p>В-третьих, наше понимание семантики языка Python может быть виной.
Легко сделать неверное предположение об относительной сфере действия двух операторов.
Например, <tt class="doctest"><span class="pre"><span class="pysrc-string">"%s.%s.%02d"</span> % <span class="pysrc-string">"ph.d."</span>, <span class="pysrc-string">"n"</span>, 1</span></tt> производит ошибку выполнения <tt class="doctest"><span class="pre">TypeError: <span class="pysrc-keyword">не</span> достаточно аргументов <span class="pysrc-keyword">для</span> строки формата</span></tt>.
Это происходит потому, что оператор процент имеет более высокий приоритет, чем оператор запятая.  Решение - добавить круглые скобки, чтобы скорректировать сферу действия.  В качестве другого примера предположим, что мы определяем функцию, чтобы собрать все токены текста, имеющие заданную длину.  Функция имеет параметры для текста и длины слова, а также дополнительный параметр, который позволяет задать в виде параметра начальное значение результата:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def find_words(text, wordlength, result=[]):
...     for word in text:
...         if len(word) == wordlength:
...             result.append(word)
...     return result
&gt;&gt;&gt; find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 3) 
['omg', 'teh', 'teh', 'mat']
&gt;&gt;&gt; find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 2, ['ur']) 
['ur', 'on']
&gt;&gt;&gt; find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 3) 
['omg', 'teh', 'teh', 'mat', 'omg', 'teh', 'teh', 'mat']</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Первый раз, когда мы вызываем <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#find-words-1"><span id="ref-find-words-1"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, мы получаем все трехбуквенные слова, как и ожидалось.  Во второй раз мы указываем начальное значение для результата, одноэлементный список <tt class="doctest"><span class="pre">[<span class="pysrc-string">'ur'</span>]</span></tt>, как и ожидалось, в результате содержится это слово наряду с другими двухбуквенными словам из нашего текста.  Теперь, когда мы в следующий раз вызываем <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#find-words-3"><span id="ref-find-words-3"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a> мы используем те же параметры, что и в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#find-words-1"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></a>, но мы получаем другой результат!
Каждый раз, когда мы вызываем <tt class="doctest"><span class="pre">find_words()</span></tt> без третьего параметра,  результат будет просто расширять результат предыдущего вызова, а не начинать с пустого списка результатов, как указано в определении функции.  Поведение программы не такое, как ожидалось, потому что мы неправильно полагали, что значение по умолчанию было создано в момент, вызова функции.  На самом деле, оно будет создано только один раз, в то время, когда интерпретатор Python загружает функцию.
Этот односписковый объект используется всякий раз, когда функция не получает явное значение аргумента.</p>
</div>
<div class="section" id="debugging-techniques">
<h3>Методы отладки</h3>
<p>Так как большинство ошибок кода проистекает от того, что программист делает неверные предположения, первое, что нужно сделать, если вы обнаружили ошибку, это <span class="emphasis">проверить свои предположения</span>.
Локализовать проблему, добавив в программу предложения <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> с указанием значения важных переменных, показывая, насколько программа продвинулась.</p>
<p>Если программа произвела «исключение» - ошибку во время выполнения - интерпретатор напечатает <a name="stack_trace_index_term"></a><span class="termdef">трассировку стека</span>, идентифицирующую местоположение выполнения программы на момент возникновения ошибки.
Если программа зависит от входных данных, попытайтесь уменьшить их до самого маленького размера, при котором все еще возникает ошибка.</p>
<p>После того как вы локализовали проблему в конкретной функции или строке кода, вам необходимо выяснить, что происходит не так.  Часто бывает полезно воссоздать ситуацию, используя интерактивную командную строку.  Определите некоторые переменные затем скопируйте и вставьте строку кода, содержащую ошибку, в интерактивную сессию и посмотрите, что произойдет.  Проверьте свое понимание кода, прочитав некоторую документацию, а также изучив другие образцы кода, которые должны делать то же самое, что вы пытаетесь сделать.  Попробуйте объяснить свой код кому-либо, на случай, если они смогут увидеть, где дела идут не так.</p>
<p>Python предоставляет <a name="debugger_index_term"></a><span class="termdef">отладчик</span>, который позволяет контролировать выполнение вашей программы, указывать номера строк , где выполнение должно остановиться (т.е. <a name="breakpoints_index_term"></a><span class="termdef">контрольные точки</span>), шагать по разделам кода и проверять значения переменных.
Вы можете вызвать отладчик кода следующим образом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; import pdb
&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; pdb.run('mymodule.myfunction()')</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Он <tt class="doctest"><span class="pre">(PDB)</span></tt> предоставит вам приглашение, где вы можете ввести инструкции для отладчика.  Введите <tt class="doctest"><span class="pre">help</span></tt>, чтобы увидеть полный список команд.
Команда <tt class="doctest"><span class="pre">step</span></tt> (или просто <tt class="doctest"><span class="pre">s</span></tt>) приведет к выполнению текущей строки и остановке.  Если текущая строка вызывает функцию, отладчик войдет в функцию и остановится на первой строке.  Команда <tt class="doctest"><span class="pre">next</span></tt> (или просто <tt class="doctest"><span class="pre">n</span></tt>) аналогична, но отладчик остановит выполнение на следующей строке в текущей функции.  Команда <tt class="doctest"><span class="pre">break</span></tt> (или <tt class="doctest"><span class="pre">b</span></tt>)  может быть использована для создания или вывода списка точек останова.  Наберите <tt class="doctest"><span class="pre">continue</span></tt> (или <tt class="doctest"><span class="pre">c</span></tt>), чтобы продолжить выполнение до следующей контрольной точки.
Введите имя любой переменной, чтобы проверить ее значение.</p>
<p>Мы можем использовать отладчик Python, чтобы найти проблему в нашей функции <tt class="doctest"><span class="pre">find_words()</span></tt>.  Вспомните, что проблема возникла, когда функция была вызвана во второй раз.  Мы начнем с вызова функции без использования отладчика <a href="http://www.nltk.org/book/ch04.html#id9"><span class="problematic" id="id10">first-run_</span></a>, используя наименьший возможный вход.  Во второй раз мы вызовем ее с отладчиком <a href="http://www.nltk.org/book/ch04.html#id11"><span class="problematic" id="id12">second-run_</span></a>.
..doctest-ignore:</p>
<pre class="literal-block">
&gt;&gt;&gt; import pdb
&gt;&gt;&gt; find_words(['cat'], 3) # [_first-run]
['cat']
&gt;&gt;&gt; pdb.run("find_words(['dog'], 3)") # [_second-run]
&gt; &lt;string&gt;(1)&lt;module&gt;()
(Pdb) step
--Call--
&gt; &lt;stdin&gt;(1)find_words()
(Pdb) args
text = ['dog']
wordlength = 3
result = ['cat']
</pre>
<p>Здесь мы набрали только две команды в отладчик: <tt class="doctest"><span class="pre">step</span></tt> поместил нас внутрь функции, а <tt class="doctest"><span class="pre">args</span></tt> показал значения ее аргументов (или параметров).
Мы видим сразу, что <tt class="doctest"><span class="pre">result</span></tt> имеет начальное значение <tt class="doctest"><span class="pre">[<span class="pysrc-string">'cat'</span>]</span></tt>, а не пустой список, как ожидалось.  Отладчик помог нам локализовать проблему, что побудило нас проверить наше понимание функций Python.</p>
</div>
<div class="section" id="defensive-programming">
<h3>Защитное программирование</h3>
<p>Для того, чтобы избежать проблем отладки, полезно принять некоторые защитные привычки программирования.  Вместо того, чтобы писать программу о 20 строках, затем проверять ее, стройте программу снизу вверх из маленьких кусочков, которые работают.  Каждый раз, когда вы объединяете эти части, чтобы собрать более крупную единицу кода, тщательно проверьте ее, чтобы убедиться, что она работает так, как задумано.  Рассмотрите возможность добавления предложений <tt class="doctest"><span class="pre">assert</span></tt> в свой код, указав свойства переменной, например <tt class="doctest"><span class="pre">assert(isinstance(text, list))</span></tt>.
Если значение переменной <tt class="doctest"><span class="pre">text</span></tt> позже станет строкой, когда ваш код будет использоваться в некотором более широком контексте, то это вызовет исключение <tt class="doctest"><span class="pre">AssertionError</span></tt> и вы получите немедленное уведомление о об этой проблеме.</p>
<p>Когда вы думаете, что нашли ошибку, рассмотрите ваше решение как гипотезу.
Попробуйте предсказать эффект вашего исправления ошибки до повторного запуска программы.
Если ошибка не устранена, не попадайте в ловушку слепого изменения кода в надежде, что он волшебным образом снова начнет работать.
Вместо этого для каждого изменения попытайтесь сформулировать гипотезу о том, что не так и почему изменение будет решать эту проблему.  Затем отмените изменения, если проблема не была решена.</p>
<p>При разработке программы, расширении ее функциональных возможностей и исправлении любых ошибок, полезно иметь набор тестов.
Это называется <a name="regression_testing_index_term"></a><span class="termdef">регрессионным тестированием</span>, так как предназначено для обнаружения ситуаций, когда код "регрессирует" - то есть изменение кода имеет непреднамеренный побочный эффект разрушения того, что раньше работало.  Python обеспечивает простую основу регрессионного тестирования в виде <tt class="doctest"><span class="pre">doctest</span></tt> модуля.  Этот модуль ищет в файле кода или документации блоки текста, которые выглядят как интерактивный сеанс Python, имеющий форму, которую вы уже видели много раз в этой книге.  Он выполняет команды Python, которые он находит, и проверяет, чтобы их выход соответствовал выходу, указанному в исходном файле.  Всякий раз, когда есть несоответствие, он сообщает об ожидаемых и фактических значениях.  Для получения дополнительной информации, пожалуйста, обратитесь к документации по <tt class="doctest"><span class="pre">doctest</span></tt> на странице <tt class="doctest"><span class="pre">http://docs.python.org/library/doctest.html</span></tt>.  Помимо своего значения для регрессионного тестирования, <tt class="doctest"><span class="pre">doctest</span></tt> модуль полезен для обеспечения того, чтобы ваша документация программного обеспечения остается синхронизированной с вашим кодом.</p>
<p>Пожалуй, самая важная оборонительная стратегия программирования состоит в том, чтобы изложить свой код ясно, выбрать значимые имена переменных и функций, а также упростить код, где это возможно, разлагая его на функции и модули с хорошо документированными интерфейсами.</p>
</div>
</div>
<div class="section" id="algorithm-design">
<span id="sec-algorithm-design"></span><h2>4.7 Алгоритм проектирования</h2>
<p>В этом разделе обсуждаются более сложные понятия, которые вы возможно предпочтете пропустить, первый раз читая эту главу.</p>
<p>Большая часть алгоритмического решения проблемы заключается в выборе или адаптации соответствующего алгоритма для вашей задачи.  Иногда существует несколько альтернативных вариантов, и выбор лучшего зависит от знания того, как каждая альтернатива работает по мере роста данных.
Целые книги написаны на эту тему, а у нас есть только возможность, чтобы ввести некоторые ключевые понятия и немного поговорить о подходах, которые являются наиболее распространенными в обработке естественного языка.</p>
<p>Наиболее известная стратегия известна как <a name="divide_and_conquer_index_term"></a><span class="termdef">разделяй и властвуй</span>.
Мы атакуем проблему размера <em>n</em>, разделив ее на две задачи размера <em>n/2</em>, решите эти проблемы и объедините их результаты в решение исходной задачи.
Например, предположим, что у нас была стопка карт с одним словом, написанным на каждой карточке.
Мы могли бы отсортировать эту стопку, разделив ее пополам и отдав ее двум другим людям для сортировки (они могли бы сделать то же самое, в свою очередь).  Затем, когда две отсортированных стопки возвращаются, несложно объединить их в одну отсортированную.
См <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fig-mergesort">4.8</a> для иллюстрации этого процесса.</p>
<span class="target" id="fig-mergesort"></span><div class="figure" id="fig-mergesort">
<img alt="../images/mergesort.png" src="http://www.nltk.org/images/mergesort.png" style="width:650.1px;height:345.0px">
<p class="caption"><span class="caption-label">Рисунок 4.8:</span> Сортировка по принципу разделяй и властвуй: для сортировки массива, мы разделили его пополам и отсортировали каждую половину (рекурсивно); мы соединяем каждую отсортированную половину обратно в целый список (опять рекурсивно); этот алгоритм известен как "Merge Sort".</p>
</div>
<p>Другим примером может служить процесс поиска слова в словаре.  Мы открываем книгу где-то около середины и сравниваем наше слово с текущей страницей.  Если это наше слово раньше в словаре, мы повторяем процесс для первой половины; если позже мы используем вторую половину.  Этот метод поиска называется <span class="example">бинарный поиск</span> , так как он разделяет проблему пополам на каждом шагу.</p>
<p>В другом подходе к разработке алгоритма, мы атакуем проблему, превращая ее в экземпляр проблемы, которую мы уже знаем, как решить.
Например, для того, чтобы обнаружить повторяющиеся записи в списке, мы можем <a name="pre_sort_index_term"></a><span class="termdef">предварительно отсортировать</span> список, а затем сканировать его один раз, чтобы проверить, есть ли в нем какие-либо идентичные соседние пары элементов.</p>
<div class="section" id="recursion">
<h3>Рекурсия</h3>
<p>Приведенные выше примеры сортировки и поиска имеют поразительное свойство: решить проблему размера <span class="math">n</span>, мы должны разбить ее пополам, а затем работать над одной или несколькими проблемами размера <span class="math">n/2</span>.
Обычный способ реализации таких методов использует <a name="recursion_index_term"></a><span class="termdef">рекурсию</span>.
Определим функцию <span class="math">f</span>, которая упрощает задачу, и <span class="emphasis">вызывает себя</span>, чтобы решить одну или несколько более простых экземпляров той же задачи.  Затем она объединяет результаты в решение исходной задачи.</p>
<p>Например, предположим, что у нас есть набор из <span class="math">n</span> слов и вы хотите подсчитать, сколькими различными способами они могут быть объединены в последовательность слов.  Если у нас есть только одно слово <span class="math">(n=1)</span>, есть только один способ составить последовательность.  Если у нас есть набор из двух слов, есть два способа, чтобы составить из них последовательность.  Для трех слов есть шесть вариантов.  В общем случае для <span class="math">n</span> слов есть <span class="math">n</span>×<span class="math">n-1</span>×...×2×1 способов (т.е. факториал <span class="math">n</span>).  Мы можем закодировать это следующим образом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def factorial1(n):
...     result = 1
...     for i in range(n):
...         result *= (i+1)
...     return result</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Однако есть также рекурсивный алгоритм для решения этой задачи, основанный на следующем наблюдении.  Предположим, у нас есть способ построить все варианты расположения элементов для <span class="math">n-1</span> различных слов.  Тогда для каждой такой последовательности, есть <span class="math">n</span> мест, куда мы можем вставить новое слово: в начало, в конец или любую из <span class="math">n-2</span> позиций между словами.  Таким образом, мы просто умножаем число найденных решений при <span class="math">n -1</span> на значение <span class="math">n</span>.
Нам также необходим <a name="base_case_index_term"></a><span class="termdef">базовый случай</span>, чтобы сказать, что если у нас только одно слово, то есть только одна последовательность.  Мы можем закодировать это следующим образом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def factorial2(n):
...     if n == 1:
...         return 1
...     else:
...         return n * factorial2(n-1)</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX clarify that size != depth here -->
<p>Эти два алгоритма решают одинаковую задачу.  Один использует итерацию, а другой использует рекурсию.
Мы можем использовать рекурсию для навигации по глубоко вложенному объекту, например, иерархии гипернимов WordNet.  Давайте посчитаем размер иерархии гипернимов, начинающуюся на данном синсете <span class="math">s</span>.  Мы сделаем это, находя размер каждого из  гипонимов <span class="math">s</span>, затем складывая их вместе (мы также добавим 1 для самого синсета).  Следующая функция <tt class="doctest"><span class="pre">size1()</span></tt> делает эту работу; обратите внимание, что тело функции включает в себя рекурсивный вызов <tt class="doctest"><span class="pre">size1():</span></tt></p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def size1(s):
...     return 1 + sum(size1(child) for child in s.hyponyms())</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы также можем разработать итеративное решение этой проблемы, которое обрабатывает иерархию по уровням.  Первый уровень - сам синсет <a class="reference internal" href="http://www.nltk.org/book/ch04.html#first-layer"><span id="ref-first-layer"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, затем все гипонимы синсета, затем все гипонимы этих гипонимов.  Каждый раз, проходя цикл программа вычисляет следующий слой, находя гипонимы всего, что было в последнем уровне <a class="reference internal" href="http://www.nltk.org/book/ch04.html#update-layer"><span id="ref-update-layer"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>.
Это решение также ведет счет общего количества синсетов, которое было найдено <a class="reference internal" href="http://www.nltk.org/book/ch04.html#update-total"><span id="ref-update-total"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; def size2(s):
...     layer = [s] 
...     total = 0
...     while layer:
...         total += len(layer) 
...         layer = [h for c in layer for h in c.hyponyms()] 
...     return total</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мало того, что итеративное решение гораздо длиннее, его еще и труднее интерпретировать.
Это заставляет нас думать процедурно и отслеживать , что происходит с переменными <tt class="doctest"><span class="pre">layer</span></tt> и <tt class="doctest"><span class="pre">total</span></tt> во времени.  Давайте удовлетворимся тем, что оба решения дают одинаковый результат.  Мы будем использовать другую форму предложения импорта, позволяющую нам сокращать имя <tt class="doctest"><span class="pre">wordnet</span></tt> до <tt class="doctest"><span class="pre">wn</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk.corpus import wordnet as wn
&gt;&gt;&gt; dog = wn.synset('dog.n.01')
&gt;&gt;&gt; size1(dog)
190
&gt;&gt;&gt; size2(dog)
190</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>В качестве последнего примера рекурсии, давайте используем ее, чтобы <span class="emphasis">построить</span> глубоко вложенный объект.
<a name="letter_trie_index_term"></a><span class="termdef">Буквенное древо</span> представляет собой структуру данных, которая может быть использована для индексации словаря, по буквам.  (Название основано на слове <span class="emphasis">retrieval</span> (поиск)).
Например, если переменная <tt class="doctest"><span class="pre">trie</span></tt> содержала бы буквенное дерево, тогда <tt class="doctest"><span class="pre">trie[<span class="pysrc-string">'c'</span>]</span></tt> было бы меньшим буквенным деревом со всеми словами, начинающимися с <span class="example">c</span>.
<a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-trie">4.9</a> демонстрирует рекурсивный процесс построения такого дерева с использованием словарей Python (<a class="reference external" href="http://www.nltk.org/book/ch05.html#sec-dictionaries">3</a>).
Для того, чтобы вставить слово <span class="example">chien</span> (французское слово <span class="example">собака</span>), мы отщепим <span class="example">c</span> и рекурсивно вставим <span class="example">hien</span> в поддерево <tt class="doctest"><span class="pre">trie[<span class="pysrc-string">'с'</span>]</span></tt>.  Рекурсия продолжается до тех пор пока в слове не закончатся буквы, тогда в качестве значения мы помещаем предполагаемую величину (в данном случае слово <span class="example">собака</span>).</p>
<span class="target" id="code-trie"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def insert(trie, key, value):
    if key:
        first, rest = key[0], key[1:]
        if first not in trie:
            trie[first] = {}
        insert(trie[first], rest, value)
    else:
        trie['value'] = value</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; trie = {}
&gt;&gt;&gt; insert(trie, 'chat', 'cat')
&gt;&gt;&gt; insert(trie, 'chien', 'dog')
&gt;&gt;&gt; insert(trie, 'chair', 'flesh')
&gt;&gt;&gt; insert(trie, 'chic', 'stylish')
&gt;&gt;&gt; trie = dict(trie)               # for nicer printing
&gt;&gt;&gt; trie['c']['h']['a']['t']['value']
'cat'
&gt;&gt;&gt; pprint.pprint(trie, width=40)
{'c': {'h': {'a': {'t': {'value': 'cat'}},
                  {'i': {'r': {'value': 'flesh'}}},
             'i': {'e': {'n': {'value': 'dog'}}}
                  {'c': {'value': 'stylish'}}}}}</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_trie.py" type="text/x-python"><span class="caption-label">Пример 4.9 (code_trie.py)</span></a> : <span class="caption-label">Рисунок 4.9:</span> Построение буквенного дерева: рекурсивная функция, которая строит вложенную структуру словарного типа; каждый уровень вложенности содержит все слова с заданным префиксом и поддерево, содержащее все возможные продолжения.</p></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Внимание!</p>
<p class="last">Несмотря на простоту рекурсивного программирования, за это приходится платить определенную цену.
Каждый раз, когда функция вызывается, некоторые сведения о состоянии должны быть помещены в стек, чтобы после ее завершения, выполнение могло продолжиться с того момента, где оно было прервано.  По этой причине, итеративные решения часто более эффективны, чем рекурсивные решения.</p>
</div>
</div>
<div class="section" id="space-time-tradeoffs">
<h3>Пространственно-временные компромиссы</h3>
<p>Мы можем иногда значительно ускорить выполнение программы путем создания вспомогательной структуры данных, такой как индекс.  Листинг в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-search-documents">4.10</a> реализует простую систему поиска текста для корпуса обзоров фильмов (Movie Reviews Corpus).  Благодаря индексации коллекции документов он обеспечивает гораздо более быстрый поиск.</p>
<span class="target" id="code-search-documents"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def raw(file):
    contents = open(file).read()
    contents = re.sub(r'&lt;.*?&gt;', ' ', contents)
    contents = re.sub('\s+', ' ', contents)
    return contents

def snippet(doc, term):
    text = ' '*30 + raw(doc) + ' '*30
    pos = text.index(term)
    return text[pos-30:pos+30]

print("Building Index...")
files = nltk.corpus.movie_reviews.abspaths()
idx = nltk.?)(&gt; <span class="pysrc-string">','</span></span> <span class="pysrc-string">',</span> Содержание) содержание = re.sub <span class="pysrc-string">(' \ s + <span class="pysrc-string">','</span></span> <span class="pysrc-string">',</span> содержание) возвращают содержимое <span class="pysrc-keyword">Защиту</span> <span class="pysrc-defname">фрагмент кода</span> (DOC, термин): текст <span class="pysrc-string">=' '*</span> 30 + сырец (док) <span class="pysrc-string">+' '*</span> 30 пос = text.index (термин) возвращение текст [поз-30: поз + 30] <span class="pysrc-keyword">печать</span> ( <span class="pysrc-string">"Index Building ...")</span> файлы = nltk.corpus.movie_reviews.abspaths () IDX = NLTK.Index((w, f) for f in files for w in raw(f).split())

query = ''
while query != "quit":
    query = input("query&gt; ")     # use raw_input() in Python 2
    if query in idx:
        for doc in idx[query]:
            print(snippet(doc, query))
    else:
        print("Not found")</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_search_documents.py" type="text/x-python"><span class="caption-label">Пример 4.10 (code_search_documents.py)</span></a> : <span class="caption-label">Листинг 4.10:</span> Простая система поиска текста</p></td></tr>
</table></div>
<p>Более тонкий пример пространственно-временного компромисса включает в себя замену токенов свода целочисленными идентификаторами.  Мы создаем словарь для корпуса, список, в котором каждое слово хранится один раз, а затем инвертируем этот список так, что мы можем найти идентификатор любого слова.  Каждый документ предварительно обрабатывается, так что список слов становится списком целых чисел.
Любые языковые модели теперь могут работать с целыми числами.  Смотрите листинг в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-strings-to-ints">4.11</a> для примера того, как сделать это для размеченного корпуса.</p>
<!-- XXX further discussion and performance comparison. -->
<span class="target" id="code-strings-to-ints"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def preprocess(tagged_corpus):
    words = set()
    tags = set()
    for sent in tagged_corpus:
        for word, tag in sent:
            words.add(word)
            tags.add(tag)
    wm = dict((w, i) for (i, w) in enumerate(words))
    tm = dict((t, i) for (i, t) in enumerate(tags))
    return [[(wm[w], tm[t]) for (w, t) in sent] for sent in tagged_corpus]</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_strings_to_ints.py" type="text/x-python"><span class="caption-label">Пример 4.11 (code_strings_to_ints.py)</span></a> : <span class="caption-label">Листинг 4.11:</span> Предварительная обработка данных размеченного корпуса, преобразующая все слова и теги в целые числа</p></td></tr>
</table></div>
<p>Другим примером пространственно-временного компромисса является поддержание словарного списка.
Если вам нужно обработать входной текст, чтобы проверить, что все слова содержатся в существующем словаре, словарь должен храниться в виде набора, а не списка.
Элементы набора автоматически индексируются, поэтому проверка членства в большом наборе будет намного быстрее, чем проверка членства в соответствующем списке.</p>
<p>Мы можем проверить это утверждение с помощью модуля <tt class="doctest"><span class="pre">timeit</span></tt>.
Класс <tt class="doctest"><span class="pre">Timer</span></tt> имеет два параметра, предложение, которое выполняется множество раз, и код установки, который выполняется один раз в начале.  Мы будем моделировать словарь в 100.000 элементов с помощью списка <a class="reference internal" href="http://www.nltk.org/book/ch04.html#vocab-list"><span id="ref-vocab-list"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> или набора <a class="reference internal" href="http://www.nltk.org/book/ch04.html#vocab-set"><span id="ref-vocab-set"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a> целых чисел.  Тестовое предложение будет генерировать случайный элемент, который имеет 50% шанс быть в словаре <a class="reference internal" href="http://www.nltk.org/book/ch04.html#vocab-statement"><span id="ref-vocab-statement"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from timeit import Timer
&gt;&gt;&gt; vocab_size = 100000
&gt;&gt;&gt; setup_list = "import random; vocab = range(%d)" % vocab_size 
&gt;&gt;&gt; setup_set = "import random; vocab = set(range(%d))" % vocab_size 
&gt;&gt;&gt; statement = "random.randint(0, %d) in vocab" % (vocab_size * 2) 
&gt;&gt;&gt; print(Timer(statement, setup_list).timeit(1000))
2.78092288971
&gt;&gt;&gt; print(Timer(statement, setup_set).timeit(1000))
0.0037260055542</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Выполнение 1000 тестов на членство в списке занимает в общей сложности 2,8 секунды, в то время как эквивалентные испытания для набора занимают всего лишь 0,0037 секунды или на три порядка быстрее!</p>
</div>
<div class="section" id="dynamic-programming">
<h3>Динамическое программирование</h3>
<p>Динамическое программирование - это общая методика для проектирования алгоритмов, которая широко используются в обработке естественного языка.  Термин «программирование» употребляется в ином смысле, нежели вы могли бы ожидать, означающем планирование или составление расписания.  Динамическое программирование используется, когда проблема содержит перекрывающиеся подзадачи.  Вместо вычисления решения этих подзадач многократно, мы просто храним их в справочной таблице.
В оставшейся части этого раздела мы представим динамическое программирование, но в несколько ином контексте для синтаксического разбора.</p>
<p>Пингала был индийским автором, который жил примерно в 5 веке до нашей эры, и написал трактат по санскритской просодии под названием <em>Чанда-шастра</em>.
Вираанка расширил эту работу около 6 века н.э., изучая число способов объединения коротких и длинных слогов, чтобы создать метр длинной <em>n</em>.  Короткие слоги, отмеченные <em>S</em>, занимают одну единицу длины, в то время как длинные слоги, отмеченные <em>L</em>, занимают две.
Пингала нашел, например, что существует пять способов построить метр длины 4: <em>V</em><sub>4</sub> = <em>{LL, SSL, SLS, LSS, SSSS}</em>.  Заметим, что мы можем разделить <em>V</em><sub>4</sub> на два подмножества, которые начинаются с <em>L</em> и те, которые начинаются с <em>S</em>, как показано на <a class="reference internal" href="http://www.nltk.org/book/ch04.html#ex-v4">(1)</a>.</p>
<span class="target" id="ex-v4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><pre class="literal-block">
V4 =
  LL, LSS
    i.e. L prefixed to each item of V2 = {L, SS}
  SSL, SLS, SSSS
    i.e. S prefixed to each item of V3 = {SL, LS, SSS}

</pre>
</td></tr></table></p>
<span class="target" id="code-virahanka"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
def virahanka1(n):
    if n == 0:
        return [""]
    elif n == 1:
        return ["S"]
    else:
        s = ["S" + prosody for prosody in virahanka1(n-1)]
        l = ["L" + prosody for prosody in virahanka1(n-2)]
        return s + l

def virahanka2(n):
    lookup = [[""], ["S"]]
    for i in range(n-1):
        s = ["S" + prosody for prosody in lookup[i+1]]
        l = ["L" + prosody for prosody in lookup[i]]
        lookup.append(s + l)
    return lookup[n]

def virahanka3(n, lookup={0:[""], 1:["S"]}):
    if n not in lookup:
        s = ["S" + prosody for prosody in virahanka3(n-1)]
        l = ["L" + prosody for prosody in virahanka3(n-2)]
        lookup[n] = s + l
    return lookup[n]

from nltk import memoize
@memoize
def virahanka4(n):
    if n == 0:
        return [""]
    elif n == 1:
        return ["S"]
    else:
        s = ["S" + prosody for prosody in virahanka4(n-1)]
        l = ["L" + prosody for prosody in virahanka4(n-2)]
        return s + l</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; virahanka1(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
&gt;&gt;&gt; virahanka2(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
&gt;&gt;&gt; virahanka3(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
&gt;&gt;&gt; virahanka4(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_virahanka.py" type="text/x-python"><span class="caption-label">Пример 4.12 (code_virahanka.py)</span></a> : <span class="caption-label">Листинг 4.12</span>: Четыре способа вычислить санскритский метр: (I) рекурсивный; (II) динамическое программирование снизу вверх; (III) динамическое программирование сверху вниз; и (IV) встроенное запоминание.</p></td></tr>
</table></div>
<p>С помощью этого наблюдения, мы можем написать небольшую рекурсивную функцию под названием <tt class="doctest"><span class="pre">virahanka1()</span></tt>, чтобы вычислить эти метры, показанные в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-virahanka">4.12</a>.
Обратите внимание, что для того, чтобы вычислить <em>V</em><sub>4</sub> мы вычислим сначала <em>V</em><sub>3</sub> и <em>V</em><sub>2</sub>.  Но для вычисления <em>V</em><sub>3</sub>, мы должны сначала вычислить <em>V</em><sub>2</sub> и <em>V</em><sub>1</sub>.  Эта <a name="call_structure_index_term"></a><span class="termdef">структура вызова</span> изображена на схеме <a class="reference internal" href="http://www.nltk.org/book/ch04.html#ex-call-structure">(2)</a>.</p>
<span class="target" id="ex-call-structure"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><img alt="tree_images / CH04-дерево-1.png" class="align-top" src="http://www.nltk.org/book/tree_images/ch04-tree-1.png" style="width:178.0px;height:144.0px"></td></tr></table></p>
<p>Как вы можете видеть, <em>V</em><sub>2</sub> вычисляется дважды.
Это может показаться не существенной проблемой, но она оказывается довольно расточительной, по мере того, как <em>n</em> становится большим: для вычисления <em>V</em><sub>20</sub>, используя эту рекурсивную технику, мы бы вычислили <em>V</em><sub>2</sub> 4.181 раз; а <em>V</em><sub>40</sub> мы бы вычислили <em>V</em><sub>2</sub> 63.245.986 раз!
Гораздо лучшей альтернативой является хранение значения <em>V</em><sub>2</sub> в таблице и найти его всякий раз, когда нам это нужно.  То же самое касается и других значений, таких как <em>V</em><sub>3</sub> и так далее.  Функция <tt class="doctest"><span class="pre">virahanka2()</span></tt> реализует подход динамического программирования к проблеме.  Он работает путем заполнения таблицы (называемый <tt class="doctest"><span class="pre">поисковой</span></tt>) решениями <em>всех</em> меньших экземпляров задачи, останавливаясь, когда мы достигаем искомое значение.
В этот момент мы считываем значение из таблицы и возвращаем его.  Важно отметить, что каждая подпроблема решается только один раз.</p>
<p>Обратите внимание на то, что подход , принятый в <tt class="doctest"><span class="pre">virahanka2()</span></tt> заключается в решении меньших проблем на пути к решению больших проблем.  Соответственно это решение известно как подход <a name="bottom_up_index_term"></a> <span class="termdef">снизу вверх</span>.  К сожалению, этот подход оказывается весьма расточительным для некоторых приложений, так как он может вычислять решения подзадач, которые никогда не потребуются для решения основной задачи.  Этого бесполезного вычисления можно избежать с помощью подхода <a name="top_down_index_term"></a><span class="termdef">сверху вниз</span>, который показан в функции <tt class="doctest"><span class="pre">virahanka3 ()</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-virahanka">4.12</a> .
В отличие от подхода снизу вверх, этот подход является рекурсивным.  Это позволяет избежать огромных потерь <tt class="doctest"><span class="pre">virahanka1()</span></tt> путем проверки того, сохранял ли он ранее этот результат.  Если нет, то он вычисляет результат рекурсивно и сохранит его в таблице.  Последний шаг состоит в том, чтобы вернуть сохраненный результат.  Последний метод в <tt class="doctest"><span class="pre">virahanka4()</span></tt> состоит в том, чтобы использовать Python "декоратор" под названием <tt class="doctest"><span class="pre">memoize</span></tt>, который заботится о сохранении работы, проделанной <tt class="doctest"><span class="pre">virahanka3()</span></tt>, не загромождая программу.
Этот процесс "запоминания" сохраняет результат каждого предыдущего вызова функции вместе с параметрами, которые были использованы.
Если функция затем вызывается с теми же параметрами, он возвращает сохраненный результат вместо перерасчета его.
(Этот аспект синтаксиса Python выходит за рамки данной книги.)</p>
<p>На этом завершается наше краткое введение в динамическое программирование.
Мы снова сталкнемся с ним в <a class="reference external" href="http://www.nltk.org/book/ch08.html#sec-parsing">4</a>.</p>
</div>
</div>
<div class="section" id="a-sample-of-python-libraries">
<span id="sec-libraries"></span><h2>4.8 Образец библиотек Python</h2>
<p>Python имеет сотни сторонних библиотек, специализированных программных пакетов, которые расширяют функциональность Python.  NLTK является одной из таких библиотек.  Для того, чтобы в полной мере реализовать силу программирования на Python, вы должны быть знакомы с несколькими другими библиотеками.
Большинство из них должны быть установлены вручную на компьютере.</p>
<div class="section" id="matplotlib">
<h3>Matplotlib</h3>
<p>Python имеет некоторые библиотеки, которые полезны для визуализации данных языка.
Пакет Matplotlib поддерживает сложные функции с интерфейсом в стиле MATLAB, доступен на странице <tt class="doctest"><span class="pre">http://matplotlib.sourceforge.net/</span></tt>.</p>
<p>До сих пор мы были сосредоточены на текстовой репрезентации и использовании отформатированных предложений печати, чтобы получить выход, выстроенный в колонки.  Порой бывает полезно представить числовые данные в графическом виде, так как это часто облегчает обнаружение закономерностей.  Например, в <a class="reference external" href="http://www.nltk.org/book/ch03.html#code-modal-tabulate">3.7</a> мы видели таблицу чисел, показывающих частоту отдельных модальных глаголов в корпуск Брауна, классифицированных по жанру.  Программа в листинге <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-modal-plot">4.13</a> представляет ту же информацию в графическом формате.  Вывод показан на рисунке <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fig-modal-genre">4.14</a> (цветной рисунок на графическом дисплее).</p>
<span class="target" id="code-modal-plot"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
from numpy import arange
from matplotlib import pyplot

colors = 'rgbcmyk' # red, green, blue, cyan, magenta, yellow, black

def bar_chart(categories, words, counts):
    "Plot a bar chart showing counts for each word by category"
    ind = arange(len(words))
    width = 1 / (len(categories) + 1)
    bar_groups = []
    for c in range(len(categories)):
        bars = pyplot.bar(ind+c*width, counts[categories[c]], width,
                         color=colors[c % len(colors)])
        bar_groups.append(bars)
    pyplot.xticks(ind+width, words)
    pyplot.legend([b[0] for b in bar_groups], categories, loc='upper left')
    pyplot.ylabel('Frequency')
    pyplot.title('Frequency of Six Modal Verbs by Genre')
    pyplot.show()</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; genres = ['news', 'religion', 'hobbies', 'government', 'adventure']
&gt;&gt;&gt; modals = ['can', 'could', 'may', 'might', 'must', 'will']
&gt;&gt;&gt; cfdist = nltk.ConditionalFreqDist(
...              (genre, word)
...              for genre in genres
...              for word in nltk.corpus.brown.words(categories=genre)
...              if word in modals)
...
&gt;&gt;&gt; counts = {}
&gt;&gt;&gt; for genre in genres:
...     counts[genre] = [cfdist[genre][word] for word in modals]
&gt;&gt;&gt; bar_chart(genres, modals, counts)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_modal_plot.py" type="text/x-python"><span class="caption-label">Пример 4.13 (code_modal_plot.py)</span></a> : <span class="caption-label">Рисунок 4.13:</span> Частота модальных глаголов в различных разделах корпуса Брауна</p></td></tr>
</table></div>
<span class="target" id="fig-modal-genre"></span><div class="figure" id="fig-modal-genre">
<img alt="../images/modal_genre.png" src="http://www.nltk.org/images/modal_genre.png" style="width:613.0px;height:463.0px">
<p class="caption"><span class="caption-label">Рисунок 4.14:</span> Гистограмма, отображающая частоту модальных глаголов в различных разделах корпуса Брауна: эта визуализация была произведена программой из листинга <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-modal-plot">4.13</a>.</p>
</div>
<!-- def count_words_by_tag(t, genres):
    cfdist = nltk.ConditionalFreqDist()
    for genre in genres:
        for (word,tag) in nltk.corpus.brown.tagged_words(categories=genre):
            if tag == t:
                 cfdist[genre][word.lower()] += 1
    return cfdist -->
<p>Из гистограммы сразу видно, что <span class="example">may</span> и <span class="example">must</span> имеют практически одинаковые относительные частоты.  То же самое касается <span class="example">could</span> и <span class="example">might</span>.</p>
<p>Кроме того, такие визуализации данных  можно генерировать на лету.
Например, веб-страница с формой ввода может позволить посетителям задать параметры поиска, отправьте форму и увидеть динамически генерируемую визуализацию.
Для этого мы должны указать <tt class="doctest"><span class="pre">Agg</span></tt> бэкэнд для <tt class="doctest"><span class="pre">Matplotlib</span></tt>, который представляет собой библиотеку для создания растровых (пиксельных) изображений <a class="reference internal" href="http://www.nltk.org/book/ch04.html#agg-backend"><span id="ref-agg-backend"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.
Далее, мы используем все те же методы Matplotlib, как и раньше, но вместо того, чтобы отображать результат на графическом терминале с помощью <tt class="doctest"><span class="pre">pyplot.show()</span></tt>, мы сохраняем его в файл с помощью <tt class="doctest"><span class="pre">pyplot.savefig()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#pyplot-savefig"><span id="ref-pyplot-savefig"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>.  Мы указываем имя файла, а затем печатаем HTML-разметку, которая указывает веб-браузеру загрузить файл.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from matplotlib import use, pyplot
&gt;&gt;&gt; use('Agg') 
&gt;&gt;&gt; pyplot.savefig('modals.png') 
&gt;&gt;&gt; print('Content-Type: text/html')
&gt;&gt;&gt; print()
&gt;&gt;&gt; print('&lt;html&gt;&lt;body&gt;')
&gt;&gt;&gt; print('&lt;img src="modals.png"/&gt;')
&gt;&gt;&gt; print('&lt;/body&gt;&lt;/html&gt;')</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="networkx">
<h3>NetworkX</h3>
<p>Пакет NetworkX предназначен для определения и работы со структурами, состоящими из узлов и ребер, известными как <a name="graphs_index_term"></a><span class="termdef">графы</span>.  Он доступен на странице <tt class="doctest"><span class="pre">https://networkx.lanl.gov/</span></tt>. NetworkX может быть использован в сочетании с Matplotlib для визуализации сетей, таких как WordNet (семантическая сеть, которую мы представили в <a class="reference external" href="http://www.nltk.org/book/ch02.html#sec-wordnet">5</a>).  Программа в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-networkx">4.15</a> инициализирует пустой граф <a class="reference internal" href="http://www.nltk.org/book/ch04.html#define-graph"><span id="ref-define-graph"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a> затем проходит иерархию гипернимов WordNet, добавляя ребра на граф <a class="reference internal" href="http://www.nltk.org/book/ch04.html#add-edge"><span id="ref-add-edge"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.
Обратите внимание на то, что обход является рекурсивным <a class="reference internal" href="http://www.nltk.org/book/ch04.html#recursive-traversal"><span id="ref-recursive-traversal"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>, применяя методы программирования, описанные в <a class="reference internal" href="http://www.nltk.org/book/ch04.html#sec-algorithm-design">4.7</a>.  Полученное отображение показано на рисунке <a class="reference internal" href="http://www.nltk.org/book/ch04.html#fig-dog-graph">4.16</a>.</p>
<span class="target" id="code-networkx"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
import networkx as nx
import matplotlib
from nltk.corpus import wordnet as wn

def traverse(graph, start, node):
    graph.depth[node.name] = node.shortest_path_distance(start)
    for child in node.hyponyms():
        graph.add_edge(node.name, child.name) 
        traverse(graph, start, child) 

def hyponym_graph(start):
    G = nxGraph() 
    G.depth = {}
    traverse(G, start, start)
    return G

def graph_draw(graph):
    nx.draw_graphviz(graph,
         node_size = [16 * graph.degree(n) for n in graph],
         node_color = [graph.depth[n] for n in graph],
         with_labels = False)
    matplotlib.pyplot.show()</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dog = wn.synset('dog.n.01')
&gt;&gt;&gt; graph = hyponym_graph(dog)
&gt;&gt;&gt; graph_draw(graph)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="http://www.nltk.org/book/pylisting/code_networkx.py" type="text/x-python"><span class="caption-label">Пример 4.15 (code_networkx.py)</span></a> : <span class="caption-label">Листинг 4.15:</span> Использование NetworkX и Matplotlib библиотек</p></td></tr>
</table></div>
<span class="target" id="fig-dog-graph"></span><div class="figure" id="fig-dog-graph">
<img alt="../images/dog-graph.png" src="http://www.nltk.org/images/dog-graph.png" style="width:810.4000000000001px;height:402.40000000000003px">
<p class="caption"><span class="caption-label">Рисунок 4.16:</span> Визуализация с помощью NetworkX и Matplotlib: Показана часть иерархии гипернимов WordNet, начиная с <tt class="doctest"><span class="pre">dog.n.01</span></tt> (самый темный узел в середине); размер узла определяется количеством детей узла, а цвет на расстоянии от узла <tt class="doctest"><span class="pre">dog.n.01</span></tt>; эта визуализация была произведена программой из листинга <a class="reference internal" href="http://www.nltk.org/book/ch04.html#code-networkx">4.15</a>.</p>
</div>
</div>
<div class="section" id="csv">
<h3>CSV</h3>
<p>Работа по анализу языка часто включает в себя представление данных в табличной форме (табуляцию), содержащих информацию о лексических единицах, или участниках эмпирического исследования, или лингвистических признаках, извлеченных из корпуса.  Вот фрагмент простого словаря в формате CSV:</p>
<div class="line-block">
<div class="line">sleep, sli:p, v.i, a condition of body and mind ...</div>
<div class="line">walk, wo:k, v.intr, progress by lifting and setting down each foot ...</div>
<div class="line">wake, weik, intrans, cease to sleep</div>
</div>
<p>Мы можем использовать библиотеку CSV Python, чтобы читать и записывать файлы в этом формате.
Например, мы можем открыть файл CSV с именем <tt class="doctest"><span class="pre">lexicon.csv</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch04.html#open-csv"><span id="ref-open-csv"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> и перебирать его строки <a class="reference internal" href="http://www.nltk.org/book/ch04.html#iterate-csv"><span id="ref-iterate-csv"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; import csv
&gt;&gt;&gt; input_file = open("lexicon.csv", "rb") 
&gt;&gt;&gt; for row in csv.reader(input_file): 
...     print(row)
['sleep', 'sli:p', 'v.i', 'a condition of body and mind ...']
<span class="pysrc-output">['walk', 'wo:k', 'v.intr', 'progress by lifting and setting down each foot ...']</span>
<span class="pysrc-output">['wake', 'weik', 'intrans', 'cease to sleep']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Каждая строка представляет собой просто список строковых значений.  Если какие-либо поля содержат числовые данные, они будут отображаться в виде строки и должны быть преобразованы с помощью <tt class="doctest"><span class="pre">int()</span></tt> или <tt class="doctest"><span class="pre">float()</span></tt>.</p>
</div>
<div class="section" id="numpy">
<h3>NumPy</h3>
<p>Пакет NumPy обеспечивает существенную поддержку для численной обработки в Python.
NumPy имеет объект - многомерный массив, который легко инициализировать и использовать:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; cube = array([ [[0,0,0], [1,1,1], [2,2,2]],
...                 [[3,3,3], [4,4,4], [5,5,5]],
...                [[6,6,6], [7,7,7], [8,8,8]] ])
&gt;&gt;&gt; cube[1,1,1]
4
&gt;&gt;&gt; cube[2].transpose()
array([[6, 7, 8],
       [6, 7, 8],
       [6, 7, 8]])
&gt;&gt;&gt; cube[2,1:]
array([[7, 7, 7],
       [8, 8, 8]])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>NumPy включает в себя функции линейной алгебры.  Здесь мы выполняем сингулярное разложение матрицы, операцию, используемую в <a name="latent_semantic_analysis_index_term"></a><span class="termdef">латентном семантическом анализе</span>, помогающую определить неявные концепции в коллекции документов.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from numpy import linalg
&gt;&gt;&gt; a=array([[4,0], [3,-5]])
&gt;&gt;&gt; u,s,vt = linalg.svd(a)
&gt;&gt;&gt; u
array([[-0.4472136 , -0.89442719],
       [-0.89442719,  0.4472136 ]])
&gt;&gt;&gt; s
array([ 6.32455532,  3.16227766])
&gt;&gt;&gt; vt
array([[-0.70710678,  0.70710678],
       [-0.70710678, -0.70710678]])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Пакет кластеризации NLTK <tt class="doctest"><span class="pre">nltk.cluster</span></tt> широко использует NumPy массивы и включает в себя поддержку для кластеризации <span class="math">к</span>-средних, ЕМ-алгоритма Гауса, агломерационной кластеризации групповых средних и дендрограмм зависимостей.
Для получения дополнительной информации, наберите <tt class="doctest"><span class="pre">help(nltk.cluster)</span></tt>.</p>
</div>
<div class="section" id="other-python-libraries">
<h3>Другие библиотеки Python</h3>
<p>Есть много других библиотек Python, и вы можете найти их с помощью Python индекса пакетов <tt class="doctest"><span class="pre">http://pypi.python.org/</span></tt>. Многие библиотеки предоставляют интерфейс для внешнего программного обеспечения, например, реляционных баз данных (например , <tt class="doctest"><span class="pre">mysql-python</span></tt>) и больших коллекций документов (например , <tt class="doctest"><span class="pre">PyLucene</span></tt>).
Многие другие библиотеки предоставляют доступ к форматам файлов, таким как PDF, MSWord и XML <tt class="doctest"><span class="pre">(pypdf</span></tt>, <tt class="doctest"><span class="pre">pywin32</span></tt>, <tt class="doctest"><span class="pre">xml.etree</span></tt>), RSS-каналам (например, <tt class="doctest"><span class="pre">feedparser</span></tt>) и электронной почте (например, <tt class="doctest"><span class="pre">imaplib</span></tt>, <tt class="doctest"><span class="pre">email</span></tt>).</p>
</div>
</div>
<div class="section" id="summary">
<h2>4.9 Резюме</h2>
<ul class="simple">
<li>Python использует объектные ссылки для присвоения и передачи параметров; например, если <tt class="doctest"><span class="pre">a</span></tt> список и мы присваиваем <tt class="doctest"><span class="pre">b = а</span></tt>, тогда любая операция с <tt class="doctest"><span class="pre">a</span></tt> будет изменять <tt class="doctest"><span class="pre">b</span></tt> и наоборот.</li>
<li>Оператор <tt class="doctest"><span class="pre"><span class="pysrc-keyword">is</span></span></tt> проверяет, являются ли два объекта идентичными внутренними объектами, в то время как <tt class="doctest"><span class="pre">==</span></tt> проверяет, являются ли два объекта эквивалентными.  Это различие параллелено различию типа и токена.</li>
<li>Строки, списки и кортежи различные виды последовательностей, поддерживающих общие операции, такие как индексирование, срез, <tt class="doctest"><span class="pre">len()</span></tt>, <tt class="doctest"><span class="pre">sorted()</span></tt> и проверка членства с помощью <tt class="doctest"><span class="pre"><span class="pysrc-keyword">in</span></span></tt>.</li>
<li>Декларативный стиль программирования, как правило, производит более компактный, легко читаемый код; "рукописные" переменные цикла, как правило, не нужны; когда последовательность должна быть перечислена, используйте <tt class="doctest"><span class="pre">enumerate()</span></tt>.</li>
<li>Функции являются одной из важнейших абстракций программирования: ключевые понятия, которые необходимо понимать: передача параметров, контекст переменной и строки документации.</li>
<li>Функция служит в качестве пространства имен: имена, определенные внутри функции, не видны вне этой функции, если эти имена не объявляются глобальными.</li>
<li>Модули позволяют локализовать логически связанные материалы в одном файле.
Модуль служит в качестве пространство имен: имена, определенные в модуле - такие, как переменные и функции - не видны другим модулям, если эти имена не импортируются.</li>
<li>Динамическое программирование представляет собой метод проектирования алгоритма, широко используемый в NLP, который хранит результаты предыдущих вычислений для того, чтобы избежать ненужных перерасчетов.</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>7 Дополнительные материалы</h2>
<p>В этой главе мы коснулись многих тем программирования, некоторые специфичные для Python, другие весьма общего характера.  Мы только прошли по поверхности, и вы возможно захотите прочитать больше об этом, начав с дополнительных материалов к этой главе, доступных на <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>.</p>
<p>Сайт Python предоставляет обширную документацию.  Важно понимать встроенные функции и стандартные типы, описанные в <tt class="doctest"><span class="pre">http://docs.python.org/library/functions.html</span></tt> и <tt class="doctest"><span class="pre">http://docs.python.org/library/stdtypes.html</span></tt>. Мы узнали о генераторах и их значении для эффективности; для получения информации об итераторах, тесно связанная тема, см. <tt class="doctest"><span class="pre">http://docs.python.org/library/itertools.html</span></tt>. Обратитесь к любимой книге по Python для получения дополнительной информации по этим темам.
Отличный ресурс по использованию Python для обработки мультимедийных данных, включая работу со звуковыми файлами, является <a class="reference external" href="http://www.nltk.org/book/bibliography.html#guzdial2005" id="id1">(Guzdial, 2005)</a>.</p>
<p>При использовании онлайн документации по Python, имейте в виду, что установленная у вас версия может отличаться от версии документации, которую вы читаете.  Вы можете легко проверить, какая версия у вас, с помощью <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> sys; sys.version</span></tt>.
Документация для конкретной версии доступна на <tt class="doctest"><span class="pre">http://www.python.org/doc/versions/</span></tt>.</p>
<p>Алгоритм проектирования богатое поле в компьютерной науке.  Для начала можно ознакомиться со следующими работами: <a class="reference external" href="http://www.nltk.org/book/bibliography.html#harel2004" id="id2">(Harel, 2004)</a>, <a class="reference external" href="http://www.nltk.org/book/bibliography.html#levitin2004" id="id3">(Levitin, 2004)</a>, <a class="reference external" href="http://www.nltk.org/book/bibliography.html#knuth2006trees" id="id4">(Knuth, 2006)</a>.
Полезные рекомендации по практике разработки программного обеспечения содержатся в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#hunt2000" id="id5">(Hunt &amp; Thomas, 2000)</a> и <a class="reference external" href="http://www.nltk.org/book/bibliography.html#mcconnell2004" id="id6">(McConnell, 2004)</a>.</p>
</div>
<div class="section" id="exercises">
<h2>4.11 Упражнения</h2>
<ol class="arabic">
<li><p class="first">☼ Узнайте больше об объектах последовательности с помощью справки объекта Python.
В интерпретатором, тип <tt class="doctest"><span class="pre">справки (ул),</span></tt> <tt class="doctest"><span class="pre">помощь (список),</span></tt> и <tt class="doctest"><span class="pre">помощь (кортеж).</span></tt>
Это даст вам полный список функций, поддерживаемых каждым типом.
Некоторые функции имеют специальные имена фланкированные с подчеркиванием; в качестве справочной документации показывает, каждая такая функция соответствует чему-то более привычное.  Например <tt class="doctest"><span class="pre">х .__ GetItem __ (у)</span></tt> просто многословно способ сказать <tt class="doctest"><span class="pre">х [у].</span></tt></p>
</li>
<li><p class="first">☼ Определить три операции, которые могут быть выполнены на обоих кортежей и списков.  Определить три операции списка, которые не могут быть выполнены на кортежей.  Назовите контекст, в котором с помощью списка вместо кортежа генерирует ошибку Python.</p>
</li>
<li><p class="first">☼ Узнайте, как создать кортеж, состоящий из одного элемента.
Есть по крайней мере два способа сделать это.</p>
</li>
<li><p class="first">☼ создать список <tt class="doctest"><span class="pre">слов = [ <span class="pysrc-string">'есть',</span> <span class="pysrc-string">'НЛП',</span> <span class="pysrc-string">'весело',</span> <span class="pysrc-string">'?'</span> ].</span></tt>  Используйте серию операторов присваивания (например , <tt class="doctest"><span class="pre">слова [1] = слова [2])</span></tt> и временная переменная <tt class="doctest"><span class="pre">TMP</span></tt> , чтобы преобразовать этот список в список <tt class="doctest"><span class="pre">[ <span class="pysrc-string">'НЛП',</span> <span class="pysrc-string">'есть',</span> <span class="pysrc-string">'весело',</span> <span class="pysrc-string">'!'</span> ].</span></tt>  Теперь сделайте то же преобразование с помощью присвоения кортежа.</p>
</li>
<li><p class="first">☼ Читайте о встроенной функции сравнения <tt class="doctest"><span class="pre">КСС,</span></tt> введя <tt class="doctest"><span class="pre">помощи (КСС).</span></tt>  Чем она отличается от поведения операторов сравнения?</p>
</li>
<li><p class="first">☼ ли метод для создания скользящего окна из п-граммы ведут себя корректно для двух предельных случаях: <span class="math">п</span> = 1 и <span class="math">п</span> = <tt class="doctest"><span class="pre">Len (пересылаются)?</span></tt></p>
</li>
<li><p class="first">☼ Мы отметили, что , когда пустые строки и пустые списки происходят в состоянии часть , <tt class="doctest"><span class="pre"><span class="pysrc-keyword">если</span></span></tt> пункт, они оценивают <tt class="doctest"><span class="pre">Ложь.</span></tt> В этом случае они, как говорят, происходит в логическом контексте.
Эксперимент с различными видами без логических выражений в булевой контекстах, и посмотреть , оценить ли они как <tt class="doctest"><span class="pre">истинные</span></tt> или <tt class="doctest"><span class="pre">ложные.</span></tt></p>
</li>
<li><p class="first">☼ Используйте операторы неравенства для сравнения строк, например , <tt class="doctest"><span class="pre"><span class="pysrc-string">'Рокфор'</span> &lt; <span class="pysrc-string">'Python'.</span></span></tt>  Что происходит , когда вы делаете <tt class="doctest"><span class="pre"><span class="pysrc-string">'Z'</span> &lt; <span class="pysrc-string">'а'?</span></span></tt>
Попробуйте пары строк , которые имеют общий префикс, например <tt class="doctest"><span class="pre"><span class="pysrc-string">'Monty <span class="pysrc-string">'&lt;'</span></span> <span class="pysrc-string">Монтекки '.</span></span></tt>
Читайте на "лексикографическом сорта" для того, чтобы понять, что здесь происходит.  Попытка сравнения структурированных объектов, например , <tt class="doctest"><span class="pre">( <span class="pysrc-string">'Рокфор',</span> 1) &lt;( <span class="pysrc-string">'Рокфор',</span> 2).</span></tt>  Имеет ли себя это, как ожидалось?</p>
</li>
<li><p class="first">☼ написать код, который удаляет пробелы в начале и в конце строки, а также нормализует пробелы между словами, чтобы быть одним пробелом.</p>
<ol class="arabic simple">
<li>выполнить эту задачу с помощью <tt class="doctest"><span class="pre">раскола ()</span></tt> и <tt class="doctest"><span class="pre">присоединиться</span></tt> к <tt class="doctest"><span class="pre">()</span></tt></li>
<li>выполнить эту задачу с помощью регулярных выражений замены</li>
</ol>
</li>
<li><p class="first">☼ Напишите программу для сортировки слов по длине.  Определим функцию <tt class="doctest"><span class="pre">cmp_len</span></tt> помощника , который использует функцию сравнения <tt class="doctest"><span class="pre">CMP</span></tt> на длинах слов.</p>
</li>
<li><p class="first">◑ Создать список слов и сохранить его в переменной <tt class="doctest"><span class="pre">sent1.</span></tt>
Теперь назначить <tt class="doctest"><span class="pre">sent2 = sent1.</span></tt>  Изменение одного из элементов в <tt class="doctest"><span class="pre">sent1</span></tt> и убедитесь , что <tt class="doctest"><span class="pre">sent2</span></tt> изменилось.</p>
<ol class="loweralpha simple">
<li>Теперь попробуйте то же самое упражнение , но вместо того, чтобы назначить <tt class="doctest"><span class="pre">sent2 = sent1 [:].</span></tt>
Изменить <tt class="doctest"><span class="pre">sent1</span></tt> еще раз и посмотреть , что происходит с <tt class="doctest"><span class="pre">sent2.</span></tt>  Объясните.</li>
<li>Теперь определим <tt class="doctest"><span class="pre">text1</span></tt> быть списком списков строк (например , чтобы представить текст , состоящий из нескольких предложений.  Теперь назначить <tt class="doctest"><span class="pre">text2 = текст1 [:],</span></tt> присвоить новое значение одного из слов, например , <tt class="doctest"><span class="pre">текст1 [1] [1] = <span class="pysrc-string">'Рокфор'.</span></span></tt>  Проверьте , что это сделал <tt class="doctest"><span class="pre">TEXT2.</span></tt>
Объясните.</li>
<li>Загрузить функцию (т.е. <tt class="doctest"><span class="pre"><span class="pysrc-keyword">от</span> <span class="pysrc-builtin">копирования</span> <span class="pysrc-keyword">импорта</span> DeepCopy)</span></tt> языка Python <tt class="doctest"><span class="pre">DeepCopy (),</span></tt> обратитесь к документации, а также тест , что делает новую копию любого объекта.</li>
</ol>
</li>
<li><p class="first">◑ Инициализировать <em>п</em> матрицу с размерностью <em>м</em> список списков пустых строк с помощью списка умножения, например , <tt class="doctest"><span class="pre">word_table = [[ <span class="pysrc-string">'']</span> * п] * м.</span></tt>  Что происходит , когда вы устанавливаете один из его значений, например , <tt class="doctest"><span class="pre">word_table [1] [2] = <span class="pysrc-string">"привет"?</span></span></tt>
Объясните, почему это происходит.  Теперь записать выражение , используя <tt class="doctest"><span class="pre">диапазон ()</span></tt> для построения списка списков, и показать , что он не имеет этой проблемы.</p>
</li>
<li><p class="first">◑ Написать код для инициализации двумерный массив множеств , называемых <tt class="doctest"><span class="pre">word_vowels</span></tt> и обработать список слов, добавляя каждое слово <tt class="doctest"><span class="pre">word_vowels [L] [v]</span></tt> , где <tt class="doctest"><span class="pre">L</span></tt> длина слова и <tt class="doctest"><span class="pre">v</span></tt> это число гласных звуков , которые он содержит.</p>
</li>
<li><p class="first">◑ Напишите функцию <tt class="doctest"><span class="pre">novel10 (текст)</span></tt> , который печатает любое слово , которое появилось в последних 10% текста , который не возникало раньше.</p>
</li>
<li><p class="first">◑ Напишите программу, которая принимает предложение выражается в виде одной строки, расщепляет его и подсчитывает слова.  Получить его, чтобы напечатать каждое слово и частота данного слова, по одному в каждой строке, в алфавитном порядке.</p>
</li>
<li><p class="first">◑ Читайте на гематрии, метод присвоения номеров для слов, а также для отображения между словами , имеющих одинаковое число , чтобы обнаружить скрытый смысл текстов <tt class="doctest"><span class="pre">(http://en.wikipedia.org/wiki/Gematria,</span></tt> <tt class="doctest"><span class="pre">HTTP: // Эссеи .net / gemcal.htm).</span></tt></p>
<ol class="loweralpha">
<li><p class="first">Напишите функцию <tt class="doctest"><span class="pre">гематрию ()</span></tt> , которая суммирует числовые значения букв слова, в соответствии со значениями букв в <tt class="doctest"><span class="pre">letter_vals:</span></tt></p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> Letter_vals = { <span class="pysrc-string">'а':</span> 1, <span class="pysrc-string">'Ъ':</span> 2, <span class="pysrc-string">'с':</span> 3, <span class="pysrc-string">'d':</span> 4, <span class="pysrc-string">'е':</span> 5, <span class="pysrc-string">'F':</span> 80, <span class="pysrc-string">'г':</span> 3, <span class="pysrc-string">'ч ':</span> 8, <span class="pysrc-string"><span class="pysrc-more">...'</span> я ':</span> <span class="pysrc-string">10,' J ':</span> <span class="pysrc-string">10,' к ':</span> <span class="pysrc-string">20,' л ':</span> <span class="pysrc-string">30,' м ':</span> <span class="pysrc-string">40,' п ':</span> <span class="pysrc-string">50,' о ':</span> <span class="pysrc-string">70' р ':</span> <span class="pysrc-string">80,' д ':</span> 100, <span class="pysrc-string"><span class="pysrc-more">...'</span> г ':</span> <span class="pysrc-string">200,' s ':</span> <span class="pysrc-string">300,' т ':</span> <span class="pysrc-string">400,' и ':</span> <span class="pysrc-string">6,' v ':</span> <span class="pysrc-string">6,' W ':</span> 800, <span class="pysrc-string">'х':</span> 60, <span class="pysrc-string">'у':</span> 10, <span class="pysrc-string">'г':</span> 7}</pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">Процесс свода (например , <tt class="doctest"><span class="pre">nltk.corpus.state_union)</span></tt> и для каждого документа, подсчитать , сколько из его слов есть число 666.</p>
</li>
<li><p class="first">Напишите функцию <tt class="doctest"><span class="pre">декодирования ()</span></tt> для обработки текста, в случайном порядке замены слов с их эквивалентами Гиматрия для того, чтобы обнаружить «скрытый смысл» текста.</p>
</li>
</ol>
</li>
<li><p class="first">◑ Написать функцию <tt class="doctest"><span class="pre">укоротить (текст, п)</span></tt> для обработки текста, опуская <span class="math">п</span> наиболее часто встречающихся слов текста.  Как читаемый это?</p>
</li>
<li><p class="first">◑ Написать код для распечатки индекса для лексикона, позволяя кому-то искать слова в соответствии с их значениями (или произношением, какими бы ни были свойства содержатся в лексических записей).</p>
</li>
<li><p class="first">◑ Написать список понимание, что сортирует список Wordnet synsets для близости к данному synset.  Например, учитывая synsets <tt class="doctest"><span class="pre">minke_whale.n.01,</span></tt> <tt class="doctest"><span class="pre">orca.n.01,</span></tt> <tt class="doctest"><span class="pre">novel.n.01</span></tt> и <tt class="doctest"><span class="pre">tortoise.n.01,</span></tt> сортировать их в соответствии с их <tt class="doctest"><span class="pre">shortest_path_distance ()</span></tt> из <tt class="doctest"><span class="pre">right_whale.n.01.</span></tt></p>
</li>
<li><p class="first">◑ Написать функцию, которая принимает список слов (содержащих дубликаты) и возвращает список слов (без дубликатов), отсортированных по понижением частоты.
Например , если список входов содержал 10 экземпляров <tt class="doctest"><span class="pre">таблицы</span></tt> слов и 9 экземпляров слова <tt class="doctest"><span class="pre">стул,</span></tt> то <tt class="doctest"><span class="pre">таблица</span></tt> будет появляться перед <tt class="doctest"><span class="pre">стулом</span></tt> в списке вывода.</p>
</li>
<li><p class="first">◑ Написать функцию, которая принимает текст и словарь в качестве аргументов и возвращает набор слов, которые появляются в тексте, но не в словаре.  Оба аргумента могут быть представлены в виде списка строк.
Вы можете сделать это в одной строке, используя <tt class="doctest"><span class="pre">set.difference ()?</span></tt></p>
</li>
<li><p class="first">◑ Импорт функции <tt class="doctest"><span class="pre">itemgetter ()</span></tt> из модуля <tt class="doctest"><span class="pre">оператора</span></tt> в стандартной библиотеке Python (т.е. <tt class="doctest"><span class="pre"><span class="pysrc-keyword">от</span> оператора <span class="pysrc-keyword">импорта</span> itemgetter).</span></tt>  Создайте список <tt class="doctest"><span class="pre">слов</span></tt> , содержащих несколько слов.  Теперь попробуйте позвонить: <tt class="doctest"><span class="pre">упорядоченные (слова, ключ = itemgetter (1))</span></tt> и <tt class="doctest"><span class="pre">упорядоченные (слова, ключ = itemgetter (-1)).</span></tt>
Объясните , что <tt class="doctest"><span class="pre">itemgetter ()</span></tt> делает.</p>
</li>
<li><p class="first">◑ Написать рекурсивную функцию <tt class="doctest"><span class="pre">поиска (TRIE, ключ)</span></tt> , который ищет ключ в синтаксического дерева, и возвращает значение , которое он находит.  Продолжим функцию , чтобы вернуть слово , когда оно однозначно определяется своим префиксом (например , <tt class="doctest"><span class="pre">авангардная</span></tt> это единственное слово , которое начинается с <tt class="doctest"><span class="pre">vang-,</span></tt> поэтому <tt class="doctest"><span class="pre">поиск (Trie, <span class="pysrc-string">"оттяжка")</span></span></tt> должен возвращать то же самое , как <tt class="doctest"><span class="pre">поиск (синтаксического дерева, <span class="pysrc-string">"авангард"</span> )).</span></tt></p>
</li>
<li><p class="first">◑ Читайте на "ключевых слов связи" (глава 5 <a class="reference external" href="http://www.nltk.org/book/bibliography.html#scott2006" id="id7">(Scott &amp; Триббл, 2006)</a> ).  Извлечение ключевых слов из NLTK Шекспир корпус и с использованием пакета NetworkX, участок ключевых слов сцепления сетей.</p>
</li>
<li><p class="first">◑ Читайте о струнной расстояния редактирования и Левенштейн алгоритма.
Попробуйте реализацию , предоставляемую в <tt class="doctest"><span class="pre">nltk.edit_distance ().</span></tt>
Каким образом это с помощью динамического программирования?  Есть ли использовать снизу вверх или сверху вниз подход?
[Смотри также <tt class="doctest"><span class="pre">http://norvig.com/spell-correct.html]</span></tt></p>
</li>
<li><p class="first">◑ числа Каталана возникают во многих приложениях комбинаторной математики, в том числе при подсчете деревьев разбора ( <a class="reference external" href="http://www.nltk.org/book/ch08.html#sec-grammar-development">6</a> ).  Серия может быть определена следующим образом : С <sub>0</sub> = 1, и С <sub>п + 1</sub> = Σ <sub>0..n</sub> (C <sub>I</sub> C <sub>Ni).</sub></p>
<ol class="loweralpha simple">
<li>Написать рекурсивную функцию для вычисления <span class="math">п</span> - й каталонской число C <sub>п.</sub></li>
<li>Теперь написать еще одну функцию, которая делает это вычисление с использованием динамического программирования.</li>
<li>Используйте модуль <tt class="doctest"><span class="pre">timeit</span></tt> для сравнения производительности этих функций при увеличении <span class="math">п.</span></li>
</ol>
</li>
<li><p class="first">★ Репродуцировать некоторые из результатов <a class="reference external" href="http://www.nltk.org/book/bibliography.html#zhao07" id="id8">(Zhao &amp; Зобель, 2007)</a> , касающихся идентификации авторства.</p>
</li>
<li><p class="first">★ Исследование учитывающих гендерную специфику лексической выбор, и посмотреть , если вы можете воспроизвести некоторые из результатов <tt class="doctest"><span class="pre">http://www.clintoneast.com/articles/words.php</span></tt></p>
</li>
<li><p class="first">★ Написать рекурсивную функцию, которая довольно печатает в алфавитном порядке синтаксического дерева отсортированном порядке, например:</p>
<pre class="literal-block">
Стул: 'плоть' --- т: 'кот' --ic: 'стильный' --- ан: 'собака'
</pre>
</li>
<li><p class="first">★ С помощью структуры данных TRIE, написать рекурсивную функцию, которая обрабатывает текст, расположение единственности точки в каждом слове, и отбрасывая остальную часть каждого слова.  Сколько сжатия дает ли это?  Как читаемый это итоговый текст?</p>
</li>
<li><p class="first">★ Получить некоторые сырой текст, в виде одной длинной строки.
Используйте модуль <tt class="doctest"><span class="pre">TextWrap</span></tt> Python, чтобы разбить его на несколько строк.
Теперь писать код, чтобы добавить дополнительные пробелы между словами, чтобы оправдать вывод.  Каждая строка должна иметь такую ​​же ширину, и пространства должны быть примерно равномерно распределены по каждой строке.  Ни одна строка не может начинаться или заканчиваться пробелом.</p>
</li>
<li><p class="first">★ Разработка простого добывающую инструмент реферирования, который печатает фразы документа, которые содержат самую высокую итоговую частоту слов.  Используйте <tt class="doctest"><span class="pre">FreqDist ()</span></tt> для подсчета частоты слов, и использовать <tt class="doctest"><span class="pre">сумму</span></tt> , чтобы суммировать частоты слов в каждом предложении.
Ранжируйте предложения в соответствии с их счетом.  И, наконец, распечатать <em>п</em> наибольшее количество баллов предложений в порядке документа.  Внимательно изучите дизайн вашей программы, особенно ваш подход к этой двойной сортировке.  Убедитесь, что программа написана так ясно, как это возможно.</p>
</li>
<li><p class="first">★ Прочитайте следующую статью о семантической ориентации прилагательных.
Используйте пакет NetworkX для визуализации сети прилагательных с краями, чтобы указать же против различных смысловых ориентации. <tt class="doctest"><span class="pre">http://www.aclweb.org/anthology/P97-1023</span></tt></p>
</li>
<li><p class="first">★ Разработайте алгоритм, чтобы найти "статистически невероятные фразы" из коллекции документов.
<tt class="doctest"><span class="pre">http://www.amazon.com/gp/search-inside/sipshelp.html</span></tt></p>
</li>
<li><p class="first">★ Напишите программу для реализации алгоритма перебором для обнаружения слов квадратов, своего рода <span class="math">N</span> × <span class="math">N</span> кроссворд , в котором запись в <span class="math">п</span> й строке совпадает с записью в <span class="math">п</span> - м столбце.  Для обсуждения см <tt class="doctest"><span class="pre">http://itre.cis.upenn.edu/~myl/languagelog/archives/002679.html</span></tt></p>
</li>
</ol>
<!-- #. |hard| Extend the program in Example compound-keys_ in the following ways:

a) Define two sets ``verbs`` and ``preps``, and add each verb and preposition
   as they are encountered.  (Note that you can add an item to a set without
   bothering to check whether it is already present.)

b) Create nested loops to display the results, iterating over verbs and
   prepositions in sorted order.  Generate one line of output per verb,
   listing prepositions and attachment ratios as follows:
   ``raised: about 0:3, at 1:0, by 9:0, for 3:6, from 5:0, in 5:5...``

c) We used a tuple to represent a compound key consisting of two strings.
   However, we could have simply concatenated the strings, e.g.
   ``key = verb + ":" + prep``, resulting in a simple string key.
   Why is it better to use tuples for compound keys? -->
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">Об этом документе ...</p>
<p>Обновлялся для NLTK 3.0.
Это глава из книги <em>Обработка естественного языка с помощью Python</em> написанной <a class="reference external" href="http://estive.net/">Стивеном Бердом</a> , <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Эваном Клайном</a> и <a class="reference external" href="http://ed.loper.org/">Эдвардом Лопером</a> , Copyright © 2014 авторов.
Он распространяется с <em>Набором инструментов для естественного языка</em> <tt class="doctest"><span class="pre">[http://nltk.org/],</span></tt> версия 3.0 в соответствии с условиями <em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 Лицензии Соединенных Штатов</em> [ <a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">Этот документ был построен на ср 1 июля 2015 12:30:05 AEST</p>
</div>
</div>
</div>
<div class="system-messages section">
<h1>Docutils Системные сообщения</h1>
<div class="system-message" id="id9">
<p class="system-message-title">Системное сообщение: ОШИБКА / 3 <tt class="docutils">(ch04.rst2,</tt> строка 1791); <em><a href="http://www.nltk.org/book/ch04.html#id10">обратной</a></em></p>
Неизвестно имя цели: "при первом запуске".</div>
<div class="system-message" id="id11">
<p class="system-message-title">Системное сообщение: ОШИБКА / 3 <tt class="docutils">(ch04.rst2,</tt> строка 1791); <em><a href="http://www.nltk.org/book/ch04.html#id12">обратной</a></em></p>
Неизвестно имя цели: "второй перспективе".</div>
</div>
</div>
</body>
</html>