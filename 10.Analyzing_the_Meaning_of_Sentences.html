<html lang="ru" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii"></meta>
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/"></meta>
<title>4,46%10 Анализ значения предложений</title>
<style type="text/css">/* :Author: Edward Loper, James Curran:Copyright: This stylesheet has been placed in the public domain.Stylesheet for use with Docutils.This stylesheet defines new css classes used by NLTK.It uses a Python syntax highlighting scheme that matchesthe colour scheme used by IDLE, which makes it easier forbeginners to check they are typing things in correctly. */
/* Include the standard docutils stylesheet. */
</style>
</head>
<body dir="ltr">
<div class="document" id="analyzing-the-meaning-of-sentences">
<span id="chap-semantics"></span>
<h1 class="title">10. Анализ смысла предложений</h1>

<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words &#39;inside&#39; a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<!-- standard global imports

>>> import nltk, re, pprint -->
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<!-- TO-DO:
* we are using lc feature names here, but capitalized ones in ch09! :-(
* use capitalized proper names in DRSs? -->
<p>Мы видели, как полезно использовать возможности компьютера для обработки текста в больших масштабах.  Однако теперь, когда у нас есть механизм анализаторов и грамматик на основе свойств, можем ли мы сделать что-нибудь такое же полезное для анализа значения предложений?
Цель этой главы - ответить на следующие вопросы:</p>
<ol class="arabic simple">
<li>Как мы можем представить смысл естественного языка, чтобы компьютер мог обрабатывать эти представления?</li>
<li>Как мы можем связать представления смысла с неограниченным набором предложений?</li>
<li>Как мы можем использовать программы, которые соединяют представления смысла предложений с хранилищами знаний?</li>
</ol>
<p>По пути мы узнаем некоторые формальные методы в области логической семантики, и увидим, как они могут быть использованы для опрашивая баз данных, которые хранят факты о мире.</p>
<div class="section" id="natural-language-understanding">
<span id="sec-nlu-introduction"></span><h1>1 Понимание естественного языка</h1>
<div class="section" id="querying-a-database">
<h2>1.1 Формирование запросов к базе данных</h2>
<p>Предположим, у нас есть программа, которая позволяет нам вводить вопросы на естественном языке и возвращает нам на них правильные ответы:</p>
<span class="target" id="ex-dbq0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><span class="target" id="ex-dbq01"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>В какая стране Афины?</td></tr></table></p>
<span class="target" id="ex-dbq02"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Греция.</td></tr></table></p>
</td></tr></table></p>
<p>Как трудно написать такую ​​программу? И можем ли мы просто использовать те же методы, которые мы уже видели в этой книге, или для этого необходимо что-то новое?
В этом разделе мы покажем, что решение задачи в ограниченной области довольно простое. Но мы также увидим, что для решения этой проблемы в более общем виде мы должны открыть новый ряд идей и методов необходимых для представления смысла.</p>
<p>Итак, давайте начнем, предполагая, что у нас есть данные о городах и странах в структурированном виде. Для конкретности мы будем использовать таблицу базы данных, первые несколько строк которой приведены в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tab-cities">1.1</a>.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">Данные, показанные в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tab-cities">1.1</a> заимствованы из системы Чат-80 <a class="reference external" href="http://www.nltk.org/book/bibliography.html#warren1982eea" id="id1">(Warren &amp; Pereira, 1982)</a>.  Данные о численности населения приведены в тысячах, но обратите внимание, что данные, используемые в этих примерах, относятся по меньшей мере к 1980-м годам и уже несколько устарели на тот момент, когда работа <a class="reference external" href="http://www.nltk.org/book/bibliography.html#warren1982eea" id="id2">(Warren &amp; Pereira, 1982)</a> была опубликована.</p>
</div>
<span class="target" id="tab-cities"></span><table border="1" class="docutils" id="tab-cities">
<colgroup>
<col width="32%">
<col width="38%">
<col width="30%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Город</th>
<th class="head">Страна</th>
<th class="head">Население</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Афины</td>
<td>Греция</td>
<td>1368</td>
</tr>
<tr><td>Бангкок</td>
<td>Таиланд</td>
<td>1178</td>
</tr>
<tr><td>барселона</td>
<td>Испания</td>
<td>1280</td>
</tr>
<tr><td>Берлин</td>
<td>Восточная Германия</td>
<td>3481</td>
</tr>
<tr><td>Бирмингем</td>
<td>Великобритания</td>
<td>1112</td>
</tr>
</tbody>
<td><p class="caption"><span class="caption-label">Таблица 1.1</span>: <p><tt class="doctest"><span class="pre">city_table:</span></tt> Таблица городов, стран и населения</p>
</p>
</td></table>
<p>Очевидный способ получить ответы из этих табличных данных подразумевает написание запросов на языке запросов к базе данных, таком как SQL.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">SQL (Structured Query Language) является языком, предназначенным для извлечения и управления данными в реляционных базах данных.
Если вы хотите узнать больше о SQL, то <tt class="doctest"><span class="pre">http://www.w3schools.com/sql/</span></tt> удобный онлайн справочник.</p>
</div>
<p>Например, выполнение запроса <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq1">(2)</a> вернет значение <tt class="doctest"><span class="pre"><span class="pysrc-string">'greece'</span></span></tt>:</p>
<span class="target" id="ex-dbq1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><tt class="doctest"><span class="pre">SELECT Country FROM city_table WHERE City = <span class="pysrc-string">'athens'</span></span></tt></td></tr></table></p>
<p>Этот запрос указывают результирующий набор, состоящий из всех значений для столбца <tt class="doctest"><span class="pre">Country</span></tt> в строках данных, где значением столбца <tt class="doctest"><span class="pre">City</span></tt> является <tt class="doctest"><span class="pre"><span class="pysrc-string">'athens'</span></span></tt>.</p>
<p>Как мы можем получить тот же эффект, используя английский язык в качестве входа для системы запроса? Формализ грамматики на основе свойств, описанный в <a class="reference external" href="http://www.nltk.org/book/ch09.html#chap-featgram">9.</a> позволяет легко перевести с английского на SQL. Грамматика <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> иллюстрирует, как собрать представление смысл для предложения в тандеме с разбором предложения. Каждое правило фразовой структуры дополняется инструкцией для построения значения для свойства <tt class="doctest"><span class="pre">sem</span></tt>. Вы можете видеть, что эти инструкции очень просты; в каждом конкретном случае мы используем операцию конкатенации строки <tt class="doctest"><span class="pre">+</span></tt> для сращивания значений дочерних конституентов, чтобы собрать значение для родительского конституента.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; nltk.data.show_cfg('grammars/book_grammars/sql0.fcfg')
% start S
S[SEM=(?np + WHERE + ?vp)] -&gt; NP[SEM=?np] VP[SEM=?vp]
VP[SEM=(?v + ?pp)] -&gt; IV[SEM=?v] PP[SEM=?pp]
VP[SEM=(?v + ?ap)] -&gt; IV[SEM=?v] AP[SEM=?ap]
NP[SEM=(?det + ?n)] -&gt; Det[SEM=?det] N[SEM=?n]
PP[SEM=(?p + ?np)] -&gt; P[SEM=?p] NP[SEM=?np]
AP[SEM=?pp] -&gt; A[SEM=?a] PP[SEM=?pp]
NP[SEM='Country="greece"'] -&gt; 'Greece'
NP[SEM='Country="china"'] -&gt; 'China'
Det[SEM='SELECT'] -&gt; 'Which' | 'What'
N[SEM='City FROM city_table'] -&gt; 'cities'
IV[SEM=''] -&gt; 'are'
A[SEM=''] -&gt; 'located'
P[SEM=''] -&gt; 'in'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Это позволяет разобрать запрос и представить его в формате SQL.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk import load_parser
&gt;&gt;&gt; cp = load_parser('grammars/book_grammars/sql0.fcfg')
&gt;&gt;&gt; query = 'What cities are located in China'
&gt;&gt;&gt; trees = list(cp.parse(query.split()))
&gt;&gt;&gt; answer = trees[0].label()['SEM']
&gt;&gt;&gt; answer = [s for s in answer if s]
&gt;&gt;&gt; q = ' '.join(answer)
&gt;&gt;&gt; print(q)
SELECT City FROM city_table WHERE Country="china"</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Запустите анализатор с максимальной трассировки, т.е. <tt class="doctest"><span class="pre">ср = load_parser( <span class="pysrc-string">'grammars/book_grammars/sql0.fcfg'</span>, trace = 3)</span></tt>, и проследите за тем, как значения <tt class="doctest"><span class="pre">sem</span></tt> строятся по мере того, как законченные ребра добавляются к диаграмме.</p>
</div>
<p>Наконец, мы выполняем запрос к базы данных <tt class="doctest"><span class="pre">city.db</span></tt> и получаем некоторые результаты.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk.sem import chat80
&gt;&gt;&gt; rows = chat80.sql_query('corpora/city_database/city.db', q)
&gt;&gt;&gt; for r in rows: print(r[0], end=" ") 
canton chungking dairen harbin kowloon mukden peking shanghai sian tientsin</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Так как каждая строка <tt class="doctest"><span class="pre">r</span></tt> представляет собой кортеж, состоящий из одного элемента, мы выводим элемент кортежа, а не сам кортеж <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tuple-val"><span id="ref-tuple-val"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.</p>
<p>Итак, мы определили задачу, где компьютер возвращает полезные данные в ответ на запрос на естественном языке, и мы реализовали это путем перевода небольшого подмножества английского языка на SQL.Мы можем сказать, что наш NLTK код уже "понимает" SQL, учитывая, что Python способен выполнять запросы SQL к базе данных, и он также «понимает» такие запросы, как <span class="example">"Какие города расположены в Китае?"</span>. Это соответствует способности переводить с голландского на английский язык как пример понимания естественного языка.
Предположим, что вы являетесь носителем английского языка, и начали изучать голландский язык. Ваш учитель спрашивает, понимаете ли вы, что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a> означает:</p>
<span class="target" id="ex-sem1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(3)</td><td width="15"></td><td>Margrietje Houdt van Brunoke.</td></tr></table></p>
<p>Если вы знаете значения отдельных слов в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a>, и знаете, как эти значения объединяются, чтобы получить смысл всего предложения, вы могли бы сказать, что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a> означает то же самое, что и <span class="example">"Margrietje любит Brunoke"</span>.</p>
<p>Наблюдатель - давайте назовем ее Ольга - вполне может принять это как свидетельство того, что вы на самом деле поняли смысл <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a>. Но это будет зависеть от понимания английского языка самой Ольгой. Если она не понимает, то ваш перевод с голландского на английский не убедит ее в вашей способности понимать голландский. Мы вернемся к этому вопросу в ближайшее время.</p>
<p>Грамматика <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> вместе с анализатором NLTK Эрли являются инструментом в осуществлении перевода с Английский на SQL. Насколько адекватна эта грамматика? Вы видели, что SQL перевод всего предложения был построен из переводов компонентов. Однако, кажется, нет серьезных оправданий для такого представления смысла этих компонентов. Например, если мы посмотрим на анализ именной фразы <span class="example">Which cities</span>, то увидим, что определитель и существительное соответствуют фрагментам SQL <tt class="doctest"><span class="pre">SELECT</span></tt> и <tt class="doctest"><span class="pre">City FROM city_table</span></tt>. Но ни один из них (фрагментов) не имеет четко определенного смысла в отрыве от другого.</p>
<p>Существует еще один повод для критики - в отношении грамматики: у нас есть "жесткое" неудобное количество деталей о базе данных в ней (грамматике).  Нам нужно знать имя соответствующей таблицы (например, <tt class="doctest"><span class="pre">city_table</span></tt>) и имена полей. Но наша база данных могла бы содержать в точности те же строки данных, но использовать другое имя таблицы и другие имена полей, в этом случае запросы SQL были бы невыполнимы. Равным образом, мы могли бы хранить свои данные в другом формате, например, XML, и в этом случае получение тех же результатов потребовало бы от нас перевести наши английские запросы на язык запросов для XML, а не SQL. Эти соображения позволяют предположить, что мы должны переводить с английского на то, что является более абстрактным и общим, нежели SQL.</p>
<p>Для того, чтобы заострить проблему, давайте рассмотрим другой английский запрос и его перевод:</p>
<span class="target" id="ex-dbq2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(4)</td><td width="15"></td><td><span class="target" id="ex-dbq21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>What cities are in China and have populations above 1,000,000?
</td></tr></table></p>
<span class="target" id="ex-dbq22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">SELECT City FROM city_table WHERE Country = <span class="pysrc-string">'china'</span> AND
Population &gt; 1000</span></tt></td></tr></table></p>
</td></tr></table></p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p><strong>Ваша очередь:</strong> 
Расширьте грамматику <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> так, чтобы она перевела <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq21">(4a)</a> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq22">(4b)</a> и проверьте значения, возвращаемые запросом.</p>
<p class="last">Вы, вероятно, обнаружите, что проще сначала расширить грамматику для обработки запросов наподобие: <span class="example">"Какие города имеют население выше 1,000,000"</span>, прежде чем браться за конъюнкцию. После того, как вы попробовали решить эту задачу, вы можете сравнить ваше решение с <tt class="doctest"><span class="pre">grammars/book_grammars/sql1.fcfg</span></tt> в дистрибутиве данных NLTK.</p>
</div>
<p>Заметим, что <span class="example">and</span> конъюнкция в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq21">(4а)</a> переводится в <tt class="doctest"><span class="pre">AND</span></tt> в SQL, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq22">(4b)</a>. Последнее говорит нам выбрать результаты из строк, где два условия истинны вместе: значение столбца <tt class="doctest"><span class="pre">Country</span></tt> является <tt class="doctest"><span class="pre"><span class="pysrc-string">'china'</span></span></tt> и значение столбца <tt class="doctest"><span class="pre">Population</span></tt> больше, чем 1000.
Эта интерпретация <span class="example">and</span> включает новую идею: and говорит о том, <span class="emphasis">что истинно в той или иной ситуации</span>, и говорит нам, что <tt class="doctest"><span class="pre">Cond1 AND Cond2</span></tt> истинно в ситуации <em>s</em> только в случае, если условие <tt class="doctest"><span class="pre">Cond1</span></tt> истинно в <em>s</em> и условие <tt class="doctest"><span class="pre">Cond2</span></tt> истинно в <em>s</em>. Хотя это не учитывает весь спектр значений <span class="example">and</span> на английском языке, оно имеет приятное свойство что оно не зависит от языка запросов. На самом деле, мы дали ему стандартную интерпретацию из классической логики. В следующих разделах мы рассмотрим подход, в котором предложения естественного языка переводятся на язык логики вместо исполняемого языка запросов, такого как SQL.Одно из преимуществ логических формализмов является то, что они являются более абстрактными и, следовательно, носят более общий характер. Если бы мы хотели после того, как выполнили наш перевод на язык логики, мы могли бы перевести с языка логики на различные другие языки специального назначения. На самом деле, наиболее серьезные попытки формирования запросов к базам данных с помощью естественного языка использовали эту методологию.</p>
</div>
<div class="section" id="natural-language-semantics-and-logic">
<h2>1.2 Естественный язык, семантика и логика</h2>
<p>Мы начали пытаться схватить значение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-dbq01">(1a)</a>, переводя его в запрос на другом языке, SQL, который компьютер мог бы интерпретировать и выполнять. Но ответ на вопрос, был ли перевод правильным, так и не был дан. Отступив от запроса к базе данных, мы отметили, что смысл <span class="example">и</span>, кажется, зависит от возможности указать, когда утверждения верны, а когда нет в той или иной ситуации. Вместо того, чтобы переводить предложение <em>S</em> с одного языка на другой, мы пытаемся сказать, <span class="emphasis">о чем</span> <em>S</em>, связывая его с ситуацией в мире. Давайте продолжим дальше. Представьте себе ситуацию <em>s</em>, в которой есть два объекта, Margrietje и ее любимая кукла, Brunoke. Кроме того, существует связь между двумя этими объектами, которую мы будем называть отношением <em>любви</em>. Если вы понимаете значение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a>, то вы знаете, что оно истинно в ситуации <em>s</em>. В частности, вы это знаете, потому что вы знаете, что <span class="example">Margrietje</span> относится к Margrietje, <span class="example">Brunoke</span> относится к Brunoke, а <span class="example">houdt van</span> относится к отношению <em>любви</em>.</p>
<p>Мы ввели два фундаментальных понятия семантики. Во-первых, повествовательные предложения являются <span class="emphasis">истинными или ложными в определенных ситуациях</span>.
Во-вторых, определенные именные фразы и имена собственные <span class="emphasis">относятся к вещам в мире</span>. Таким образом, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem1">(3)</a> верно в ситуации, когда Margrietje любит куклу Brunoke, изображенной на рисунке <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-mimo-and-bruno">1.1</a>.</p>
<span class="target" id="fig-mimo-and-bruno"></span><div class="figure" id="fig-mimo-and-bruno">
<img alt="../images/mimo-and-bruno.png" src="http://www.nltk.org/images/mimo-and-bruno.png" style="width:540.0px;height:355.0px">
<p class="caption"><span class="caption-label">Рисунок 1.1</span>: Изображение ситуации, в которой Margrietje любит Brunoke.</p>
</div>
<p>После того, как мы приняли понятие истины в некоторой ситуации, у нас есть мощный инструмент для рассуждений.  В частности, мы можем рассмотреть наборы предложений и спросить, могут ли они быть истинными вместе в какой-то ситуации. Например, предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons1">(5)</a> могут быть оба истинными, в то время как предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons2">(6)</a> и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons3">(7)</a> не могут быть. Другими словами, предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons1">(5)</a> являются <a name="consistent_index_term"></a><span class="termdef">совместимыми</span>, в то время как предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons2">(6)</a> и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons3">(7)</a> являются <a name="inconsistent_index_term"></a> <span class="termdef">несовместимыми</span>.</p>
<span class="target" id="ex-cons1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(5)</td><td width="15"></td><td><span class="target" id="ex-cons11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Sylvania is to the north of Freedonia.</td></tr></table></p>
<span class="target" id="ex-cons12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Freedonia is a republic.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-cons2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(6)</td><td width="15"></td><td><span class="target" id="ex-cons21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The capital of Freedonia has a population of 9,000.</td></tr></table></p>
<span class="target" id="ex-cons22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>No city in Freedonia has a population of 9,000.
</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-cons3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">7.</td><td width="15"></td><td><span class="target" id="ex-cons31"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Sylvania is to the north of Freedonia.</td></tr></table></p>
<span class="target" id="ex-cons32"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Freedonia is to the north of Sylvania.
</td></tr></table></p>
</td></tr></table></p>
<p>Мы выбрали предложения о вымышленных странах (из фильма 1933 года <em>Утиный суп</em> братьев Маркс), чтобы подчеркнуть, что ваша способность рассуждать об этих примерах не зависит от того, что является истинным или ложным в реальном мире. Если вы знаете значение слова <span class="example">no</span>, а также знаете, что столица страны - это город в этой стране, то вы должны быть в состоянии сделать вывод о том, что два предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons2">(6)</a> несовместимы независимо от того, где находится Фридония или какова численность населения ее столицы. То есть, нет никакой возможности ситуации, в которой оба предложения могли бы быть правдой. Точно так же, если вы знаете, что отношение <span class="example">к северу от</span> асимметрично, то вы должны быть в состоянии сделать вывод о том, что два предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-cons3">(7)</a> несовместимы.</p>
<p>Вообще говоря, подходы, основанные на логике, к семантике естественного языка сосредоточены на тех аспектах естественного языка, которые направляют наши суждения о совместимости и несовместимости. Синтаксис логического языка разработан так, чтобы сделать эти свойства формально выраженными. В результате определение свойств совместимости часто может быть сведено к символической манипуляции, то есть к задаче, которая может быть выполнена компьютером. Для реализации этого подхода мы сначала хотим разработать методику для представления возможной ситуации. Мы делаем это с помощью того, что логики называют моделью.</p>
<!-- XXX is "sentence" being used with it linguistic or logical meaning?
(The ambiguity is probably harmless.) -->
<p><a name="model_index_term"></a><span class="termdef">Модель</span> для множества предложений <em>W</em> является формальным представлением ситуации, в которой все предложения в <em>W</em> являются истинными. Обычный способ представления моделей использует теорию множеств. Домен <em>D</em> дискурса (все объекты, которые нас интересуют в настоящее время) представляет собой совокупность индивидуальных объектов, а отношения рассматриваются как наборы, построенные из <em>D</em>. Давайте посмотрим на конкретном примере. Наш домен <em>D</em> будет состоять из трех детей: Stefan, Klaus и Evi, представленных соответственно как <tt class="doctest"><span class="pre">s</span></tt>, <tt class="doctest"><span class="pre">k</span></tt> и <tt class="doctest"><span class="pre">e</span></tt>. Запишем это следующим образом: <em>D</em> = <tt class="doctest"><span class="pre">{s, k, e}</span></tt>. Выражение <span class="example">boy</span> обозначает множество, состоящее из Stefan и Klaus, выражение <span class="example">girls</span> обозначает множество, состоящее из Evi, а выражение <span class="example">is running</span> обозначает множество, состоящее из Stefan и Evi. Рисунок <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-model-kids">1.2</a> представляет собой графическое отображение модели.</p>
<span class="target" id="fig-model-kids"></span><div class="figure" id="fig-model-kids">
<img alt="../images/model_kids.png" src="http://www.nltk.org/images/model_kids.png" style="width:385.0px;height:328.40000000000003px">
<p class="caption"><span class="caption-label">Рисунок 1.2:</span> Схема модели, содержащей домен <em>D</em> и подмножества <em>D</em>, соответствующие предикатам <span class="math">boy</span>, <span class="math">girl</span> и <span class="math">is running</span>.</p>
</div>
<p>Позже в этой главе мы будем использовать модели, чтобы оценить истинность или ложность английских предложений, и таким образом проиллюстрировать некоторые методы для представления значения. Однако прежде, чем остановиться на этом более подробно, давайте поместим обсуждение в более широкую перспективу и вернемся обратно к вопросу, который мы затронули в <a class="reference external" href="http://www.nltk.org/book/ch01.html#sec-automatic-natural-language-understanding">5</a>.  Может ли компьютер понимать смысл предложения? И как мы могли бы сказать, что он это сделал?  Это похоже на вопрос: "Может ли компьютер мыслить?"Алан Тьюринг предложил ответить на этот вопрос путем изучения способности компьютера вести имеющие смысл беседы с человеком (Turing, 1950). Предположим, что вы ведете две беседы в чате с человеком и компьютером, но вам не сказали, кто из них кто. Если после беседы с каждым из них вы не можете определить, кто из ваших партнеров компьютер, то компьютер успешно имитировал человека. Если компьютер успешно выдал себя за человека в этой "имитационной игре" (широко известной как "тест Тьюринга"), то согласно Тьюрингу мы должны быть готовы сказать, что компьютер <span class="emphasis">может</span> думать и может быть назван разумным. Так что Тьюринг обошел вопрос какого-либо исследования внутренних состояний компьютера, использовав вместо этого его <span class="emphasis">поведение</span> как свидетельство интеллекта. По той же причине мы предположили, что для того, чтобы сказать, что компьютер понимает по-английски, он просто должен вести себя так, как будто бы это было так.  Что важно здесь - так это не столько специфика имитационной игры Тьюринга, сколько предложение судить о способности понимать естественный язык по наблюдаемому поведению.</p>
</div>
</div>
<div class="section" id="propositional-logic">
<span id="sec-proplog"></span><h1>2 Логика высказываний </h1>
<p>Логический язык разработан, чтобы сделать рассуждения формально явными. В результате он может схватывать аспекты естественного языка, которые определяют, является ли множество предложений совместимым. В рамках этого подхода мы должны разработать логические представления предложения φ, которые формально будут схватывать <a name="truth_conditions_index_term"></a> <span class="termdef">условия истинности</span> φ. Начнем с простого примера:</p>
<span class="target" id="ex-proplog1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(8)</td><td width="15"></td><td>[Klaus chased Evi] and [Evi ran away].</td></tr></table></p>
<p>Давайте заменим два простых предложения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog1">(8)</a> на φ [фи] и ψ [пси] соответственно и поставим <tt class="doctest"><span class="pre">&amp;</span></tt> [амперсанд] для логического оператора, соответствующего английского слову <span class="example">and</span>: φ <tt class="doctest"><span class="pre">&amp;</span></tt> ψ. Эта структура является <a name="logical_form_index_term"></a><span class="termdef">логической формой</span> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog1">(8)</a> .</p>
<p><a name="propositional_logic_index_term"></a><span class="termdef">Логика высказываний</span> позволяет представить только те части языковой структуры, которые соответствуют конкретным связкам предложений. Мы только что рассмотрели <span class="example">and</span>. Другими подобными связками являются <span class="example">not</span>, <span class="example">or</span> и <span class="example">if ..., then ....</span> В формализации логики высказываний аналоги таких связок иногда называют <a name="boolean_operators_index_term"></a><span class="termdef">логическими операторами</span>.  Базовые выражения логики высказываний суть <a name="propositional_symbols_index_term"></a><span class="termdef">символы высказываний</span>, часто записываемые как <span class="math">P</span>, <span class="math">Q</span>, <span class="math">R</span> и т.п.  Существуют различные соглашения для представления логических операторов. Так как мы будем сосредоточены на способах изучения логики с помощью NLTK, мы будем придерживаться следующих ASCII-версий операторов:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; nltk.boolean_ops()
negation            -
conjunction         &amp;
disjunction         |
implication         -&gt;
equivalence         &lt;-&gt;</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Из символов высказываний и логических операторов мы можем построить бесконечное множество <a name="well_formed_formulas_index_term"></a><span class="termdef">хорошо сформированных формул</span> (или просто формул для краткости) логики высказываний. Во-первых, каждая символ высказываний является формулой. Тогда если φ является формулой, то и <tt class="doctest"><span class="pre">-</span></tt>φ является формулой. А если ф и ψ являются формулами, то и формулами являются:
(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">&amp;</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>) 
(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">|</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>)
(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">-&gt;</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>) 
(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">&lt;-&gt;</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>).</p>
<p>Таблица <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tab-boolean-tcs">2.1</a> характеризует условия истинности для формул, содержащих эти операторы. Как и прежде, мы используем φ и ψ в качестве переменных для предложений и сокращаем <span class="example">тогда и только тогда</span> как <span class="example">iff</span>.</p>
<span class="target" id="tab-boolean-tcs"></span><table border="1" class="docutils" id="tab-boolean-tcs">
<colgroup>
<col width="28%">
<col width="28%">
<col width="8%">
<col width="35%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Логический оператор</th>
<th class="head" colspan="3">Условия истины</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Отрицание <span class="example">(это не тот случай, когда...)</span></td>
<td><tt class="doctest"><span class="pre">-</span></tt>φ истинно в <em>s</em></td>
<td>iff</td>
<td>φ ложно в <em>S</em></td>
</tr>
<tr><td>конъюнкция <span class="example">(и)</span></td>
<td>(<tt class="doctest"><span class="pre">φ </span></tt> <tt class="doctest"><span class="pre">&amp;</span></tt> <tt class="doctest"><span class="pre">ψ)</span></tt> истинно в <em>s</em></td>
<td>iff</td>
<td>φ истинно в <em>s</em> и ψ истинно в <em>с</em></td>
</tr>
<tr><td>дизъюнкция <span class="example">(или)</span></td>
<td>(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">|</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>) истинно в <em>s</em></td>
<td>iff</td>
<td>φ истинно в <em>s</em> или ψ истинно в <em>s</em></td>
</tr>
<tr><td>импликация <span class="example">(если ..., то ...)</span></td>
<td>(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">-&gt;</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>) истинно в <em>s</em></td>
<td>iff</td>
<td>φ ложно в <em>s</em> или ψ истинно в <em>s</em></td>
</tr>
<tr><td>эквивалентность <span class="example">(тогда и только тогда)</span></td>
<td>(<tt class="doctest"><span class="pre">φ</span></tt> <tt class="doctest"><span class="pre">&lt;-&gt;</span></tt> <tt class="doctest"><span class="pre">ψ</span></tt>) истинно в <em>s</em></td>
<td>iff</td>
<td>φ и ψ оба являются истинными в <em>s</em> или ложными в <em>s</em></td>
</tr>
</tbody>
<td><p class="caption"><span class="caption-label">Таблица 2.1</span>: <p>Условия истинности для логических операторов в логике высказываний.</p>
</p>
</td></table>
<p>Эти правила, в общем, просты, хотя условия истинности для импликации исходят во многих случаях из наших обычных представлений об условных предложениях в английском языке. Формула вида <tt class="doctest"><span class="pre">(Р -&gt; Q)</span></tt> ложна только тогда, когда <tt class="doctest"><span class="pre">P</span></tt> истинна, а <tt class="doctest"><span class="pre">Q</span></tt> ложно. Если <tt class="doctest"><span class="pre">P</span></tt> ложно (скажем, <tt class="doctest"><span class="pre">P</span></tt> соответствует <span class="example">Луна сделана из зеленого сыра</span>) и <tt class="doctest"><span class="pre">Q</span></tt> истинно (скажем <tt class="doctest"><span class="pre">Q</span></tt> соответствует <span class="example">два плюс два равно четыре</span>), то <tt class="doctest"><span class="pre">Р -&gt; Q</span></tt> оказывается истинной.</p>
<p>Объект NLTK <tt class="doctest"><span class="pre">Expression</span></tt> может перерабатывать логические выражения в различные подклассы <tt class="doctest"><span class="pre">Expression</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_expr = nltk.sem.Expression.fromstring
&gt;&gt;&gt; read_expr('-(P &amp; Q)')
&lt;NegatedExpression -(P &amp; Q)&gt;
&gt;&gt;&gt; read_expr('P &amp; Q')
&lt;AndExpression (P &amp; Q)&gt;
&gt;&gt;&gt; read_expr('P | (R -&gt; Q)')
&lt;OrExpression (P | (R -&gt; Q))&gt;
&gt;&gt;&gt; read_expr('P &lt;-&gt; -- P')
&lt;IffExpression (P &lt;-&gt; --P)&gt;</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>С вычислительной точки зрения логики дают нам важный инструмент для умозаключений.  Предположим, вы утверждаете, что Freedonia is not to the north of Sylvania, и вы указываете в качестве аргументов, что Sylvania is to the north of Freedonia. В этом случае, вы произвели <a name="argument_index_term"></a><span class="termdef">аргумент</span>. Предложение <span class="example">Sylvania is to the north of Freedonia</span> является <a name="assumption_index_term"></a><span class="termdef">посылкой</span> аргумента, в то время как <span class="example">Freedonia is not to the north of Sylvania</span> является его <a name="conclusion_index_term"></a><span class="termdef">выводом</span>. Этап перехода от одной или нескольких посылок к выводу называется <a name="inference_index_term"></a><span class="termdef">умозаключением</span>. Неформально обычно записывают аргументы в формате, в котором выводу предшествует <span class="example">"следовательно" (therefore)</span>.</p>
<span class="target" id="ex-proplog8"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(9)</td><td width="15"></td><td><div class="line-block">
<div class="line">Sylvania is to the north of Freedonia.</div>
<div class="line">Therefore, Freedonia is not to the north of Sylvania</div>
</div>
</td></tr></table></p>
<p>Аргумент является <a name="valid_index_term"></a><span class="termdef">действительным</span>, если нет возможной ситуации, в которой все его предпосылки истинны, а его вывод неистинный.</p>
<p>Теперь справедливость <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog8">(9)</a> в решающей степени зависит от смысла фразы <span class="example">to the north of</span>, в частности, от того факта, что она выражает асимметричное отношение:</p>
<span class="target" id="ex-north"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(10)</td><td width="15"></td><td>if <span class="math">х</span> to the north of <span class="math">y</span>, тогда <span class="math">y</span> is not to the north of <span class="math">х</span>.</td></tr></table></p>
<p>К сожалению, мы не можем выразить такие правила в логике высказываний: самые маленькие элементы, с которыми мы можем работать - атомарные высказывания, и мы не можем "заглянуть внутрь" них, чтобы сказать об отношениях между индивидуальными объектами <span class="math">x</span> и <span class="math">y</span>.  Лучшее, что мы можем сделать в этом случае, - схватить частный случай асимметрии. Давайте использовать символ высказывания <tt class="doctest"><span class="pre">SnF</span></tt> для <span class="example">Sylvania is to the north of Freedonia</span> и <tt class="doctest"><span class="pre">FnS</span></tt> для <span class="example">Freedoniais to the north of Sylvania</span>. Чтобы выразить, что <span class="example">Freedonia is not to the north of Sylvania</span>, мы напишем <tt class="doctest"><span class="pre">-FnS</span></tt>.То есть, мы рассматриваем <span class="example">not</span> как эквивалент фразы <span class="example">это не тот случай, когда...</span> и переводим это как одноместный логический оператор <tt class="doctest"><span class="pre">-</span></tt>.  Так что теперь мы можем записать импликацию в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-north">(10)</a> как</p>
<span class="target" id="ex-northprop"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(11)</td><td width="15"></td><td><tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt></td></tr></table></p>
<p>Как насчет того, чтобы дать версию полного аргумента? Мы заменим первое предложение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog8">(9)</a> на две формулы логики высказываний: <tt class="doctest"><span class="pre">SnF</span></tt> и импликацию в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-northprop">(11)</a>, которая выражает (весьма слабо) наше фоновое знание о смысле выражения <span class="example">to the north of</span>.  Мы пишем <tt class="doctest"><span class="pre">[A1, ..., An] / C</span></tt>, чтобы представить аргумент, вывод которого <tt class="doctest"><span class="pre">C</span></tt> следует из посылок <tt class="doctest"><span class="pre">[A1, ..., An]</span></tt>. Это приводит к следующему выражению как представлению аргумента <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog8">(9)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(12)</td><td width="15"></td><td><tt class="doctest"><span class="pre">[SnF, SnF -&gt; -FnS] / -FnS</span></tt></td></tr></table></p>
<p>Это действительный аргумент: если <tt class="doctest"><span class="pre">SnF</span></tt> и <tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt> оба являются истинными в ситуации <em>s</em>, то <tt class="doctest"><span class="pre">-FnS</span></tt> должно также быть истинно в <em>s</em>. Напротив, если <tt class="doctest"><span class="pre">FnS</span></tt> было бы истиной, то это противоречило бы нашему пониманию того, что два объекта не могут быть оба к северу друг от друга в любой возможной ситуации. Эквивалентно, список <tt class="doctest"><span class="pre">[SnF, SnF -&gt; -FnS, FnS]</span></tt> несовместим - эти предложения не могут быть истинными вместе.</p>
<p>Аргументы могут быть проверены на "синтаксическую действительность" с помощью системы доказательств.  Мы скажем об этом немного больше в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#sec-fol">3</a>.  Логические доказательства могут быть выполнены с помощью модуля NLTK <tt class="doctest"><span class="pre">inference</span></tt>, например, <em>через</em> интерфейс к стороннему пакету для доказательства теорем Prover9. Входы для механизма логического вывода сначала должны быть преобразованы в логические выражения.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; lp = nltk.sem.Expression.fromstring
&gt;&gt;&gt; SnF = read_expr('SnF')
&gt;&gt;&gt; NotFnS = read_expr('-FnS')
&gt;&gt;&gt; R = read_expr('SnF -&gt; -FnS')
&gt;&gt;&gt; prover = nltk.Prover9()
&gt;&gt;&gt; prover.prove(NotFnS, [SnF, R])
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Вот еще один способ увидеть, почему следует этот вывод.  Выражение <tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt> семантически эквивалентно выражению <tt class="doctest"><span class="pre">-SnF | -FnS</span></tt>, Ггде <tt class="doctest"><span class="pre">"|"</span></tt> является двухместным оператором, соответствующим <span class="example">или</span>. В общем, <tt class="doctest"><span class="pre">φ | ψ</span></tt> истинно в ситуации <em>s</em>, если или φ истинно в <em>s</em>, или φ истинно в <em>s</em>. Теперь предположим, что оба <tt class="doctest"><span class="pre">SnF</span></tt> и <tt class="doctest"><span class="pre">-SnF | -FnS</span></tt> истинны в ситуации <em>s</em>. Если <tt class="doctest"><span class="pre">SnF</span></tt> истинно, то <tt class="doctest"><span class="pre">-SnF</span></tt> не может быть также истинным; фундаментальное предположение классической логики заключается в том, что предложение не может быть одновременно истинным и ложным в одной ситуации. Следовательно, <tt class="doctest"><span class="pre">-FnS</span></tt> должно быть истиной.</p>
<p>Напомним, что мы интерпретируем предложения логического языка, относящегося к модели, которая является очень упрощенной версией мира. Модель для логики высказываний должна присвоить значения <tt class="doctest"><span class="pre">Истина</span></tt> или <tt class="doctest"><span class="pre">Ложь</span></tt> для каждой возможной формулы. Мы делаем это индуктивно: сначала каждому символ высказываний присваивается значение, а затем мы вычисляем значение сложных формул, обращаясь к значениям логических операторов (т.е. <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tab-boolean-tcs">2.1</a>) и применяя их к значениям компонентов этих формул. <tt class="doctest"><span class="pre">Valuation</span></tt> - это соединение исходных выражений логики с их значениями (оценка). Вот пример:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; val = nltk.Valuation([('P', True), ('Q', True), ('R', False)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы создаем <tt class="doctest"><span class="pre">Valuation</span></tt> с помощью списка пар, каждая из которых состоит из семантического символа и семантического значения. Полученный объект является по существу всего лишь словарем, который соединяет логические выражения (обрабатываемые как строки) и соответствующие значения.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; val['P']
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Как мы увидим позже, наши модели должны быть несколько более сложным для того, чтобы обрабатывать более сложные логические формы, обсуждаемые в следующем разделе; до поры до времени просто игнорируйте параметры <tt class="doctest"><span class="pre">dom</span></tt> и <tt class="doctest"><span class="pre">g</span></tt> в следующих декларациях.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dom = set()
&gt;&gt;&gt; g = nltk.Assignment(dom)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Теперь давайте инициализируем модель <tt class="doctest"><span class="pre">m</span></tt>, которая использует <tt class="doctest"><span class="pre">val</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m = nltk.Model(dom, val)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Каждый объект Model имеет метод <tt class="doctest"><span class="pre">evaluate()</span></tt>, который будет определять смысловое значение логических выражений, таких как формулs логики высказываний; конечно, эти значения зависят от начальных значений истинности, которые мы назначили символам высказываний, таким как <tt class="doctest"><span class="pre">P</span></tt>, <tt class="doctest"><span class="pre">Q</span></tt> и <tt class="doctest"><span class="pre">R</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; print(m.evaluate('(P &amp; Q)', g))
True
&gt;&gt;&gt; print(m.evaluate('-(P &amp; Q)', g))
False
&gt;&gt;&gt; print(m.evaluate('(P &amp; R)', g))
False
&gt;&gt;&gt; print(m.evaluate('(P | R)', g))
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Поэкспериментируйте с оценкой различных формул логики высказываний.
Дает ли модель оценки, которые вы ожидали увидеть?</p>
</div>
<p>До сих пор мы переводили наши английские предложения на язык логики высказываний. Поскольку мы ограничены представлением атомарных предложений с помощью символов, таких как <tt class="doctest"><span class="pre">P</span></tt> и <tt class="doctest"><span class="pre">Q</span></tt>, мы не можем копаться в их внутренней структуре. Фактически мы говорим, что нет ничего, представляющего интерес с точки зрения логики в делении атомарных предложений на субъекты, объекты и предикаты. Однако это кажется ошибочным: если мы хотим формализовать аргументы, такие как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-proplog8">(9)</a>, мы должны иметь возможность "заглянуть внутрь" исходных предложений. В результате мы выйдем за пределы логики высказываний к чему-то более выразительному, а именно логике первого порядка. Это то, к чему мы переходим в следующем разделе.</p>
</div>
<div class="section" id="first-order-logic">
<span id="sec-fol"></span><h1>3 Логика первого порядка</h1>
<p>В оставшейся части этой главы мы будем представлять смысл выражений естественного языка, переводя их на язык логики первого порядка.
Не все из семантики естественного языка может быть выражено в логике первого порядка. Но это хороший выбор для вычислительной семантики, поскольку она достаточно выразительна, чтобы представлять собой хорошее решение, а с другой стороны, существуют отличные готовые системы для автоматизированных умозаключений в логике первого порядка.</p>
<p>Наш следующий шаг будет заключаться в том, чтобы описать, как формулы логики первого порядка строятся, а затем, как такие формулы могут быть оценены в модели.</p>
<div class="section" id="syntax">
<h2>3.1 Синтаксис</h2>
<p>Логика первого порядка сохраняет все логические операторы логики высказываний. Но она добавляет некоторые важные новые механизмы. Начнем с того, что высказывания расчленяются на предикаты и ​​аргументы, что делает нас на шаг ближе к структуре естественных языков. Стандартные правила построения для логики первого порядка признают такие <a name="terms_index_term"></a><span class="termdef">термины</span>, как отдельные переменные и константы, а также <a name="predicates_index_term"></a><span class="termdef">предикаты</span>, которые принимают разное число аргументов. Например, <span class="example">Angus walks</span> может быть оформлена как <span class="mathit">walk(angus)</span>, а <span class="example">Angus sees Bertie</span> как <span class="mathit">see(angus, bertie)</span>. Мы будем называть <span class="mathit">walk</span> <a name="unary_predicate_index_term"></a><span class="termdef">унарным предикатом</span>, а <span class="mathit">see</span> <a name="binary_predicate_index_term"></a><span class="termdef">бинарным предикатом</span>. Символы, используемые как предикаты не имеют внутреннего смысла, хотя это трудно запомнить. Возвращаясь к одному из наших предыдущих примеров, нет никакого <span class="emphasis">логического</span> различия между <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog11">(13a)</a> и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog12">(13b)</a>.</p>
<span class="target" id="ex-predlog1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(13)</td><td width="15"></td><td><span class="target" id="ex-predlog11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>love(margrietje, brunoke)</td></tr></table></p>
<span class="target" id="ex-predlog12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>houden_van(margrietje, brunoke)</td></tr></table></p>
</td></tr></table></p>
<!-- XXX is it important enough to tell the reader that some theories
of lexical semantics can be encoded in FOL? -->
<p>Сама по себе логика первого порядка не имеет ничего существенного сказать о лексической семантике - смысле отдельных слов - хотя некоторые теории лексической семантики могут быть закодированы в логику первого порядка. Является ли атомарная предикация, как <span class="mathit">see(angus, berie)</span>, истинной или ложной в некоторой ситуации, не вопрос логики, а зависит от конкретной оценки, которую мы выбрали для констант <span class="mathit">see</span>, <span class="mathit">angus</span> и <span class="mathit">betie</span>. По этой причине такие выражения называются <a name="non_logical_constants_index_term"></a><span class="termdef">нелогические константы</span>. В противоположность этому<a name="logical_constants_index_term"></a><span class="termdef">логические константы</span> (такие как логические операторы) всегда получают одну ту же интерпретацию в каждой модели для логики первого порядка.</p>
<p>Следует отметить здесь, что один двоичный предикат имеет особый статус, а именно равенство, как в формулах, таких как <span class="mathit">angus = аj</span>. Равенство рассматривается как логическая константа, так как для индивидуальных терминов <span class="math">t1</span> и <span class="math">t2</span>, формула <span class="math">t1 = t2</span> истинна тогда и только тогда, когда <span class="math">t1</span> и <span class="math">t2</span> относятся к одному и тому же объекту.</p>
<!-- SB: Note that the angle brackets don&#39;t appear in the PDF output version -->
<p>Часто бывает полезно проверить синтаксическую структуру выражений логики первого порядка, обычный способ сделать это - назначить <a name="types_index_term"></a><span class="termdef">типы</span> для выражений. Следуя традиции грамматики Montague, мы будем использовать два <a name="basic_types_index_term"></a><span class="termdef">основных типа</span>: <span class="math">e</span> это тип объетокв, а <span class="math">t</span> - тип формул, то есть выражений, которые имеют значения истинности. С помощью этих двух основных типов, мы можем сформировать <a name="complex_types_index_term"></a><span class="termdef">сложные типы</span> для функциональных выражений. То есть для любых типов σ [сигма] и τ [тау] &lt;σ, τ&gt; представляет собой сложный тип, соответствующий функциям из "σ вещей" в "τ вещи". Например, &lt;<span class="mathit">e</span>, <span class="mathit">t</span>&gt; является типом выражений из объектов в значения истинности, то есть одноместные предикаты. Логическое выражение может быть обработано с помощью проверки типа.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_expr = nltk.sem.Expression.fromstring
&gt;&gt;&gt; expr = read_expr('walk(angus)', type_check=True)
&gt;&gt;&gt; expr.argument
&lt;ConstantExpression angus&gt;
&gt;&gt;&gt; expr.argument.type
e
&gt;&gt;&gt; expr.function
&lt;ConstantExpression walk&gt;
&gt;&gt;&gt; expr.function.type
&lt;e,?&gt;</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Почему мы видим &lt;<tt class="doctest"><span class="pre">e,?</span></tt>&gt; в конце этого примера? Несмотря на то, что программа проверки типа попытается вывести как можно больше типов, в данном случае ей не удалось полностью определить тип <tt class="doctest"><span class="pre">walk</span></tt>, так как тип его результата неизвестен. Хотя мы предполагаем, что <tt class="doctest"><span class="pre">walk</span></tt> получит тип <tt class="doctest"><span class="pre">&lt;e, t&gt;</span></tt>, в соответствии с тем, что программа проверки типа знает, в этом контексте оно может быть каким-либо другим типом, таким как <tt class="doctest"><span class="pre">&lt;e, e&gt;</span></tt> или <tt class="doctest"><span class="pre">&lt;e, &lt;e, t&gt;</span></tt>. Чтобы помочь программе проверки типа, необходимо указать <a name="signature_index_term"></a><span class="termdef">подпись</span> в виде словаря, который явно связывает типы с нелогическими константами:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sig = {'walk': '&lt;e, t&gt;'}
&gt;&gt;&gt; expr = read_expr('walk(angus)', signature=sig)
&gt;&gt;&gt; expr.function.type
e</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Бинарный предикат имеет тип &lt;<span class="mathit">e</span>, &lt;<span class="mathit">e</span>, <span class="mathit">t</span>&gt;&gt;. Несмотря на то, что это тип чего-то, что сочетается в первую очередь с аргументом типа <span class="mathit">e</span>, чтобы образовать унарный предикат, мы представляем бинарные предикаты как сочетающиеся непосредственно с их двумя аргументами. Например, предикат <span class="math">see</span> в переводе <cite>Angus sees Cyril</cite> будет сочетаться со своими аргументами, чтобы дать результат <span class="math">see(angus, cyril)</span>.</p>
<p>В логике первого порядка аргументы предикатов также могут быть индивидуальными переменными, такими как <span class="math">х</span>, <span class="math">у</span> и <span class="math">z</span>. В NLTK мы принимаем соглашение, что переменные типа <em>e</em> - все в нижнем регистре.
Индивидуальные переменные похожи на личные местоимения, как <span class="example">он</span>, <span class="example">она</span> и <span class="example">оно</span>, в том, что мы должны знать о контексте использования, чтобы выяснить их денотат.</p>
<p>Один из способов интерпретации местоимения в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog2">(14)</a> является указание на соответствующий индивидуальный объект в локальном контексте.</p>
<span class="target" id="ex-predlog2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(14)</td><td width="15"></td><td>He disappeared.</td></tr></table></p>
<p>Другой способ заключается в том, чтобы предоставить текстового предшественника для местоимения <span class="example">он</span>, например, произнеся <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog31">(15а)</a> перед <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog2">(14)</a>. Здесь мы говорим, что <span class="example">he</span> <a name="coreferential_index_term"></a><span class="termdef">соотносится</span> с именной фразой <span class="example">Cyril</span>. В результате <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog2">(14)</a> семантически эквивалентно <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog32">(15b)</a>.</p>
<span class="target" id="ex-predlog3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(15)</td><td width="15"></td><td><span class="target" id="ex-predlog31"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Cyril is Angus's dog.</td></tr></table></p>
<span class="target" id="ex-predlog32"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Cyril disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>Сравните с <span class="example">he</span> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog41">(16а)</a>. В этом случае оно <a name="bound_index_term"></a><span class="termdef">связано</span> с неопределенной <tt class="doctest"><span class="pre">NP</span></tt> <span class="example">a dog</span>, и это отношение отличное от соотнесенности. Если заменить местоимение <span class="example">he</span> на <span class="example">a dog</span>, результат <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog42">(16b)</a> <span class="emphasis">не</span> будет семантически эквивалентным <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog41">(16а)</a>.</p>
<span class="target" id="ex-predlog4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(16)</td><td width="15"></td><td><span class="target" id="ex-predlog41"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Angus had a dog but he disappeared.
</td></tr></table></p>
<span class="target" id="ex-predlog42"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Angus had a dog but a dog disappeared.
</td></tr></table></p>
</td></tr></table></p>
<p>В соответствии с <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog51">(17а)</a> мы можем построить <a name="open_formula_index_term"></a><span class="termdef">открытую формулу</span> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog52">(17b)</a> с двумя вхождениями переменной <span class="math">x</span>. (Мы игнорируем время для упрощения изложения.)</p>
<span class="target" id="ex-predlog5"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(17)</td><td width="15"></td><td><span class="target" id="ex-predlog51"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>He is a dog and he disappeared.</td></tr></table></p>
<span class="target" id="ex-predlog52"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><span class="mathit">dog(x)</span> ∧ <span class="mathit">disappear(х)</span></td></tr></table></p>
</td></tr></table></p>
<p>Размещая <a name="existential_quantifier_index_term"></a><span class="termdef">квантификатор существования</span> ∃<span class="math">х</span> ('для некоторого <span class="math">х</span>') перед <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog52">(17b)</a>, мы можем <a name="bind_index_term"></a><span class="termdef">связать</span> эти переменные, как в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog61">(18а)</a>, что означает <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog62">(18b)</a> или, более идиоматически, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog63">(18c)</a>.</p>
<span class="target" id="ex-predlog6"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(18)</td><td width="15"></td><td><span class="target" id="ex-predlog61"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>∃<span class="mathit">х.(dog(х)</span> ∧ <span class="mathit">disappear(х))</span></td></tr></table></p>
<span class="target" id="ex-predlog62"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>At least one entity is a dog and disappeared.</td></tr></table></p>
<span class="target" id="ex-predlog63"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>A dog disappeared.
</td></tr></table></p>
</td></tr></table></p>
<p>NLTK представление <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog61">(18а)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(19)</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(dog(x) &amp; disappear(x))
</span></tt></td></tr></table></p>
<p>В дополнение к квантификатору существования логика первого порядка дает нам <a name="universal_quantifier_index_term"></a><span class="termdef">универсальный квантификатор</span> ∀<span class="math">х</span> ('для всех <span class="math">х</span>'), проиллюстрированный в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog7">(20)</a>.</p>
<span class="target" id="ex-predlog7"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(20)</td><td width="15"></td><td><span class="target" id="ex-predlog71"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>∀<span class="mathit">x.(dog(x)</span> → <span class="mathit">disappear(x))</span></td></tr></table></p>
<span class="target" id="ex-predlog72"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Everything has the property that if it is a dog, it disappears.</td></tr></table></p>
<span class="target" id="ex-predlog73"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Every dog disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>Синтаксис NLTK для <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog71">(20а)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(21)</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(dog(x) -&gt; disappear(x))
</span></tt></td></tr></table></p>
<p>Хотя <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog71">(20а)</a> является стандартным переводом <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog73">(20с)</a> на язык логики первого порядка, условия истинности необязательно такие, как вы ожидаете.
Формула говорит, что <span class="emphasis">если</span> какое-то <em>x</em> - собака, то <em>x</em> исчезает, но она не говорит о том, что есть какие-то собаки. Таким образом, в ситуации, когда ни у кого нет собак, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-predlog71">(20а)</a> все равно будет истинным. (Помните, что <tt class="doctest"><span class="pre">(Р -&gt; Q)</span></tt> истинно, когда <tt class="doctest"><span class="pre">P</span></tt> ложно.) Сейчас вы могли бы возразить, что <span class="example">every dog disappeared</span> на самом деле предполагают наличие собак, и что логическая формализация просто ошибочна.  Но можно найти и другие примеры, в которых отсутствует такое предположение.
Например, мы могли бы объяснить, что значение выражения Python <tt class="doctest"><span class="pre">astring.replace(<span class="pysrc-string">'ate'</span>, <span class="pysrc-string">'8'</span>)</span></tt> является результатом замены каждого вхождения <tt class="doctest"><span class="pre"><span class="pysrc-string">'ate'</span></span></tt> в <tt class="doctest"><span class="pre">astring</span></tt> на <tt class="doctest"><span class="pre"><span class="pysrc-string">'8'</span></span></tt>, хотя на самом деле в ней может не быть таких вхождений (<a class="reference external" href="http://www.nltk.org/book/ch03.html#tab-string-methods">3.2</a>).</p>
<p>Мы видели множество примеров, когда переменные связаны квантификаторами. Что происходит в формулах, таких как эта?</p>
<pre class="literal-block">
((exists x. dog(x)) -&gt; bark(x))
</pre>
<p>Сферой квантификатора <tt class="doctest"><span class="pre">exists х</span></tt> является <tt class="doctest"><span class="pre">dog(х)</span></tt>, поэтому появление <tt class="doctest"><span class="pre">x</span></tt> в <tt class="doctest"><span class="pre">bark(x)</span></tt> не ограниченно. Следовательно, оно может стать связанным каким-либо другим квантификатором, например, <tt class="doctest"><span class="pre">all x</span></tt> в следующей формуле:</p>
<pre class="literal-block">
all x.((exists x. dog(x)) -&gt; bark(x))
</pre>
<p>Вообще вхождение переменной <tt class="doctest"><span class="pre">x</span></tt> в формуле φ является <a name="free_index_term"></a><span class="termdef">свободным</span> в φ, если это вхождение не попадает в сферу действия <tt class="doctest"><span class="pre">all x</span></tt> или <tt class="doctest"><span class="pre">some х</span></tt> в φ. И, наоборот, если <tt class="doctest"><span class="pre">х</span></tt> свободен в формуле φ, тогда <a name="bound_index_term_2"></a><span class="termdef">связан</span> в <tt class="doctest"><span class="pre">all х.</span></tt>φ и <tt class="doctest"><span class="pre">exists х.</span></tt>φ. Если все вхождения переменных в формуле связаны, то формула называется <a name="closed_index_term"></a><span class="termdef">закрытой</span>.</p>
<p>Мы уже упоминали ранее, что объект <tt class="doctest"><span class="pre">Expression</span></tt> может обрабатывать строки и возвращать объекты класса <tt class="doctest"><span class="pre">Expression</span></tt>. Каждый экземпляр <tt class="doctest"><span class="pre">expr</span></tt> этого класса имеет метод <tt class="doctest"><span class="pre">free()</span></tt>, который возвращает набор переменных, которые свободны в <tt class="doctest"><span class="pre">expr</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_expr = nltk.sem.Expression.fromstring
&gt;&gt;&gt; read_expr('dog(cyril)').free()
set()
&gt;&gt;&gt; read_expr('dog(x)').free()
{Variable('x')}
&gt;&gt;&gt; read_expr('own(angus, cyril)').free()
set()
&gt;&gt;&gt; read_expr('exists x.dog(x)').free()
set()
&gt;&gt;&gt; read_expr('((some x. walk(x)) -&gt; sing(x))').free()
{Variable('x')}
&gt;&gt;&gt; read_expr('exists x.own(y, x)').free()
{Variable('y')}</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="first-order-theorem-proving">
<h2>3.2 Доказательство теорем логики первого порядка</h2>
<p>Вспомните ограничение на <span class="example">to the north of which</span>, которое мы предложили ранее как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-north">(10)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(22)</td><td width="15"></td><td>if <span class="math">x</span> is to the north of <span class="math">y</span> then <span class="math">y</span> is not to the north of <span class="math">x</span>.</td></tr></table></p>
<p>Мы заметили, что логика высказываний не достаточно выразительна для представления обобщений о бинарных предикатах и в результате мы не правильно схватываем аргумент <span class="example">Sylvania is to the north of Freedonia. Therefore, Freedonia is not to the north of Sylvania</span>.</p>
<p>Вы, без сомнения, уже догадались, что  логика первого порядка, напротив, идеально подходит для формализации таких правил:</p>
<pre class="literal-block">
all x. all y.(north_of(x, y) -&gt; -north_of(y, x))
</pre>
<p>Более того, мы можем сделать автоматический вывод, чтобы показать обоснованность аргумента.</p>
<p>Общим случаем в доказательстве теорем является определение того, может ли формула, которую мы хотим доказать (<a name="proof_goal_index_term"></a><span class="termdef">цель доказательства)</span> быть получена с помощью конечной последовательности выводов из списка формул-посылок. Мы записываем это как <span class="mathit">S</span> ⊢ <span class="mathit">g</span>, где <tt class="doctest"><span class="pre">S</span></tt> - (возможно, пустой) список предпосылок, а <tt class="doctest"><span class="pre">g</span></tt> - цель доказательства. Проиллюстрируем это с помощью интерфейса NLTK к системе доказывания теорем Prover9.  Сначала мы разбираем цель доказательства <a class="reference internal" href="http://www.nltk.org/book/ch10.html#goal"><span id="ref-goal"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a> и две предпосылки <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ass1"><span id="ref-ass1"><img class="callout" alt="[2]" src="http://www.nltk.org/book/callouts/callout2.gif"></span></a> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ass2"><span id="ref-ass2"><img class="callout" alt="[3]" src="http://www.nltk.org/book/callouts/callout3.gif"></span></a>. Затем мы создаем экземпляр <tt class="doctest"><span class="pre">Prover9</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#new-prover"><span id="ref-new-prover"><img class="callout" alt="(4)" src="http://www.nltk.org/book/callouts/callout4.gif"></span></a> и вызываем его метод <tt class="doctest"><span class="pre">prove()</span></tt> в отношении цели доказательства для данного списка предпосылок <a class="reference internal" href="http://www.nltk.org/book/ch10.html#prove"><span id="ref-prove"><img class="callout" alt="5%" src="http://www.nltk.org/book/callouts/callout5.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; NotFnS = read_expr('-north_of(f, s)')  
&gt;&gt;&gt; SnF = read_expr('north_of(s, f)')    
&gt;&gt;&gt; R = read_expr('all x. all y. (north_of(x, y) -&gt; -north_of(y, x))')  
&gt;&gt;&gt; prover = nltk.Prover9()   
&gt;&gt;&gt; prover.prove(NotFnS, [SnF, R])  
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>К счастью, Prover9  соглашается с нами, что аргумент является действительным.  И наоборот заключает, что не представляется возможным сделать вывод о <tt class="doctest"><span class="pre">north_of(f, s)</span></tt> из наших предпсылок:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; FnS = read_expr('north_of(f, s)')
&gt;&gt;&gt; prover.prove(FnS, [SnF, R])
False</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="summarizing-the-language-of-first-order-logic">
<h2>3.3 Резюме языка логики первого порядка</h2>
<p>Мы воспользуемся этой возможностью, чтобы вновь сформулировать упомянутые нами ранее синтаксические правила для логики высказываний и добавить правила формирования для квантификаторов; вместе, они дают нам синтаксис логики первого порядка. Кроме того, мы сделаем явными типы участвующих выражений. Мы примем соглашение, что &lt;<span class="mathit">е</span><sup>n</sup>, <span class="mathit">t</span>&gt; является типом предиката, который сочетается с <span class="mathit">n</span> аргументами типа <span class="mathit">e</span>, чтобы получить выражение типа <span class="mathit">t</span>. В этом случае мы говорим, что <span class="mathit">n</span> является <a name="arity_index_term"></a><span class="termdef">арностью</span> (размерностью) предиката.</p>
<blockquote>
<ol class="lowerroman simple">
<li>If P is a predicate of type 〈en,
t〉,
and α1, ... αn
are terms of type e, then
P(α1, ... αn) is
of type t.</li>
<li>f α and β are both of type e, then (α = β) and
(α != β) are of type t.</li>
<li>If φ is of type t, then so is -φ.</li>
<li>If φ and  ψ are of type t, then so are
(φ &amp; ψ),
(φ | ψ),
(φ -&gt; ψ) and
(φ &lt;-&gt; ψ).</li>
<li>If φ is of type t, and x is a variable of type e, then
exists x.φ and  all x.φ are of
type t.</li>
</ol>
</blockquote>
<p>Таблица <a class="reference internal" href="http://www.nltk.org/book/ch10.html#tab-nltk-logic">3.1</a> обобщает новые логические константы модуля <tt class="doctest"><span class="pre">logic</span></tt> и два метода <tt class="doctest"><span class="pre">ExpressionS</span></tt>.</p>
<span class="target" id="tab-nltk-logic"></span><table border="1" class="docutils" id="tab-nltk-logic">
<colgroup>
<col width="32%">
<col width="68%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Пример</th>
<th class="head">Описание</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">=</span></tt></td>
<td>равенство</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">!=</span></tt></td>
<td>неравенство</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">exists</span></tt></td>
<td>квантификатор существования</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">all</span></tt></td>
<td>универсальный квантификатор</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">e.free()</span></tt></td>
<td>показать свободные переменные <tt class="doctest"><span class="pre">e</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">e.simplify()</span></tt></td>
<td>произвести  β-сокращение на <tt class="doctest"><span class="pre">e</span></tt></td>
</tr>
</tbody>
<td><p class="caption"><span class="caption-label">Таблица 3.1</span>: <p>Резюме новых логических отношений и операторов необходимых для логики первого порядка, наряду с двумя полезными методами класса <tt class="doctest"><span class="pre">Expression</span></tt>.</p>
</p>
</td></table>
</div>
<div class="section" id="truth-in-model">
<h2>3.4 Истинность в модели</h2>
<p>Мы рассмотрели синтаксис логики первого порядка, а в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#sec-evaluating-english-sentences">4</a> мы исследуем задачу перевода с английского языка на язык логики первого порядка. Тем не менее, как мы заявили в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#sec-nlu-introduction">1</a>, это продвигает нас вперед, только если мы можем придать смысл предложениям логики первого порядка. Другими словами, мы должны придать <span class="emphasis">семантику условной истинности</span> логике первого порядка.
С точки зрения вычислительной семантики, существуют очевидные ограничения того, как далеко можно продвинуть этот подход. Несмотря на то, что мы хотим говорить о предложениях, которые являются истинными или ложными в ситуациях, у нас есть для представления ситуаций в компьютере только средства в символической форме. Несмотря на это ограничение, все же возможно получить более ясную картину  семантики условной истинности посредством кодирования модели в NLTK.</p>
<p>Для данного языка логики первого порядка <span class="math">L</span> модель <span class="math">M</span> для <span class="math">L</span> представляет собой пару &lt;<span class="math">D</span>, <span class="math">Val</span>&gt;, где <span class="math">D</span> представляет собой непустое множество, которое называется <a name="domain_index_term"></a><span class="termdef">область</span> (домен) модели, а <span class="math">Val</span> - функция, которая называется <a name="valuation_function_index_term"></a><span class="termdef">функция оценки</span>, которая присваивает значения из <span class="math">D</span> выражениям <span class="math">L</span> следующим образом:</p>
<blockquote>
<ol class="lowerroman simple">
<li>Для каждой индивидуальной константы <span class="math">c</span> в <span class="math">L</span>, <span class="math">Val(c)</span> является элементом <span class="math">D</span>.</li>
<li>Для каждого символа предиката <span class="math">P</span> размерности <span class="math">n</span> ≥ 0, <span class="math">Val(P)</span> является функцией из <span class="math">D</span><sup>n</sup> в {<span class="mathit">True</span>, <span class="mathit">False</span>}. (Если размерность <span class="math">P</span> равно 0, то <span class="math">Val(P)</span> просто истинное значение, <span class="math">Р</span> рассматривается как символ высказывания.)</li>
</ol>
</blockquote>
<p>Согласно (ii), если <span class="math">Р</span> имее размерность 2, тогда <span class="math">Val(P)</span> будет функцией <span class="math">f</span> из пар элементов <span class="math">D</span> в {<span class="mathit">True</span>, <span class="mathit">False</span>}. В моделях, которые мы будем строить в NLTK, мы будем принимать более удобную альтернативу, в которой <span class="math">Val(P)</span> представляет собой набор <span class="math">S</span> пар, определенных следующим образом:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(23)</td><td width="15"></td><td><span class="math">S</span> = {<span class="math">S</span> | <span class="math">f(s)</span> = <span class="mathit">True</span>}</td></tr></table></p>
<p>Такая <span class="math">f</span> называется <a name="characteristic_function_index_term"></a><span class="termdef">характеристической функцией</span> <span class="math">S</span> (в соответствии с обсуждением в дополнительных материалах).</p>
<p>Отношения представлены семантически в NLTK стандартным способом теории множеств: как множества кортежей. Например, давайте предположим, что мы имеем область дискурса, состоящую из индивидуальных объектов Bertie, Olive и Cyrill, где Bertie мальчик, Olive девочка, а Cyril собака. По мнемоническим причинам мы используем <tt class="doctest"><span class="pre">b</span></tt>, <tt class="doctest"><span class="pre">o</span></tt> и <tt class="doctest"><span class="pre">c</span></tt> в качестве соответствующих ярлыков в модели. Мы можем объявить область следующим образом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> dom = {<span class="pysrc-string">'b'</span>, <span class="pysrc-string">'о'</span>, <span class="pysrc-string">'с'</span>}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы будем использовать утилитарную функцию <tt class="doctest"><span class="pre">Valuation.fromstring()</span></tt>, чтобы преобразовать список строк формы <span class="mathit">символ</span>  <tt class="doctest"><span class="pre">=&gt;</span></tt> <span class="mathit">значение</span> в объект <tt class="doctest"><span class="pre">Valuation</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
 	
&gt;&gt;&gt; v = """
... bertie =&gt; b
... olive =&gt; o
... cyril =&gt; c
... boy =&gt; {b}
... girl =&gt; {o}
... dog =&gt; {c}
... walk =&gt; {o, c}
... see =&gt; {(b, o), (c, b), (o, c)}
... """
&gt;&gt;&gt; val = nltk.Valuation.fromstring(v)
&gt;&gt;&gt; print(val)
{'bertie': 'b',
 'boy': {('b',)},
 'cyril': 'c',
 'dog': {('c',)},
 'girl': {('o',)},
 'olive': 'o',
 'see': {('o', 'c'), ('c', 'b'), ('b', 'o')},
 'walk': {('c',), ('o',)}}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Таким образом, согласно этой оценке значение <tt class="doctest"><span class="pre">see</span></tt> - это множество кортежей, таких что Bertie sees ОливOlive, Cyril sees Bertie и Olive see Cyril.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> Нарисуй рисунок области <tt class="doctest"><span class="pre">m</span></tt> и множеств, соответствующих каждому из одноместных предикатов, по аналогии со схемой на Рисунке <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-model-kids">1.2</a>.</p>
</div>
<p>Вы возможно заметили, что наши унарные предикаты (т.е., <tt class="doctest"><span class="pre">boy</span></tt>, <tt class="doctest"><span class="pre">girl</span></tt>, <tt class="doctest"><span class="pre">dog</span></tt>) также оказываются наборами одиночных кортежей, а не просто наборами индивидуальных объектов. Это сделано для удобства и позволяет нам иметь однообразную обработку отношений любой размерности. Предикация вида <span class="math">Р</span>(τ<sub>1</sub>, ... τ<sub>n</sub>), где <span class="math">Р</span> имеет размерность <span class="math">n</span>, оказывается верной только в случае, если кортеж значений, соответствующих (τ<sub>1</sub>, ... τ<sub>n</sub>) принадлежит множеству кортежей в значении <span class="math">P</span>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; ('o', 'c') in val['see']
True
&gt;&gt;&gt; ('b',) in val['boy']
True</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="individual-variables-and-assignments">
<h2>3.5 Индивидуальные переменные и присвоения</h2>
<p>В наших моделях соответствием контекста употребления является <a name="assignment_index_term"></a><span class="termdef">присвоение</span> переменной. Это соединение индивидуальных переменных с объектами в области модели дискурса.  Присвоения создаются с помощью конструктора <tt class="doctest"><span class="pre">Assignment</span></tt>, который также принимает область модели дискурса в качестве параметра. Мы не обязаны фактически вводить все привязки, но если мы это делаем, они даются в формате (<span class="mathit">переменная</span>, <span class="mathit">значение</span>) аналогичном тому, который мы видели ранее для оценок.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; g = nltk.Assignment(dom, [('x', 'o'), ('y', 'c')])
&gt;&gt;&gt; g
{'y': 'c', 'x': 'o'}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Кроме того, есть формат <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span>()</span></tt> для назначений, которые используют обозначение более близкое к тому, что часто встречается в учебниках логики:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; print(g)
g[c/y][o/x]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Давайте теперь посмотрим на то, как мы можем оценить атомарную формулу логики первого порядка. Сначала мы создаем модель, затем мы вызываем метод <tt class="doctest"><span class="pre">evaluate()</span></tt> для вычисления значения истинности.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m = nltk.Model(dom, val)
&gt;&gt;&gt; m.evaluate('see(olive, y)', g)
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Что тут происходит? Мы оцениваем формулу, которая похожа на наш более раний пример, <tt class="doctest"><span class="pre">see(olive, cyril)</span></tt>.
Однако когда функция интерпретации встречает переменную <tt class="doctest"><span class="pre">y</span></tt>, вместо того, чтобы проверять ее значение в <tt class="doctest"><span class="pre">val</span></tt>, она запрашивает присвоение переменных <tt class="doctest"><span class="pre">g</span></tt> для получения значения:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; g['y']
'c'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Так как мы уже знаем, что индивидуальные объекты <tt class="doctest"><span class="pre">o</span></tt> и <tt class="doctest"><span class="pre">c</span></tt> стоят в отношении <span class="mathit">see</span>, значение <tt class="doctest"><span class="pre">Истина</span></tt> - это то, что мы ожидали. В этом случае, мы можем сказать, что присвоение <tt class="doctest"><span class="pre">g</span></tt> <a name="satisfies_index_term"></a><span class="termdef">удовлетворяет</span> формуле <tt class="doctest"><span class="pre">see(olive, у)</span></tt>.
В противоположность этому следующая формула оценивается как <tt class="doctest"><span class="pre">Ложь</span></tt> относительно <tt class="doctest"><span class="pre">g</span></tt> - проверьте, что вы видите, почему это так.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('see(y, x)', g)
False</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>В нашем подходе (хотя и не в стандартной логике первого порядка) присвоения переменных являются <span class="emphasis">частичными</span>. Например, <tt class="doctest"><span class="pre">g</span></tt> ничего не говорит о каких-либо переменных, кроме <tt class="doctest"><span class="pre">x</span></tt> и <tt class="doctest"><span class="pre">y</span></tt>. Метод <tt class="doctest"><span class="pre">purge()</span></tt> очищает все связи присвоения.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; g.purge()
&gt;&gt;&gt; g
{}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Если мы теперь попытаемся оценить формулу, такую как <tt class="doctest"><span class="pre">see(olive, y)</span></tt> относительно <tt class="doctest"><span class="pre">g</span></tt>, это все равно что пытаться интерпретировать предложение, содержащее <span class="example">him</span>, когда мы не знаем, к чему оно (<span class="example">him</span>) относится. В этом случае функция оценки не в состоянии установить значение истинности.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('see(olive, y)', g)
'Undefined'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Так как наши модели уже содержат правила интерпретации логических операторов, сколь угодно сложные формулы могут быть составлены и оценены.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('see(bertie, olive) &amp; boy(bertie) &amp; -walk(bertie)', g)
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Общий процесс определения истинности или ложности формулы в модели называется <a name="model_checking_index_term"></a><span class="termdef">проверкой модели</span>.</p>
</div>
<div class="section" id="quantification">
<h2>3.6 Квантификация</h2>
<p>Одним из важнейших прозрений современной логики является то, что понятие удовлетворения переменной можно использовать для интерпретации квантифицированных формул. Давайте используем <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-exists1">(24)</a> в качестве примера.</p>
<span class="target" id="ex-exists1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(24)</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(girl(x) &amp; walk(x))
</span></tt></td></tr></table></p>
<p>Когда это истинно? Давайте думать обо всех индивидуальных объектах в нашем домене, то есть в <tt class="doctest"><span class="pre">dom</span></tt>. Мы хотим проверить, обладает ли какой-либо из этих объектов свойством girl и walking. Другими словами, мы хотим знать, если есть некоторые <em>u</em> в <tt class="doctest"><span class="pre">dom</span></tt>, такие что <tt class="doctest"><span class="pre">g[u/x]</span></tt> удовлетворяет открытой формуле <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-exists2">(25)</a>.</p>
<span class="target" id="ex-exists2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(25)</td><td width="15"></td><td><tt class="doctest"><span class="pre">girl(x) &amp; walk(x)</span></tt></td></tr></table></p>
<p>Рассмотрите следующее:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('exists x.(girl(x) &amp; walk(x))', g)
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p><tt class="doctest"><span class="pre">evaluate()</span></tt> возвращает <tt class="doctest"><span class="pre">Истину</span></tt> здесь, потому что есть некоторые <em>u</em> в <tt class="doctest"><span class="pre">dom</span></tt>, такие что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-exists2">(25)</a> удовлетворяется присвоением, которое связывает <tt class="doctest"><span class="pre">х</span></tt> с <em>u</em>. На самом деле, <tt class="doctest"><span class="pre">o</span></tt> является такой <em>u</em>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('girl(x) &amp; walk(x)', g.add('x', 'o'))
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Одним из полезных инструментов, предлагаемых NLTK, является метод <tt class="doctest"><span class="pre">satisfiers()</span></tt>. Он возвращает набор всех индивидуальных объектов, которые удовлетворяют открытой формуле. Параметрами метода являются разобранная формула, переменная и присвоение. Вот несколько примеров:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; fmla1 = read_expr('girl(x) | boy(x)')
&gt;&gt;&gt; m.satisfiers(fmla1, 'x', g)
{'b', 'o'}
&gt;&gt;&gt; fmla2 = read_expr('girl(x) -&gt; walk(x)')
&gt;&gt;&gt; m.satisfiers(fmla2, 'x', g)
{'c', 'b', 'o'}
&gt;&gt;&gt; fmla3 = read_expr('walk(x) -&gt; girl(x)')
&gt;&gt;&gt; m.satisfiers(fmla3, 'x', g)
{'b', 'o'}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>полезно подумать о том, почему <tt class="doctest"><span class="pre">fmla2</span></tt> и <tt class="doctest"><span class="pre">fmla3</span></tt> получить значения, которые они получают. Условия истинности для <tt class="doctest"><span class="pre">-&gt;</span></tt> означают, что <tt class="doctest"><span class="pre">fmla2</span></tt> эквивалентно <tt class="doctest"><span class="pre">-girl(x) | walk(x)</span></tt>, что удовлетворяется чем-то, что либо не girl, либо не walks. Поскольку ни <tt class="doctest"><span class="pre">b</span></tt> (Bertie), ни <tt class="doctest"><span class="pre">c</span></tt> (Cyril) не girl в соответствии с моделью <tt class="doctest"><span class="pre">m</span></tt>, они оба удовлетворяют всей формуле. И, конечно, <tt class="doctest"><span class="pre">o</span></tt> удовлетворяет формуле, так как <tt class="doctest"><span class="pre">o</span></tt> удовлетворяет обоим членам дизъюнкции. Теперь, так как все члены области дискурса удовлетворяют <tt class="doctest"><span class="pre">fmla2</span></tt>, соответствующая универсально квантифицированная формула также истинна.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; m.evaluate('all x.(girl(x) -&gt; walk(x))', g)
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Другими словами, универсально квантифицировання формула ∀<span class="mathit">x.</span>φ истинна в отношении <tt class="doctest"><span class="pre">g</span></tt>, только в случае если для любого <em>u</em>, φ истинно в отношении <tt class="doctest"><span class="pre">g[u/х]</span></tt>.</p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Попробуйте выяснить, сначала с карандашом и бумагой, а затем с помощью <tt class="doctest"><span class="pre">m.evaluate()</span></tt>, значения истинности для <tt class="doctest"><span class="pre">all x.(girl(x) &amp; walk(x))</span></tt> и <tt class="doctest"><span class="pre">exists x.(boy(x) -&gt; walk(x))</span></tt>. Убедитесь, что вы понимаете, почему они получают эти значения.</p>
</div>
</div>
<div class="section" id="quantifier-scope-ambiguity">
<h2>3.7 Неоднозначность сферы действия квантификатора</h2>
<p>Что происходит, когда мы хотим дать формальное представление предложения с <em>двумя</em> квантификаторами, такого как следующее?</p>
<span class="target" id="ex-scope1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(26)</td><td width="15"></td><td>Everybody admires someone.
</td></tr></table></p>
<p>Есть (по крайней мере) два способа выражения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope1">(26)</a> в логике первого порядка:</p>
<span class="target" id="ex-scope2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(27)</td><td width="15"></td><td><span class="target" id="ex-scope2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(person(x) -&gt; exists y.(person(y) &amp; admire(x,y)))</span></tt></td></tr></table></p>
<span class="target" id="ex-scope2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists y.(person(y) &amp; all x.(person(x) -&gt; admire(x,y)))
</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Можем ли мы использовать оба этих варианта? Ответ да, но они имеют разные значения. <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2b">(27b)</a> логически сильнее, чем <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2a">(27a)</a>: он утверждает, что существует единственный человек, скажем, Брюс, который восхищает всех.
С другой стороны, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2a">(27а)</a> просто требует, чтобы для каждого человека <span class="mathit">u</span> можно было найти человека <span class="mathit">u'<span class="mathit">, которым </span>u</span> восхищается; но это может быть каждый раз другой человек <span class="mathit">u'</span>. Мы различаем <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2a">(27a)</a> и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2b">(27b)</a> по <a name="scope_index_term"></a><span class="termdef">сфере действия</span> квантификаторов. В первом варианте ∀ имеет более широкий охват, чем ∃, тогда как в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2b">(27b)</a>, соотношение сфер обратное. Так что теперь у нас есть два способа представления значения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope1">(26)</a>, и они оба вполне правомерны. Другими словами, мы утверждаем, что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope1">(26)</a> <em>неоднозначно</em> относительно охвата квантификаторов, а формулы в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2">(27)</a> дают нам возможность сделать два прочтения явными.
Тем не менее, мы заинтересованы не просто в связывании двух различных представлений с <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope1">(26)</a>. Мы также хотим показать в деталях, как эти два представления приводят к различным условиям истинности в модели.</p>
<p>Для того, чтобы более внимательно изучить неоднозначность, давайте исправим нашу оценку следующим образом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; v2 = """
... bruce =&gt; b
... elspeth =&gt; e
... julia =&gt; j
... matthew =&gt; m
... person =&gt; {b, e, j, m}
... admire =&gt; {(j, b), (b, b), (m, e), (e, m)}
... """
&gt;&gt;&gt; val2 = nltk.Valuation.fromstring(v2)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Отношение <span class="mathit">admire</span> можно визуализировать с помощью схемы отображения, показанной на рисунке <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-admire-mapping">(28)</a>.</p>
<span class="target" id="ex-admire-mapping"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(28)</td><td width="15"></td><td><img alt="../images/models_admire.png" src="http://www.nltk.org/images/models_admire.png" style="width:35.2px;height:38.400000000000006px"></td></tr></table></p>
<p>На рисунке <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-admire-mapping">(28)</a> стрелка между двумя индивидуальными объектами <span class="math">х</span> и <span class="math">у</span> означает, что <span class="math">х</span> восхищается <span class="math">у</span>. Таким образом, <tt class="doctest"><span class="pre">j</span></tt> и <tt class="doctest"><span class="pre">b</span></tt> оба восхищаются <tt class="doctest"><span class="pre">b</span></tt> (Брюс очень показной), а <tt class="doctest"><span class="pre">e</span></tt> восхищается <tt class="doctest"><span class="pre">m</span></tt> и <tt class="doctest"><span class="pre">m</span></tt> восхищается <tt class="doctest"><span class="pre">e</span></tt>. В этой модели формула <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2a">(27а)</a> истинна, а <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2b">(27b)</a> ложна. Одним из способов изучения этих результатов является метод <tt class="doctest"><span class="pre">satisfiers()</span></tt> объектов <tt class="doctest"><span class="pre">Model</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dom2 = val2.domain
&gt;&gt;&gt; m2 = nltk.Model(dom2, val2)
&gt;&gt;&gt; g2 = nltk.Assignment(dom2)
&gt;&gt;&gt; fmla4 = read_expr('(person(x) -&gt; exists y.(person(y) &amp; admire(x, y)))')
&gt;&gt;&gt; m2.satisfiers(fmla4, 'x', g2)
{'e', 'b', 'm', 'j'}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Это показывает, что <tt class="doctest"><span class="pre">fmla4</span></tt> содержит для каждого индивидуального объетка в домене.
В противоположность этому, рассмотрим формулу <tt class="doctest"><span class="pre">fmla5</span></tt> ниже; она не имеет удовлетворяющих для переменной <tt class="doctest"><span class="pre">у</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; fmla5 = read_expr('(person(y) &amp; all x.(person(x) -&gt; admire(x, y)))')
&gt;&gt;&gt; m2.satisfiers(fmla5, 'y', g2)
set()</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>То есть, нет ни одного человека, которым восхищаются все. Принимая другую открытую формулу, <tt class="doctest"><span class="pre">fmla6</span></tt>, мы можем убедиться в том , что есть человек, а именно Брюс, который вызывает восхищение как Юлии, так и Брюса.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; fmla6 = read_expr('(person(y) &amp; all x.((x = bruce | x = julia) -&gt; admire(x, y)))')
&gt;&gt;&gt; m2.satisfiers(fmla6, 'y', g2)
{'b'}</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last"><strong>Ваша очередь:</strong> 
Придумайте новую модель, основанную на <tt class="doctest"><span class="pre">m2</span></tt>, такую что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2a">(27а)</a> оказывается ложным в вашей модели; аналогичным образом придумайте новую модель, такую что <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope2b">(27b)</a> оказывается истинным.</p>
</div>
</div>
<div class="section" id="model-building">
<h2>3.8 Построение модели</h2>
<p>До сих пор мы предполагали, что у нас уже есть модель, и хотели проверить истинность предложения в модели.  В противоположность этому построение модели пытается создать новую модель для данного набора предложений. Если это удается, тогда мы знаем, что множество совместимо, так как мы имеем доказательство существования модели.</p>
<p>Мы вызываем построитель моделей Mace4 путем создания экземпляра класса <tt class="doctest"><span class="pre">Mace()</span></tt> и вызова метода <tt class="doctest"><span class="pre">build_model()</span></tt> аналогично вызову доказателя теорем Prover9. Одним из вариантов является обработка нашего набора предложений в качестве посылок, оставив цель не определенной.  Следующее взаимодействие показывает, почему <tt class="doctest"><span class="pre">[а, с1]</span></tt> и <tt class="doctest"><span class="pre">[а, с2]</span></tt> являются совместимыми списками, так как Mace удается построить модель для каждого из них, в то время как <tt class="doctest"><span class="pre">[с1, с2]</span></tt> несовместим.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; a3 = read_expr('exists x.(man(x) &amp; walks(x))')
&gt;&gt;&gt; c1 = read_expr('mortal(socrates)')
&gt;&gt;&gt; c2 = read_expr('-mortal(socrates)')
&gt;&gt;&gt; mb = nltk.Mace(5)
&gt;&gt;&gt; print(mb.build_model(None, [a3, c1]))
True
&gt;&gt;&gt; print(mb.build_model(None, [a3, c2]))
True
&gt;&gt;&gt; print(mb.build_model(None, [c1, c2]))
False</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы также можем использовать построитель моделей в качестве дополнения к доказателю теорем.
Давайте предположим, что мы пытаемся доказать <tt class="doctest"><span class="pre">S</span></tt> ⊢ <tt class="doctest"><span class="pre">g</span></tt>, т.е. <tt class="doctest"><span class="pre">g</span></tt> логически выводимое из предположений <tt class="doctest"><span class="pre">S = [s1, s2, ..., sn]</span></tt>.  Мы можем ввести эти же данные в Mace4, и он будет пытаться найти контрпример, то есть показать, что <tt class="doctest"><span class="pre">g</span></tt> <em>не</em> следует из <tt class="doctest"><span class="pre">S</span></tt>.Таким образом, для данного входа Mace4 попытается найти модель для множества <tt class="doctest"><span class="pre">S</span></tt> вместе с отрицанием <tt class="doctest"><span class="pre">g</span></tt>, то есть для списка <tt class="doctest"><span class="pre">S' = [s1, s2, ..., sn, -g]</span></tt>. Если <tt class="doctest"><span class="pre">g</span></tt> не следоует из <tt class="doctest"><span class="pre">S</span></tt>, то Mace4 вполне может вернуть контрпример быстрее, чем Prover9 придет к выводу, что он не может найти требуемое доказательство.  И наоборот, если <tt class="doctest"><span class="pre">g</span></tt> <span class="emphasis">выводимо</span> из <tt class="doctest"><span class="pre">S</span></tt>, Mace4 может длительное время безуспешно пытаться найти контрмодель и в конечном итоге сдаться.</p>
<p>Рассмотрим конкретный сценарий. Наши посылки - это список [<span class="example">There is a woman that every man loves</span>, <span class="example">Adam is a man</span>, <span class="example">Eve is a woman</span>]. Наш вывод: <span class="example">Adam loves Eva</span>. Может ли Mace4 найти модель, в которой посылки истинны, а заключение ложно? В следующем коде мы используем метод <tt class="doctest"><span class="pre">MaceCommand()</span></tt>, который позволит нам осмотреть модель, которая была построена.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; a4 = read_expr('exists y. (woman(y) &amp; all x. (man(x) -&gt; love(x,y)))')
&gt;&gt;&gt; a5 = read_expr('man(adam)')
&gt;&gt;&gt; a6 = read_expr('woman(eve)')
&gt;&gt;&gt; g = read_expr('love(adam,eve)')
&gt;&gt;&gt; mc = nltk.MaceCommand(g, assumptions=[a4, a5, a6])
&gt;&gt;&gt; mc.build_model()
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Так что ответ да: Mace4 нашел контрмодель, в которой есть какая-то женщина, кроме Евы, которую Адам любит. Но давайте подробнее рассмотрим модель Mace4, преобразованную в формат, который мы используем для оценок.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; print(mc.valuation)
{'C1': 'b',
 'adam': 'a',
 'eve': 'a',
 'love': {('a', 'b')},
 'man': {('a',)},
 'woman': {('a',), ('b',)}}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Общая форма этой оценки должна быть вам знакома: она содержит некоторые индивидуальные константы и предикаты, каждый из которых имеет надлежащий вид значения. Что может быть незнакомым, так это <tt class="doctest"><span class="pre">C1</span></tt>. Это "константа Сколема", которую наш построитель модели вводит в качестве представителя квантификатора существования. То есть, когда построитель модели столкнулся с <tt class="doctest"><span class="pre">exists y</span></tt> частью <tt class="doctest"><span class="pre">a4</span></tt>, он знал, что есть некоторый индивидуальный объект <tt class="doctest"><span class="pre">b</span></tt> в данной области,  который удовлетворяет открытой формуле в теле <tt class="doctest"><span class="pre">а4</span></tt>. Однако он не знает, является ли <tt class="doctest"><span class="pre">b</span></tt> так же обозначением индивидуальной константы где-либо еще в его входе, так что он создает новое имя для <tt class="doctest"><span class="pre">b</span></tt> "на лету", а именно <tt class="doctest"><span class="pre">C1</span></tt>. Теперь, так как наши посылки ничего не говорят об индивидуальных константах <tt class="doctest"><span class="pre">adam</span></tt> и <tt class="doctest"><span class="pre">eve</span></tt>, построитель модели решил, что нет никаких оснований рассматривать их как обозначающие различные объекты, и они оба были сопоставлены с <tt class="doctest"><span class="pre">a</span></tt>. Кроме того, мы не указали, что <tt class="doctest"><span class="pre">man</span></tt> и <tt class="doctest"><span class="pre">woman</span></tt> обозначают непересекающиеся множества, поэтому построитель модели позволяет их денотациям перекрывать друг друга. Это иллюстрирует довольно резко неявное знание, которые мы привносим в интерпретацию нашего сценария, о котором построитель модели ничего не знает.
Поэтому давайте добавим новое предположение, которое делает множества мужчин и женщин не пересекающимися. Построитель модели все равно производит контрмодель, но на этот раз она больше соответствует нашим интуициям о ситуации:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; a7 = read_expr('all x. (man(x) -&gt; -woman(x))')
&gt;&gt;&gt; g = read_expr('love(adam,eve)')
&gt;&gt;&gt; mc = nltk.MaceCommand(g, assumptions=[a4, a5, a6, a7])
&gt;&gt;&gt; mc.build_model()
True
&gt;&gt;&gt; print(mc.valuation)
{'C1': 'c',
 'adam': 'a',
 'eve': 'b',
 'love': {('a', 'c')},
 'man': {('a',)},
 'woman': {('c',), ('b',)}}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>По здравому размышлению мы можем увидеть, что в наших посылках нет ничего, что говорит, что Ева является единственной женщиной в области дискурса, поэтому контрмодель, на самом деле, является приемлемой. Если бы мы хотели исключить это, мы должны были бы добавить еще одно предположение, такое как <tt class="doctest"><span class="pre">exists y. all x. (woman(x) -&gt; (x = y))</span></tt>, чтобы гарантировать, что есть только одна женщина в модели.</p>
</div>
</div>
<div class="section" id="the-semantics-of-english-sentences">
<span id="sec-evaluating-english-sentences"></span><h1>4 Семантика английских предложений</h1>
<div class="section" id="compositional-semantics-in-feature-based-grammar">
<h2>4.1 Композиционная семантика в грамматике на основе свойств</h2>
<p>В начале главы мы кратко показали способ построения семантических представлений на основе синтаксического разбора в рамках грамматики, разработанной в <a class="reference external" href="http://www.nltk.org/book/ch09.html#chap-featgram">9.</a>. На этот раз вместо построения запроса SQL мы будем строить логическую форму. Одной из наших руководящих идей для проектирования таких грамматик является <a name="principle_of_compositionality_index_term"></a><span class="termdef">Принцип композиционности</span>.  (Известный также как принцип Фреге, см. формулировку, данную ниже, в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#partee1995lsc" id="id4">(Gleitman &amp; Liberman, 1995)</a>.)</p>
<p><strong>Принцип композиционности:</strong> Значение целого является функцией значений частей и способа, которым они синтаксически объединены.</p>
<p>Будем считать, что семантически соответствующие части сложного выражения задаются теорией синтаксического анализа. В этой главе мы будем считать, как само собой разумеющееся, что выражения обрабатываются с помощью контекстно-свободной грамматики. Тем не менее, это не подразумевается принципом композиционности.</p>
<p>Наша цель сейчас состоит в том, чтобы интегрировать построение семантического представления в манере, которая будет просто сочетаться с процессом разбора. Рисунок <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem3">(29)</a> иллюстрирует первое приближение к анализу, который мы хотели бы построить.</p>
<span class="target" id="ex-sem3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(29)</td><td width="15"></td><td><img alt="tree_images / CH10-дерево-1.png" class="align-top" src="http://www.nltk.org/book/tree_images/ch10-tree-1.png" style="width:319.0px;height:144.0px"></td></tr></table></p>
<p>На рисунке <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem3">(29)</a> значение <tt class="doctest"><span class="pre">sem</span></tt> в корневом узле показывает семантическое представление всего предложения, в то время как значения <tt class="doctest"><span class="pre">sem</span></tt> в нижних узлах показывают семантические представления для компонентов предложения. Так как значения <tt class="doctest"><span class="pre">sem</span></tt> должны быть обработаны особым образом, они отделены от значений других свойств, будучи заключенными в угловые скобки.</p>
<p>Это очень хорошо, но как мы напишем правила грамматики, которые дадут нам такой результат? Наш подход будет аналогичен принятому для грамматики <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> в начале этой главы, в том, что мы назначим семантические представления для лексических узлов, а затем составим семантические представления для каждой фразы из семантических представлений ее дочерних узлов. Однако в данном случае мы будем использовать функциональное применение, нежели строковую конкатенацию в качестве режима композиции. Конкретно говоря, предположим, что мы имеем <tt class="doctest"><span class="pre">NP</span></tt> и <tt class="doctest"><span class="pre">VP</span></tt> компоненты с соответствующими значениями для их узлов <tt class="doctest"><span class="pre">sem</span></tt>. Тогда <tt class="doctest"><span class="pre">sem</span></tt> значение <tt class="doctest"><span class="pre">S</span></tt> обрабатывается правилом, как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem4">(30)</a>. (Заметим, что в случае, когда значение <tt class="doctest"><span class="pre">sem</span></tt> является переменной, мы опускаем угловые скобки.)</p>
<span class="target" id="ex-sem4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(30)</td><td width="15"></td><td>S[SEM=&lt;?vp(?np)&gt;] -&gt; NP[SEM=?np] VP[SEM=?vp]
</td></tr></table></p>
<p><a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem4">(30)</a> говорит нам, что для данного некоторого <tt class="doctest"><span class="pre">sem</span></tt> значения <tt class="doctest"><span class="pre">?np</span></tt> для субъекта <tt class="doctest"><span class="pre">NP</span></tt> и некоторого <tt class="doctest"><span class="pre">sem</span></tt> значения <tt class="doctest"><span class="pre">?vp</span></tt> для <tt class="doctest"><span class="pre">VP</span></tt>, <tt class="doctest"><span class="pre">sem</span></tt> значение родителя <tt class="doctest"><span class="pre">S</span></tt> строится путем применения <tt class="doctest"><span class="pre">?vp</span></tt> как функционального выражения к <tt class="doctest"><span class="pre">?np</span></tt>.  Исходя из этого можно сделать вывод о том, что <tt class="doctest"><span class="pre">?vp</span></tt> должна денотировать функцию, которая имеет в качестве денотации <tt class="doctest"><span class="pre">?np</span></tt> в своей области.<a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem4">(30)</a> представляет собой хороший пример построения семантики с помощью принципа композиционности.</p>
<p>Завершить построение этой грамматики очень просто; все, что нам требуется, - это правила, приведенные ниже.</p>
<pre class="literal-block">
VP[SEM=?v] -&gt; IV[SEM=?v]
NP[SEM=&lt;cyril&gt;] -&gt; 'Cyril'
IV[SEM=&lt;\x.bark(x)&gt;] -&gt; 'barks'
</pre>
<p>Правило <tt class="doctest"><span class="pre">VP</span></tt> говорит, что родительская семантика является такой же, как семантика ребенка главы. Два лексических правила предоставляют нелогические константы в качестве семантических значений <span class="example">Cyril</span> и <span class="example">barks</span> соответственно. Существует дополнительные обозначения в записи для <span class="example">barks</span>, которую мы объясним в ближайшее время.</p>
<p>Перед тем, как пускать в ход более детальные правила композиционной семантики, нам нужно добавить новый инструмент в наш набор, а именно λ [лямбда] исчисление. Оно дает нам бесценный инструмент для объединения выражений логики первого порядка, когда мы собираем представление смысла английского предложения.</p>
</div>
<div class="section" id="the-lambda-calculus">
<h2>4.2 λ-исчисление</h2>
<p>В <a class="reference external" href="http://www.nltk.org/book/ch01.html#sec-computing-with-language-simple-statistics">3</a> мы отметили, что математическое обозначение множества было полезным способом указания свойств <span class="math">P</span> слов, которые мы хотели выбрать из документа. Мы проиллюстрировал это с помощью записи <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-set-comprehension-math2">(31)</a>, которую мы снабдили комментарием "множество всех <span class="math">w</span> такое, что <span class="math">w</span> является элементом <span class="math">V</span> (словаря) и <span class="math">w</span> имеет свойство <span class="math">Р</span>".</p>
<span class="target" id="ex-set-comprehension-math2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(31)</td><td width="15"></td><td><span class="math">{w</span> | <span class="math">w</span> ∈ <span class="math">V</span> &amp; <span class="math">P(w)}</span></td></tr></table></p>
<p>Оказывается чрезвычайно полезным добавить что-то к логике первого порядка, что будет достигать того же эффекта. Мы делаем это с помощью <a name="λ_operator_index_term"></a><span class="termdef">λ оператора</span> (произносится как "лямбда"). <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-lambda1">(32)</a> является λ аналогом <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-set-comprehension-math2">(31)</a>. (Так как мы не пытаемся заниматься теорией множеств здесь, мы рассматриваем <span class="math">V</span> просто как унарный предикат.)</p>
<span class="target" id="ex-lambda1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(32)</td><td width="15"></td><td>λ<span class="math">w</span>. (<span class="math">(V(w)</span> ∧ <span class="math">P(w)</span>)</td></tr></table></p>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">λ выражения были первоначально разработаны Alonzo Church для представления вычислимых функций и для того, чтобы обеспечить основу для математики и логики. Теория, в которой изучаются λ выражения, известна как λ-исчисление. Заметим, что λ-исчисление не является частью логики первого порядка - оба могут быть использованы независимо друг от друга.</p>
</div>
<p>λ является связывающим оператором, так же, как квантификаторы логики первого порядка. Если мы имеем открытую формулу, такую как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum11">(33а)</a>, то мы можем связать переменную <span class="math">х</span> с оператором λ, как показано в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum12">(33b)</a>.  Соответствующее NLTK представление дано в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-lambda">(33c)</a>.</p>
<span class="target" id="ex-walk-chewgum1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(33)</td><td width="15"></td><td><span class="target" id="ex-walk-chewgum11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>(walk(x) ∧ chew_gum(x))
</td></tr></table></p>
<span class="target" id="ex-walk-chewgum12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>λx.(walk(x) ∧ chew_gum(x))
</td></tr></table></p>
<span class="target" id="ex-lambda"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.(walk(x) &amp; chew_gum(x))
</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Помните, что <tt class="doctest"><span class="pre">\</span></tt> это специальный символ в строках Python.
Мы могли бы экранировать его (с помощью другого <tt class="doctest"><span class="pre">\</span></tt>), либо использовать "raw strings" (<a class="reference external" href="http://www.nltk.org/book/ch03.html#sec-regular-expressions-word-patterns">3.4</a>):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_expr = nltk.sem.Expression.fromstring
&gt;&gt;&gt; expr = read_expr(r'\x.(walk(x) &amp; chew_gum(x))')
&gt;&gt;&gt; expr
&lt;LambdaExpression \x.(walk(x) &amp; chew_gum(x))&gt;
&gt;&gt;&gt; expr.free()
set()
&gt;&gt;&gt; print(read_expr(r'\x.(walk(x) &amp; chew_gum(y))'))
\x.(walk(x) &amp; chew_gum(y))</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX next sentence has a bad linebreak: ab-straction (tweak?) -->
<p>У нас есть специальное название для результата связывания переменных в выражении: <a name="λ_abstraction_index_term"></a><span class="termdef">λ абстракция</span>. Когда вы впервые сталкиваетесь с λ-абстракциями, может быть трудно интуитивно понять их смысл. Несколько английских комментариев для <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum12">(33b)</a>: "be an <span class="math">х</span> such that <span class="math">х</span> walks and <span class="math">х</span> chews gum" или "have the property of walking and chewing gum".  Часто высказывалось предположение, что λ-абстракции являются хорошими представления для глагольных фраз (или бессубъектных предложений), особенно когда они возникают в качестве аргументов в их собственной правой стороне. Это проиллюстрировано в предложении <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum21">(34а)</a> и его переводе <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum22">(34b)</a>.</p>
<span class="target" id="ex-walk-chewgum2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(34)</td><td width="15"></td><td><span class="target" id="ex-walk-chewgum21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>To walk and chew-gum is hard</td></tr></table></p>
<span class="target" id="ex-walk-chewgum22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">hard(\х.(walk(х) &amp; chew_gum(х)))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Таким образом, общая картина такова: для данной открытой формулы φ со свободной переменной <span class="math">х</span>, абстракция над <span class="math">х</span> дает выражение свойства λ<span class="math">х.</span>φ - свойство быть <span class="math">х</span>, таким что φ. Вот более официальная версия того, как строятся абстракции:</p>
<!-- XXX strange formatting of next paragraph, with initial "#." deleted, for docbook processing -->
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(35)</td><td width="15"></td><td>Если α имеет тип τ и <span class="math">х</span> является переменной типа e, то <tt class="doctest"><span class="pre">\х.</span></tt>α имеет тип &lt;<span class="mathit">е</span>, τ&gt;.</td></tr></table></p>
<p><a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum22">(34b)</a> иллюстрирует случай, когда мы говорим что-то о свойстве, а именно что оно трудно. Но то, что мы обычно делаем со свойствами, - это отнесение их к индивидуальным объектам. И в самом деле, если φ является открытой формулой, то абстракция λ<span class="math">х.</span>φ может быть использована в качестве одноместного предиката. В <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum3">(36)</a> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum12">(33b)</a> является предикатом термина <span class="mathit">gerald</span>.</p>
<span class="target" id="ex-walk-chewgum3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(36)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.(walk(х) &amp; chew_gum(х)) (gerald)</span></tt></td></tr></table></p>
<p>Теперь <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum3">(36)</a> говорит, что Gerald обладает свойством walking и chewing gum, что имеет то же значение, что и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum4">(37)</a>.</p>
<span class="target" id="ex-walk-chewgum4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(37)</td><td width="15"></td><td><tt class="doctest"><span class="pre">(walk(gerald) &amp; chew_gum(gerald))
</span></tt></td></tr></table></p>
<p>То, что мы сделали здесь, - это удалили <tt class="doctest"><span class="pre">\х</span></tt> из начала <tt class="doctest"><span class="pre">\х.(walk(х) &amp; chew_gum(х))</span></tt> и заменили все вхождения <tt class="doctest"><span class="pre">х</span></tt> в <tt class="doctest"><span class="pre">(walk(х) &amp; chew_gum(х))</span></tt> на <tt class="doctest"><span class="pre">gerald</span></tt>. Мы будем использовать α[β<span class="mathit">/х</span>] в качестве обозначения для операции замены всех свободных вхождений <span class="mathit">х</span> в α на выражение β. Так:</p>
<pre class="literal-block">
(walk(x) &amp; chew_gum(x))[gerald/x]
</pre>
<p>то же выражение, что и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum4">(37)</a>.  "Сокращение" <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum3">(36)</a> к <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum4">(37)</a> является чрезвычайно полезной операцией в упрощении семантических представлений, и мы будем часто использовать его в остальной части этой главы. Эту операцию часто называют <a name="β_reduction_index_term"></a><span class="termdef">β-сокращением</span>. Для того, чтобы она была семантически оправдана, мы хотели бы убедиться, что λ<span class="math">х.</span> α(β) имеет те же семантические значения, что и α[β<span class="math">/х</span>]. Это действительно так при условии незначительного усложнения, к которому мы придем в ближайшее время.  Для выполнения β-сокращения выражений в NLTK мы можем вызвать метод <tt class="doctest"><span class="pre">simplify()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#simplify"><span id="ref-simplify"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; expr = read_expr(r'\x.(walk(x) &amp; chew_gum(x))(gerald)')
&gt;&gt;&gt; print(expr)
\x.(walk(x) &amp; chew_gum(x))(gerald)
&gt;&gt;&gt; print(expr.simplify()) 
(walk(gerald) &amp; chew_gum(gerald))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Хотя мы до сих пор рассматривали только те случаи, когда тело λ абстракции является открытой формулой, т. е. типа <span class="math">t</span>λ это не является необходимым ограничением; тело может быть любым хорошо сформированным выражением. Вот пример с двумя λ.</p>
<span class="target" id="ex-double-lambda"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(38)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.\y.(dog(x) &amp; own(y, x))
</span></tt></td></tr></table></p>
<p>Так же, как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-walk-chewgum12">(33b)</a> играет роль одноместного предиката, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-double-lambda">(38)</a> работает как бинарный предикат: он может быть применен непосредственно к двум аргументам <a class="reference internal" href="http://www.nltk.org/book/ch10.html#dbl-lambda"><span id="ref-dbl-lambda"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>. Логические выражения могут содержать вложенные λ, такие как <tt class="doctest"><span class="pre">\х.\y.</span></tt>, записываемые в сокращенном виде <tt class="doctest"><span class="pre">\х у.</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#dbl-lambda"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; print(read_expr(r'\x.\y.(dog(x) &amp; own(y, x))(cyril)').simplify())
\y.(dog(cyril) &amp; own(y,cyril))
&gt;&gt;&gt; print(read_expr(r'\x y.(dog(x) &amp; own(y, x))(cyril, angus)').simplify()) 
(dog(cyril) &amp; own(angus,cyril))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Все наши λ абстракции до сих пор включали знакомые переменные первого порядка: <tt class="doctest"><span class="pre">x</span></tt>, <tt class="doctest"><span class="pre">y</span></tt> и так далее - переменные типа <em>e</em>. Но предположим, что мы хотим обработать одну абстракцию, скажем <tt class="doctest"><span class="pre">\x.walk(х)</span></tt> в качестве <span class="emphasis">аргумента</span> другой λ абстракции? Мы могли бы попробовать это:</p>
<pre class="literal-block">
\y.y(angus)(\x.walk(х))
</pre>
<p>Но так как переменная <tt class="doctest"><span class="pre">y</span></tt> должна иметь тип <em>е</em>, <tt class="doctest"><span class="pre">\y.y(angus)</span></tt> применяется только к аргументам типа <em>e</em>, в то время как <tt class="doctest"><span class="pre">\x.walk(х)</span></tt> имеет тип &lt;<em>е</em>, <em>t</em>&gt;! Вместо этого мы должны разрешить абстракцию над переменными более высокого типа. Давайте использовать <tt class="doctest"><span class="pre">P</span></tt> и <tt class="doctest"><span class="pre">Q</span></tt> в качестве переменных типа &lt;<em>е</em>, <em>t</em>&gt;, а затем мы можем получить абстракцию, такую как <tt class="doctest"><span class="pre">\P.P(angus)</span></tt>. Так как <tt class="doctest"><span class="pre">Р</span></tt> имеет тип &lt;<em>е</em>, <em>t</em>&gt;, вся абстракция имеет тип &lt;&lt; <em>е</em>, <em>t</em>&gt;, <em>t</em>&gt;. Тогда <tt class="doctest"><span class="pre">\P.P(angus)(\x.walk(х))</span></tt> является допустимым и может быть приведено с помощью β-сокращения к <tt class="doctest"><span class="pre">\x.walk(х)(angus)</span></tt>, а затем снова к <tt class="doctest"><span class="pre">walk(angus)</span></tt></p>
<p>При проведении β-редукции некоторую осторожность следует проявить по отношению к переменным. Рассмотрим, например, λ выражения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha1a">(39a)</a> и <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha1b">(39b)</a>, которые отличаются только именем свободной переменной.</p>
<span class="target" id="ex-alpha1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(39)</td><td width="15"></td><td><span class="target" id="ex-alpha1a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.see(y, x)</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha1b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.see(y, z)
</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Предположим теперь, что мы применим λ-выражение <tt class="doctest"><span class="pre">\P.exists х.Р(х)</span></tt> к каждому из них:</p>
<span class="target" id="ex-alpha2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(40)</td><td width="15"></td><td><span class="target" id="ex-alpha2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.P(x)(\y.see(y, x))</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.P(x)(\y.see(y, z))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Мы указывали выше, что результаты применения должны быть семантически эквивалентными.
Но если мы позволим свободной переменной <tt class="doctest"><span class="pre">х</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha1a">(39а)</a> попасть в сферу действия экзистенциального квантификатора в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha2a">(40а)</a>, то после сокращения результаты будут отличаться:</p>
<span class="target" id="ex-alpha3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(41)</td><td width="15"></td><td><span class="target" id="ex-alpha3a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.see(x, x)</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha3b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.see(x, z)</span></tt></td></tr></table></p>
</td></tr></table></p>
<p><a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha3a">(41а)</a> означает, что есть некоторый <tt class="doctest"><span class="pre">x</span></tt>, который видит себя, в то время как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha3b">(41b)</a> означает, что есть некоторый <tt class="doctest"><span class="pre">x</span></tt>, который видит неопределенный индивидуальный объект <tt class="doctest"><span class="pre">z</span></tt>. Что пошло не так здесь? Очевидно, что мы хотим запретить "захват" переменной того типа, который был в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha3a">(41а)</a>.</p>
<p>Для того, чтобы решить эту проблему, давайте сделаем шаг назад не на долго. Имеет ли значение, какое конкретное имя мы используем для переменной, связанной с экзистенциальным квантификатором в функциональном выражении <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-alpha2a">(40а)</a>? Ответ - нет. На самом деле, для любого данного выражения, связывающего переменную, (включающего ∀, ∃ или λ) имя, которое было выбрано для связанной переменной, совершенно произвольно. Например, <tt class="doctest"><span class="pre">exists x.P(x)</span></tt> и <tt class="doctest"><span class="pre">exists y.P(y)</span></tt> эквивалентны; они называются <a name="α_equivalents_index_term"></a><span class="termdef">α эквивалентами</span>, или <a name="alphabetic_variants_index_term"></a><span class="termdef">буквенными вариантами</span>. Процесс перемаркировки связанных переменных известен как <a name="α_conversion_index_term"></a><span class="termdef">α-преобразование</span>. Когда мы тестируем равенство объектов <tt class="doctest"><span class="pre">VariableBinderExpression</span></tt> в модуле <tt class="doctest"><span class="pre">logic</span></tt> (т. е. с помощью <tt class="doctest"><span class="pre">==</span></tt>), мы фактически тестируем на α-эквивалентность:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr1 = read_expr(<span class="pysrc-string">'exists x.P(x)'</span>) 
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr1) 
<span class="pysrc-output">exists x.P(x)</span> <span class="pysrc-output"></span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr2 = expr1.alpha_convert(nltk.sem.Variable(<span class="pysrc-string">'z'</span>)) 
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr2) 
<span class="pysrc-output">exists z.P(z)</span> <span class="pysrc-output"></span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr1 == expr2 <span class="pysrc-output"></span>
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Когда β-сокращение выполняется на аппликации <tt class="doctest"><span class="pre">f(a)</span></tt>, мы проверяем, есть ли свободные переменные в <tt class="doctest"><span class="pre">a</span></tt>, которые также встречаются как связанные переменные в любых подвыражениях <tt class="doctest"><span class="pre">f</span></tt>. Предположим, что, как и в примере, рассмотренном выше, <tt class="doctest"><span class="pre">х</span></tt> свободная переменная в <tt class="doctest"><span class="pre">а</span></tt> и что <tt class="doctest"><span class="pre">f</span></tt> содержит подвыражение <tt class="doctest"><span class="pre">exists х.Р(х)</span></tt>. В этом случае мы производим буквенный вариант <tt class="doctest"><span class="pre">exists х.Р(х)</span></tt>, скажем, <tt class="doctest"><span class="pre">exists z1.P(z1)</span></tt>, а затем продолжаем сокращение. Этот переобозначение осуществляется автоматически с помощью кода β-сокращения в модуле <tt class="doctest"><span class="pre">logic</span></tt>, результаты можно увидеть в следующем примере.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; expr3 = read_expr('\P.(exists x.P(x))(\y.see(y, x))')
&gt;&gt;&gt; print(expr3)
(\P.exists x.P(x))(\y.see(y,x))
&gt;&gt;&gt; print(expr3.simplify())
exists z1.see(z1,x)</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Замечание</p>
<p class="last">В процессе работы над подобными примерами в следующих разделах вы можете обнаружить, что возвращаемые логические выражения имеют разные имена переменных; например, вы можете увидеть <tt class="doctest"><span class="pre">z14</span></tt> вместо <tt class="doctest"><span class="pre">z1</span></tt> в формуле выше. Это изменение в маркировке безвредно - на самом деле, это всего лишь иллюстрация буквенных вариантов.</p>
</div>
<p>После этого экскурса давайте вернемся к задаче построения логических форм для английских предложений.</p>
</div>
<div class="section" id="quantified-nps">
<h2>4.3 Квантифицированные именные фразы (NP)</h2>
<p>В начале этого раздела мы кратко описали, как построить семантическое представление для <span class="example">Cyril barks</span>. Вы были бы прощены, если бы подумали, что все это было слишком просто - несомненно в построении композиционной семантики есть немного больше вопросов. А как насчет квантификаторов, например? Правильно, это важный вопрос. Например, мы хотим придать <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5a">(42а)</a> логическую форму <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5b">(42b)</a>. Как это можно сделать?</p>
<span class="target" id="ex-sem5"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(42)</td><td width="15"></td><td><span class="target" id="ex-sem5a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>A dog barks.</td></tr></table></p>
<span class="target" id="ex-sem5b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(dog(x) &amp; bark(x))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Давайте предположим, что нашей <span class="emphasis">единственной</span> операцией для построения сложных семантических представлений является функциональная аппликация (функциональное применение). Тогда наша проблема заключается в следующем: как дать семантическое представление определенной в количественном отношении (квантифицированной) именной фразе (<tt class="doctest"><span class="pre">NP</span></tt>) <span class="example">a dog</span>, чтобы она могла быть совмещена с <tt class="doctest"><span class="pre">bark</span></tt> для получения результата в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5b">(42b)</a>? В качестве первого шага давайте сделаем так, чтобы <tt class="doctest"><span class="pre">sem</span></tt> значение субъекта вело себя как функциональное выражение, а не аргумент. (Это иногда называют <a name="type_raising_index_term"></a><span class="termdef">поднятием типа</span>.) Сейчас мы ищем способ выразить <tt class="doctest"><span class="pre">?np</span></tt> так, чтобы <tt class="doctest"><span class="pre">[SEM=&lt;?np(\x.bark(x))&gt;]</span></tt> было эквивалентно <tt class="doctest"><span class="pre">[SEM=&lt;exists x.(dog(x) &amp; bark(x))&gt;]</span></tt>.
Разве это не выглядит немного похожим на проведение β-сокращения в λ-исчислении? Другими словами, мы хотим, чтобы λ выражение <span class="mathit">M</span> заменило <tt class="doctest"><span class="pre">?np</span></tt> так, чтобы применение <span class="mathit">M</span> к <tt class="doctest"><span class="pre"><span class="pysrc-string">'bark'</span></span></tt> давало <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5b">(42b)</a>.  Чтобы сделать это, мы заменим вхождение <tt class="doctest"><span class="pre"><span class="pysrc-string">'bark'</span></span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5b">(42b)</a> на предикатную переменную <tt class="doctest"><span class="pre"><span class="pysrc-string">'Р'</span></span></tt> и свяжем ее с помощью λ, как показано в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a>.</p>
<span class="target" id="ex-sem7"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(43)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))
</span></tt></td></tr></table></p>
<p>Мы использовали другой стиль переменной в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a> - то есть <tt class="doctest"><span class="pre"><span class="pysrc-string">'Р'</span></span></tt>, а не <tt class="doctest"><span class="pre"><span class="pysrc-string">'х'</span></span></tt> или <tt class="doctest"><span class="pre"><span class="pysrc-string">'у'</span></span></tt> - чтобы показать, что мы абстрагируемся над другим видом объекта - не индивидуальным объектом, а функциональным выражением типа &lt;<span class="mathit">е</span>, <span class="mathit">t</span>&gt;. Таким образом, тип <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a> в целом &lt;&lt;<span class="mathit">е</span>, <span class="mathit">t</span>&gt;, <span class="mathit">t</span>&gt;. Мы примем это как тип <tt class="doctest"><span class="pre">NP</span></tt> в целом. При этом универсально квантифицированная <tt class="doctest"><span class="pre">NP</span></tt> будет выглядеть как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7univ">(44)</a>.</p>
<span class="target" id="ex-sem7univ"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(44)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.all x.(dog(x) -&gt; P(x))</span></tt></td></tr></table></p>
<p>Мы уже почти закончили, за исключением того, что мы также хотим провести дальнейшую абстракцию плюс применение для процесса объединения семантики определителя <span class="example">a</span>, а именно <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a>, с семантикой <span class="example">dog</span>.</p>
<span class="target" id="ex-sem7det"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(45)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\Q P.exists x.(Q(x) &amp; P(x))</span></tt></td></tr></table></p>
<p>Применяя <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem8">(46)</a> в качестве функционального выражения к <tt class="doctest"><span class="pre">dog</span></tt> дает <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a>, а применение этого к <tt class="doctest"><span class="pre">abrk</span></tt> дает нам <tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))(\x.bark(x))</span></tt>. И, наконец, проведение β-сокращения дает именно то, что мы хотели получить, а именно <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem5b">(42b)</a>.</p>
</div>
<div class="section" id="transitive-verbs">
<h2>4.4 Переходные глаголы</h2>
<p>Наша следующая задача состоит в том, чтобы разобраться с предложениями с переходными глаголами, такими как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem8">(46)</a>.</p>
<span class="target" id="ex-sem8"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(46)</td><td width="15"></td><td>Angus chases a dog.
</td></tr></table></p>
<p>Выходной семантикой, которую мы хотим построить, является <tt class="doctest"><span class="pre">exists х.(dog(x) &amp; chase (angus, х))</span></tt>.
Давайте посмотрим, как мы можем использовать λ-абстракцию, чтобы получить этот результат. Существенным ограничением возможных решений является требование, чтобы семантическое представление <span class="example">a dog</span> не зависело от того, действует ли <tt class="doctest"><span class="pre">NP</span></tt> в качестве субъекта или объекта предложения. Другими словами, мы хотим получить формулу выше в качестве результата, придерживаясь <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a> в качестве семантики <tt class="doctest"><span class="pre">NP</span></tt>. Второе ограничение состоит в том, что глагольная фраза (<tt class="doctest"><span class="pre">VP</span></tt>) должна иметь однородный тип интерпретации независимо от того, состоит ли она только из непереходного глагола или из переходного глагола с объектом. Конкретно говоря, условимся, что <tt class="doctest"><span class="pre">VP</span></tt> всегда имеет тип &lt;<em>е</em>, <em>t</em>&gt;. С учетом этих ограничений, вот семантическое представление для <span class="example">chases a dog</span>, которое "выполняет трюк".</p>
<span class="target" id="ex-sem99"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(47)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.exists x.(dog(x) &amp; chase(y, x))
</span></tt></td></tr></table></p>
<p>Думайте о <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem99">(47)</a> как о свойстве быть таким <span class="math">у</span>, что для некоторой собаки <span class="math">х</span> <span class="math">у</span> гонится за <span class="math">х</span>; или более разговорно, быть <span class="math">у</span>, который гонится за собакой. Наша задача теперь заключается в проектировании семантического представление для <span class="example">chases</span>, которое можно комбинировать с <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a> для получения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem99">(47)</a>.</p>
<p>Проведем обратное β-сокращение на <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem99">(47)</a>, что дает <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem10">(48)</a>.</p>
<span class="target" id="ex-sem10"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(48)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))(\z.chase(y, z))
</span></tt></td></tr></table></p>
<p>Выражение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem10">(48)</a> может быть немного трудно читать сначала; вы должны видеть, что оно включает в себя применение квантифицированного представления <tt class="doctest"><span class="pre">NP</span></tt> из <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a> к <tt class="doctest"><span class="pre">\z.chase(y, z).</span></tt>Выражение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem10">(48)</a> эквивалентно через β-сокращение выражению <tt class="doctest"><span class="pre">x.(dog(x) &amp; chase(y, x))</span></tt>.</p>
<p>Теперь заменим функциональное выражение в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem10">(48)</a> на переменную <tt class="doctest"><span class="pre">х</span></tt> того же типа, как <tt class="doctest"><span class="pre">NP</span></tt>; то есть типа &lt;&lt;<em>е</em>, <em>t</em>&gt;, <em>t</em>&gt;.</p>
<span class="target" id="ex-sem11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(49)</td><td width="15"></td><td><tt class="doctest"><span class="pre">X(\z.chase(y, z))</span></tt></td></tr></table></p>
<p>Представление переходного глагола должно применяться к аргументу типа <tt class="doctest"><span class="pre">X</span></tt> для получения функцинального выражения того же типа, как <tt class="doctest"><span class="pre">VP</span></tt>, то есть, типа &lt;<em>е</em>, <em>t</em>&gt;. Мы можем обеспечить это за счет абстракции над обоими - переменной <tt class="doctest"><span class="pre">X</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem11">(49)</a>, а также субъектной переменной <tt class="doctest"><span class="pre">у</span></tt>. Таким образом, полное решение достигается путем придания <span class="example">chases</span> семантического представления, показанного в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem12">(50)</a>.</p>
<span class="target" id="ex-sem12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(50)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\Х у.X(\x.chase(у, х))</span></tt></td></tr></table></p>
<p>Если <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem12">(50)</a> применить к <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7">(43)</a>, то результат после β-сокращения эквивалентен <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem99">(47)</a>, а это и есть то, чего мы хотели все это время:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_expr = nltk.sem.Expression.fromstring
&gt;&gt;&gt; tvp = read_expr(r'\X x.X(\y.chase(x,y))')
&gt;&gt;&gt; np = read_expr(r'(\P.exists x.(dog(x) &amp; P(x)))')
&gt;&gt;&gt; vp = nltk.sem.ApplicationExpression(tvp, np)
&gt;&gt;&gt; print(vp)
(\X x.X(\y.chase(x,y)))(\P.exists x.(dog(x) &amp; P(x)))
&gt;&gt;&gt; print(vp.simplify())
\x.exists z2.(dog(z2) &amp; chase(x,z2))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Для того, чтобы построить семантическое представление для предложения, мы также должны включить семантику субъектной <tt class="doctest"><span class="pre">NP</span></tt>.Если последний является квантифицированным выражением, как <span class="example">каждая девушка</span>, все происходит таким же образом, как мы показали для <span class="example">a dog barks</span> ранее; субъект переводится как функциональное выражение, которое применяется к семантическому представлению <tt class="doctest"><span class="pre">VP</span></tt>.  Тем не менее, мы теперь, кажется, создали еще одну проблему для себя с собственными именами. До сих пор они обрабатывались семантически как индивидуальные константы, а они не могут быть применены в качестве функций к выражениям типа <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem99">(47)</a>. Следовательно, нам нужно придумать другое семантическое представление для них. То, что мы делаем в этом случае, является реинтерпретацией собственных имен, чтобы они тоже были функциональными выражениями, как квантифицированные <tt class="doctest"><span class="pre">NP</span></tt>. Вот необходимое λ-выражение для <span class="example">Ангус</span>.</p>
<span class="target" id="ex-sem13"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(51)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.P(angus)</span></tt></td></tr></table></p>
<p>Выражение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem13">(51)</a> обозначает характеристическую функцию, соответствующую множеству всех свойств, которые являются истинными Ангуса. Переход от индивидуальной постоянной <tt class="doctest"><span class="pre">angus</span></tt> к <tt class="doctest"><span class="pre">\Р.Р(angus)</span></tt> является еще одним примером поднятия типа, кратко упомянутого выше, который позволяет заменить имеющее логическое значение применение, такое как <tt class="doctest"><span class="pre">\x.walk(х)(angus)</span></tt> на эквивалентное функциональное применение <tt class="doctest"><span class="pre">\P.P(angus) (\x.walk(х))</span></tt>. Посредством β-сокращения оба выражения сводятся к <tt class="doctest"><span class="pre">walk(angus)</span></tt>.</p>
<!-- >>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>Грамматика <tt class="doctest"><span class="pre">simple-sem.fcfg</span></tt> содержит небольшой набор правил для разбора и перевода простых примеров вида, которые мы рассматривали. Вот несколько более сложный пример.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk import load_parser
&gt;&gt;&gt; parser = load_parser('grammars/book_grammars/simple-sem.fcfg', trace=0)
&gt;&gt;&gt; sentence = 'Angus gives a bone to every dog'
&gt;&gt;&gt; tokens = sentence.split()
&gt;&gt;&gt; for tree in parser.parse(tokens):
...     print(tree.label()['SEM'])
all z2.(dog(z2) -&gt; exists z1.(bone(z1) &amp; give(angus,z1,z2)))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>NLTK предоставляет некоторые утилиты, чтобы проще и быстрее получать и проверять семантические интерпретации. Функция <tt class="doctest"><span class="pre">interpret_sents()</span></tt> предназначена для интерпретации списка входных предложений. Он строит словарь <tt class="doctest"><span class="pre">d</span></tt>, где для каждого предложения <tt class="doctest"><span class="pre">sent</span></tt> на входе, <tt class="doctest"><span class="pre">d [sent]</span></tt> хранит список пар (<em>synrep</em>, <em>semrep</em>), состоящий из деревьев и семантических представлений для <tt class="doctest"><span class="pre">sent</span></tt>. Значение представляет собой список, так как <tt class="doctest"><span class="pre">sent</span></tt> может быть синтаксически неоднозначным; в следующем примере, однако, есть только одно дерево разбора для каждого предложения в списке.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; sents = ['Irene walks', 'Cyril bites an ankle']
&gt;&gt;&gt; grammar_file = 'grammars/book_grammars/simple-sem.fcfg'
&gt;&gt;&gt; for results in nltk.interpret_sents(sents, grammar_file):
...     for (synrep, semrep) in results:
...         print(synrep)
(S[SEM=&lt;walk(irene)&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(irene)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(irene)&gt;] Irene))
  (VP[NUM='sg', SEM=&lt;\x.walk(x)&gt;]
    (IV[NUM='sg', SEM=&lt;\x.walk(x)&gt;, TNS='pres'] walks)))
(S[SEM=&lt;exists z3.(ankle(z3) &amp; bite(cyril,z3))&gt;]
  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(cyril)&gt;]
    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(cyril)&gt;] Cyril))
  (VP[NUM='sg', SEM=&lt;\x.exists z3.(ankle(z3) &amp; bite(x,z3))&gt;]
    (TV[NUM='sg', SEM=&lt;\X x.X(\y.bite(x,y))&gt;, TNS='pres'] bites)
    (NP[NUM='sg', SEM=&lt;\Q.exists x.(ankle(x) &amp; Q(x))&gt;]
      (Det[NUM='sg', SEM=&lt;\P Q.exists x.(P(x) &amp; Q(x))&gt;] an)
      (Nom[NUM='sg', SEM=&lt;\x.ankle(x)&gt;]
        (N[NUM='sg', SEM=&lt;\x.ankle(x)&gt;] ankle)))))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Теперь мы знаем, как преобразовать английские предложения в логические формы, а раньше мы видели, как логические формы могут быть проверены как истинные или ложные в модели. Соединяя эти два отображения вместе, мы можем проверить значение истинности английских предложений в той или иной модели. Давайте возьмем модель <tt class="doctest"><span class="pre">m</span></tt> так, как она определена выше. Утилита <tt class="doctest"><span class="pre">evaluate_sents()</span></tt> напоминает <tt class="doctest"><span class="pre">interpret_sents()</span></tt> за исключением того, что мы должны передать модель и назначение переменной в качестве параметров. Результатом является тройка <em>(synrep,</em> <em>semrep</em>, <em>value</em>), где <em>synrep</em>, <em>semrep</em> такие же, как и раньше, а <em>value</em> - это значение истинности. Для простоты следующий пример обрабатывает только одно предложение.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; v = """
... bertie =&gt; b
... olive =&gt; o
... cyril =&gt; c
... boy =&gt; {b}
... girl =&gt; {o}
... dog =&gt; {c}
... walk =&gt; {o, c}
... see =&gt; {(b, o), (c, b), (o, c)}
... """
&gt;&gt;&gt; val = nltk.Valuation.fromstring(v)
&gt;&gt;&gt; g = nltk.Assignment(val.domain)
&gt;&gt;&gt; m = nltk.Model(val.domain, val)
&gt;&gt;&gt; sent = 'Cyril sees every boy'
&gt;&gt;&gt; grammar_file = 'grammars/book_grammars/simple-sem.fcfg'
&gt;&gt;&gt; results = nltk.evaluate_sents([sent], grammar_file, m, g)[0]
&gt;&gt;&gt; for (syntree, semrep, value) in results:
...     print(semrep)
...     print(value)
all z4.(boy(z4) -&gt; see(cyril,z4))
True</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX seems strange to use evaluate_sents() for a single sentence. -->
</div>
<div class="section" id="quantifier-ambiguity-revisited">
<h2>4.5 И снова неоднозначность квантификатора</h2>
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>Одним существенным ограничением описанных выше способов является то, что они не обрабатывают неоднозначность сферы действия. Наш метод перевода является ориентирован на синтаксис в том смысле, что семантическое представление тесно связано с синтаксическим анализом, и, следовательно, сфера действия квантификаторов в семантике отражает относительную сферу соответствующего <tt class="doctest"><span class="pre">NP</span></tt> s в дереве синтаксического разбора.
Следовательно, предложение, как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope1">(26)</a>, повторно приведенное ниже в (52), будет всегда переводиться как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope12a">(53а)</a>, а не <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope12b">(53b)</a>.</p>
<span class="target" id="ex-scope11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(52)</td><td width="15"></td><td>Every girl chases a dog.
</td></tr></table></p>
<span class="target" id="ex-scope12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(53)</td><td width="15"></td><td><span class="target" id="ex-scope12a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(girl(x) -&gt; exists y.(dog(y) &amp; chase(x,y)))
</span></tt></td></tr></table></p>
<span class="target" id="ex-scope12b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists y.(dog(y) &amp; all x.(girl(x) -&gt; chase(x,y)))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Существуют многочисленные подходы к работе с неоднозначностью сферы действия, и мы рассмотрим очень кратко один из самых простых. Для начала давайте кратко рассмотрим структуру формул, имеющих сферы действия. Рисунок <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-quant-ambig">4.1</a> изображает то, чем отличаются два чтения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope11">(52)</a>.</p>
<span class="target" id="fig-quant-ambig"></span><div class="figure" id="fig-quant-ambig">
<img alt="../images/quant-ambig.png" src="http://www.nltk.org/images/quant-ambig.png" style="width:623.4000000000001px;height:208.4px">
<p class="caption"><span class="caption-label">Рисунок 4.1:</span> Сферы действия квантификаторов</p>
</div>
<p>Давайте сначала рассмотрим структуру по левую руку. На вершине у нас есть квантификатор, соответствующий <span class="example">every girl</span>. Можно рассматривать φ как заменитель для всего, что находится внутри сферы квантификатора. Двигаясь вниз, мы видим, что мы можем подключить квантификатор соответствующей <span class="example">a dog</span> как конкретизацию φ. Это дает новый заменитель ψ [пси], представляющий сферу действия <span class="example">a dog</span>, к этому мы можем подключить «ядро» семантики, а именно открытое предложение, соответствующее <span class="mathit">х</span> <span class="example">chases</span> <span class="mathit">у</span>.  Структура на правой стороне идентична, за исключением того, что мы поменяли местами два квантификатора.</p>
<p>В методе, известном как <a name="cooper_storage_index_term"></a> <span class="termdef">Хранилище Купера</span>, семантическое представление больше не является выражением логики первого порядка, но вместо этого представляет собой пару, состоящую из «ядра» семантического представления плюс списка <a name="binding_operators_index_term"></a><span class="termdef">связующих операторов</span>. На данный момент думайте о связующем операторе как о чем-то идентичном семантическому представлению квантифицированной <tt class="doctest"><span class="pre">NP</span></tt>, такой как <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7univ">(44)</a> или <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-sem7det">(45)</a>. Следуя по строкам в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-quant-ambig">4.1</a>, давайте предположим, что мы построили семантическое представление предложения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope11">(52)</a> в стиле хранилища Купера, и давайте возьмем в качестве нашего ядра открытую формулу <tt class="doctest"><span class="pre">chase(х,у)</span></tt>. Для данного списка связующих операторов, соответствующих двум <tt class="doctest"><span class="pre">NP</span></tt> в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope11">(52)</a>, мы выбираем связующий оператора из списка и объединяем его с ядром.</p>
<pre class="literal-block">
\P.exists y.(dog(y) &amp; P(y))(\z2.chase(z1,z2))
</pre>
<p>Затем мы берем результат и применяем к нему следующий связующий оператор из списка.</p>
<pre class="literal-block">
\P.all x.(girl(x) -&gt; P(x))(\z1.exists x.(dog(x) &amp; chase(z1,x)))
</pre>
<p>Использовав все операторы из списка, мы получаем обычную логическую форму для данного предложения. Объединение связующих операторов с ядром таким способом называют <a name="s_retrieval_index_term"></a><span class="termdef">S-восстановлением</span>. Если мы будем достаточно аккуратны, чтобы допустить все возможные порядки связывания операторов (например, путем использования всех перестановок списка, cf <a class="reference external" href="http://www.nltk.org/book/ch04.html#sec-doing-more-with-functions">4.5</a>), то мы сможем сгенерировать все возможные упорядочения сфер действия квантификаторов.</p>
<p>Следующий вопрос, который необходимо решить, как мы строим представление ядро + хранилище композиционно. Как и прежде, каждое фразовое и лексическое правило в грамматике будет иметь свойство <tt class="doctest"><span class="pre">sem</span></tt>, но теперь будут еще встроенные свойства <tt class="doctest"><span class="pre">core</span></tt> и <tt class="doctest"><span class="pre">store</span></tt>. Для иллюстрации механизма давайте рассмотрим более простой пример, а именно <span class="example">Cyril smiles</span>. Вот лексическое правило для глагола <span class="example">smiles</span> (взятое из грамматики <tt class="doctest"><span class="pre">storage.fcfg</span></tt>), которое выглядит довольно безобидно.</p>
<pre class="literal-block">
IV[SEM=[core=&lt;\x.smile(x)&gt;, store=(/)]] -&gt; 'smiles'
</pre>
<p>Правило для собственного имени <span class="example">Cyril</span> является более сложным.</p>
<pre class="literal-block">
IV[SEM=[core=&lt;\x.smile(x)&gt;, store=(/)]] -&gt; 'smiles'
</pre>
<p>Предикат <tt class="doctest"><span class="pre">bo</span></tt> имеет два подраздела: стандартное представление имени собственного (с поднятым типом) и выражение <tt class="doctest"><span class="pre">@x</span></tt>, которое называется <a name="address_index_term"></a> <span class="termdef">адресом</span> связующего оператора. (Мы объясним необходимость адресной переменной в ближайшее время.)Пара символов <tt class="doctest"><span class="pre">@x</span></tt> обозначает метапеременную, то есть переменную, которая пробегает по индивидуальным переменным логики и, как вы увидите, она также предоставляет значение <tt class="doctest"><span class="pre">core</span></tt>.
Правило для <tt class="doctest"><span class="pre">VP</span></tt> просто поднимает семантику <tt class="doctest"><span class="pre">IV</span></tt>, а также интересная работа выполняется правилом <tt class="doctest"><span class="pre">S</span></tt>.</p>
<pre class="literal-block">
VP[SEM=?s] -&gt; IV[SEM=?s]

S[SEM=[core=&lt;?vp(?np)&gt;, store=(?b1+?b2)]] -&gt;
   NP[SEM=[core=?np, store=?b1]] VP[SEM=[core=?vp, store=?b2]]
</pre>
<p>Значение <tt class="doctest"><span class="pre">core</span></tt> в узле <tt class="doctest"><span class="pre">S</span></tt> является результатом применения значения <tt class="doctest"><span class="pre">core</span></tt> <tt class="doctest"><span class="pre">VP</span></tt>, а именно <tt class="doctest"><span class="pre">\x.smile(х)</span></tt> к <tt class="doctest"><span class="pre">NP</span></tt> значению субъекта. Последнее будет не <tt class="doctest"><span class="pre">@x</span></tt>, а конкретизация <tt class="doctest"><span class="pre">@x</span></tt>, скажем, <tt class="doctest"><span class="pre">z3</span></tt>. После β-сокращения <tt class="doctest"><span class="pre">&lt;?vp(?np)&gt;</span></tt> будет унифицировано с <tt class="doctest"><span class="pre">&lt;smile(z3)&gt;</span></tt>. Теперь, когда <tt class="doctest"><span class="pre">@x</span></tt> получает конкретное значение как часть процесса синтаксического анализа, она будет получать конкретные значения единообразно. В частности, вхождение <tt class="doctest"><span class="pre">@x</span></tt> в значение <tt class="doctest"><span class="pre">store</span></tt> <tt class="doctest"><span class="pre">NP</span></tt> субъекта также будет отображаться как <tt class="doctest"><span class="pre">z3</span></tt>, давая элемент <tt class="doctest"><span class="pre">bo(\Р.Р(cyril), z3)</span></tt>. Эти шаги можно увидеть в следующем дереве разбора.</p>
<pre class="literal-block">
(S[SEM=[core=&lt;smile(z3)&gt;, store=(bo(\P.P(cyril),z3))]]
  (NP[SEM=[core=&lt;z3&gt;, store=(bo(\P.P(cyril),z3))]] Cyril)
  (VP[SEM=[core=&lt;\x.smile(x)&gt;, store=()]]
    (IV[SEM=[core=&lt;\x.smile(x)&gt;, store=()]] smiles)))
</pre>
<p>Давайте вернемся к нашему более сложному примеру, <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-scope11">(52)</a>, и посмотрим, что представляет собой значение <tt class="doctest"><span class="pre">sem</span></tt> в стиле хранилища после разбора с помощью грамматики <tt class="doctest"><span class="pre">storage.fcfg</span></tt>.</p>
<pre class="literal-block">
core  = &lt;chase(z1,z2)&gt;
store = (bo(\P.all x.(girl(x) -&gt; P(x)),z1), bo(\P.exists x.(dog(x) &amp; P(x)),z2))
</pre>
<!-- XXX next sentence says "should be clearer" having just displayed the
most complex structure seen so far.  It would be better to explain the
structure, then follow up by saying it should be clearer.  (But perhaps
such meta-comments serve only to alienate many readers for whom its not
going to be clearer?) -->
<p>Теперь должно быть яснее, почему адресные переменные являются важной частью связующего оператора. Вспомните, что во время S-восстановления мы будем брать связующие операторы из списка <tt class="doctest"><span class="pre">store</span></tt> и применять их последовательно к ядру. Предположим, что мы начинаем с оператора <tt class="doctest"><span class="pre">bo(\P.all x.(girl(x) -&gt; P(x)),z1)</span></tt>, который мы хотим объединить с <tt class="doctest"><span class="pre">chase(z1, z2)</span></tt>. Квантификаторной частью связывающего оператора является <tt class="doctest"><span class="pre">\P.all x.(girl(x) -&gt; P(x))</span></tt>, и, чтобы совместить ее с <tt class="doctest"><span class="pre">chase(z1, z2)</span></tt>, последняя должна быть сначала превращена в λ абстракцию. Как мы узнаем, над какой переменной необходима абстракция? Это то, что адрес <tt class="doctest"><span class="pre">z1</span></tt> говорит нам; то есть, что <span class="example">every girl</span> выполняет роль преследователя, а не преследуемого.</p>
<p>Модуль <tt class="doctest"><span class="pre">nltk.sem.cooper_storage</span></tt> имеет дело с задачей превращения  семантических представлений в стиле хранилища в стандартные логические формы. Сначала мы создаем экземпляр <tt class="doctest"><span class="pre">CooperStore</span></tt> и проверяем его <tt class="doctest"><span class="pre">store</span></tt> и <tt class="doctest"><span class="pre">core</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk.sem import cooper_storage as cs
&gt;&gt;&gt; sentence = 'every girl chases a dog'
&gt;&gt;&gt; trees = cs.parse_with_bindops(sentence, grammar='grammars/book_grammars/storage.fcfg')
&gt;&gt;&gt; semrep = trees[0].label()['SEM']
&gt;&gt;&gt; cs_semrep = cs.CooperStore(semrep)
&gt;&gt;&gt; print(cs_semrep.core)
chase(z2,z4)
&gt;&gt;&gt; for bo in cs_semrep.store:
...     print(bo)
bo(\P.all x.(girl(x) -&gt; P(x)),z2)
bo(\P.exists x.(dog(x) &amp; P(x)),z4)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Наконец, мы вызываем <tt class="doctest"><span class="pre">s_retrieve()</span></tt> и проверяем чтения.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; cs_semrep.s_retrieve(trace=True)
Permutation 1
   (\P.all x.(girl(x) -&gt; P(x)))(\z2.chase(z2,z4))
   (\P.exists x.(dog(x) &amp; P(x)))(\z4.all x.(girl(x) -&gt; chase(x,z4)))
Permutation 2
   (\P.exists x.(dog(x) &amp; P(x)))(\z4.chase(z2,z4))
   (\P.all x.(girl(x) -&gt; P(x)))(\z2.exists x.(dog(x) &amp; chase(z2,x)))</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; for reading in cs_semrep.readings:
...     print(reading)
exists x.(dog(x) &amp; all z3.(girl(z3) -&gt; chase(z3,x)))
all x.(girl(x) -&gt; exists z4.(dog(z4) &amp; chase(x,z4)))</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="discourse-semantics">
<h1>5 Семантика дискурса</h1>
<p><a name="discourse_index_term"></a><span class="termdef">Дискурс</span> представляет собой последовательность предложений. Очень часто интерпретация предложения в дискурсе зависит от того, что ему предшествовало. Очевидным примером этого являются анафорические местоимения, такие как <span class="example">он</span>, <span class="example">она</span> и <span class="example">оно</span>. В данном дискурсе "<span class="example">Angus used to have a dog. But he recently disappeared.</span>" вы, вероятно, будете интерпретировать <span class="example">he</span> как относящееся к собаке Ангуса. Однако в дискурсе "<span class="example"> Angus used to have a dog.He took him for walks in New Town.</span>" вы скорее интерпретируете <span class="example">he</span> как относящееся к самому Ангусу.</p>
<div class="section" id="discourse-representation-theory">
<h2>5.1 Теория представления дискурса</h2>
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>Стандартный подход к квантификации в логике первого порядка ограничен отдельными предложениями. Тем не менее, кажется, есть примеры, когда сфера действия квантификатора может простираться на два и более предложений. Мы видели один выше, а вот второй пример с переводом.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(54)</td><td width="15"></td><td><span class="target" id="ex-drs0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Angus owns a dog. It bit Irene.
</td></tr></table></p>
<span class="target" id="ex-drs1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>∃x.(dog(x) ∧ own(Angus, x) ∧ bite(x, Irene))
</td></tr></table></p>
</td></tr></table></p>
<!-- XXX reworked the respectively sentence in the following paragraph
so that the discussion is easier to follow; needs to be checked. -->
<p>То есть, <tt class="doctest"><span class="pre">NP</span></tt> <span class="example">a dog</span> действует как квантификатор, который связывает <span class="example">it</span> во втором предложении.  Теория представления дискурса (ТПД) (Discourse Representation Theory (DRT)) была разработана с целью предоставления средств для обработки этого и других семантических явлений, которые, как представляется, являются характерными для дискурса.
<a name="discourse_representation_structure_index_term"></a><span class="termdef">Структура представления дискурса</span> (СПД) (discourse representation structure (DRS)) представляет смысл дискурса в виде списка референтов дискурса и списка условий.  <a name="discourse_referents_index_term"></a><span class="termdef">Референтами дискурса</span> являются вещи, обсуждаемые в дискурсе, они соответствуют индивидуальным переменным логики первого порядка.  <a name="drs_conditions_index_term"></a><span class="termdef">Условия DRS</span> применяются к этим референтам дискурса и соответствуют атомарными открытым формулам логики первого порядка.
<a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a> показывает, как DRS для первого предложения <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-drs0">(54а)</a> дополняется, чтобы получить DRS для обоих предложений.</p>
<span class="target" id="fig-drs1"></span><div class="figure" id="fig-drs1">
<img alt="../images/drs1.png" src="http://www.nltk.org/images/drs1.png" style="width:471.29999999999995px;height:287.55px">
<p class="caption"><span class="caption-label">Рисунок 5.1:</span> Построение DRS; DRS на левой стороне представляет собой результат обработки первого предложения в речи, тогда как DRS на правой стороне показывает эффект обработки и интеграции содержания второго предложения.</p>
</div>
<p>Когда второе предложение <a class="reference internal" href="http://www.nltk.org/book/ch10.html#ex-drs0">(54а)</a> обрабатывается, оно интерпретируется в контексте того, что уже присутствует в левой части <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a>. Местоимение <span class="example">it</span> вызывает добавление нового референта дискурса, скажем <span class="mathit">u</span>, и мы должны найти <a name="anaphoric_antecedent_index_term"></a><span class="termdef">анафорического предшественника</span> для него - то есть, мы хотим выяснить, к чему <span class="example">it</span> относится. В DRT задача нахождения антецедента (предшественника) для анафорического местоимением включает его привязку к референту дискурса уже имеющегося внутри текущей DRS, и <span class="mathit">y</span> - это очевидный выбор. (Мы скажем больше о разрешении анафоры в ближайшее время.) Этот этап обработки приводит к появлению нового условия <span class="mathit">u</span> = <span class="mathit">y</span>.
Оставшееся содержание во втором предложении объединяется с содержанием первого, это показано на правой стороне <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a>.</p>
<p><a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a> показывает, как DRS может представлять больше, чем просто одно предложение. В этом случае это дискурс, состоящий из двух предложений, но в принципе одна DRS может соответствовать интерпретации целого текста. Мы можем исследовать условия истинности правых DRS в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a>. Неформально, она истинна в некоторых ситуациях <span class="mathit">s</span>, если есть объекты <strong>a</strong>, <strong>c</strong> и <strong>i</strong> в <span class="mathit">s</span> соответствующие референтам дискурса в DRS так, что все условия в <span class="mathit">s</span> истинны; то есть<strong>a</strong> имеет имя <span class="example">Angus</span>, <strong>c</strong> является собакой, <strong>a</strong> владеет <strong>c</strong>, <strong>i</strong> зовется <span class="example">Irene</span> и <strong>c</strong> укусил <strong>i</strong>.</p>
<p>Для того, чтобы обрабатывать DRS вычислительно, нам нужно преобразовать их в линейный формат. Вот пример, в котором DRS является парой, состоящая из списка референтов дискурса и перечня условий DRS:</p>
<pre class="literal-block">
([x, y], [angus(x), dog(y), own(x,y)])
</pre>
<p>Самый простой способ построить <tt class="doctest"><span class="pre">DRS</span></tt> объект в NLTK - путем разбора строкового представления <a class="reference internal" href="http://www.nltk.org/book/ch10.html#parse-drs"><span id="ref-parse-drs"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; read_dexpr = nltk.sem.DrtExpression.fromstring
&gt;&gt;&gt; drs1 = read_dexpr('([x, y], [angus(x), dog(y), own(x, y)])') 
&gt;&gt;&gt; print(drs1)
([x,y],[angus(x), dog(y), own(x,y)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX reinstated the split example since otherwise a bunch of subsequent doctests -->
<!-- fail. -->
<p>Мы можем использовать метод <tt class="doctest"><span class="pre">draw()</span></tt> <a class="reference internal" href="http://www.nltk.org/book/ch10.html#draw-drs"><span id="ref-draw-drs"><img class="callout" alt="[1]" src="http://www.nltk.org/book/callouts/callout1.gif"></span></a>, чтобы визуализировать результат, как показано на <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs-screenshot">5.2</a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> drs1.draw() <a name="draw-drs"></a><a href="http://www.nltk.org/book/ch10.html#ref-draw-drs"><img src="http://www.nltk.org/book/callouts/callout1.gif" alt="[1]" class="callout"></a></pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-drs-screenshot"></span><div class="figure" id="fig-drs-screenshot">
<img alt="../images/drs_screenshot0.png" src="http://www.nltk.org/images/drs_screenshot0.png" style="width:190.8px;height:198.0px">
<p class="caption"><span class="caption-label">Рисунок 5.2:</span> DRS Снимок экрана</p>
</div>
<p>Когда мы обсуждали условия истинности DRS в <a class="reference internal" href="http://www.nltk.org/book/ch10.html#fig-drs1">5.1</a>, мы предполагали, что самые верхние референты дискурса интерпретируются как экзистенциальные квантификаторы, тогда как условия интерпретируются так, как будто они объединены. На самом деле, каждый DRS можно перевести в формулу логики первого порядка, и метод <tt class="doctest"><span class="pre">fol()</span></tt> реализует эту операцию.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; print(drs1.fol())
exists x y.(angus(x) &amp; dog(y) &amp; own(x,y))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>В дополнение к функциональности доступной для выражений логики первого порядка, DRT <tt class="doctest"><span class="pre">ExpressionS</span></tt> имеет оператор DRS-конкатенации, представленный как символ <tt class="doctest"><span class="pre">+</span></tt>.  Конкатенация двух DRS представляет собой единый DRS, содержащий слитые референты дискурсов и условия обоих аргументов.  DRS-конкатенация автоматически выполняет α-преобразования связующих переменных, чтобы избежать столкновений имен.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; drs2 = read_dexpr('([x], [walk(x)]) + ([y], [run(y)])')
&gt;&gt;&gt; print(drs2)
(([x],[walk(x)]) + ([y],[run(y)]))
&gt;&gt;&gt; print(drs2.simplify())
([x,y],[walk(x), run(y)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Тогда как все виденные до сих пор условия были атомарными, можно встроить одну DRS внутрь другой, так обрабатывается универсальная квантификация. В <tt class="doctest"><span class="pre">drs3</span></tt> нет референтов дискурса верхнего уровня и единственное условие состоит из двух суб-DRS, соединенных импликацией. Мы снова можем использовать <tt class="doctest"><span class="pre">fol()</span></tt>, чтобы получить условия истинности.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; drs3 = read_dexpr('([], [(([x], [dog(x)]) -&gt; ([y],[ankle(y), bite(x, y)]))])')
&gt;&gt;&gt; print(drs3.fol())
all x.(dog(x) -&gt; exists y.(ankle(y) &amp; bite(x,y)))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Мы указывали ранее, что DRT разработана, чтобы позволить разрешать анафорические местоимения путем связывания их с существующими референтами дискурса. DRT устанавливает ограничения на референты дискурса, которые "доступны" в качестве возможных предшественников, но она не предназначена для объяснения того, как конкретный предшественник выбирается из набора кандидатов.
Модуль <tt class="doctest"><span class="pre">nltk.sem.drt_resolve_anaphora</span></tt> принимает аналогичную консервативную стратегию: если DRS содержит условие вида <tt class="doctest"><span class="pre">PRO(х)</span></tt>, метод <tt class="doctest"><span class="pre">resolve_anaphora()</span></tt> заменяет его условием вида <tt class="doctest"><span class="pre">х = [...]</span></tt>, где <tt class="doctest"><span class="pre">[...]</span></tt> представляет собой список возможных предшественников.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; drs4 = read_dexpr('([x, y], [angus(x), dog(y), own(x, y)])')
&gt;&gt;&gt; drs5 = read_dexpr('([u, z], [PRO(u), irene(z), bite(u, z)])')
&gt;&gt;&gt; drs6 = drs4 + drs5
&gt;&gt;&gt; print(drs6.simplify())
([u,x,y,z],[angus(x), dog(y), own(x,y), PRO(u), irene(z), bite(u,z)])
&gt;&gt;&gt; print(drs6.simplify().resolve_anaphora())
([u,x,y,z],[angus(x), dog(y), own(x,y), (u = [x,y,z]), irene(z), bite(u,z)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Так как алгоритм для разрешения анафоры был выделен в свой собственный модуль, это позволяет применять альтернативные процедуры, которые пытаются сделать более разумные предположения о правильном антецеденте.</p>
<p>Наша обработка DRS полностью совместима с существующим механизмом для обработки λ абстракции, и, следовательно, мы просто строим композиционные семантические представления на основе DRT, а не логики первого порядка. Этот способ показан в следующем правиле для неопределенных (которое является частью грамматики <tt class="doctest"><span class="pre">drt.fcfg</span></tt>). Для удобства сравнения мы добавили параллельное правило для неопределенных из <tt class="doctest"><span class="pre">simple-sem.fcfg</span></tt>.</p>
<pre class="literal-block">
Det[num=sg,SEM=&lt;\P Q.(([x],[]) + P(x) + Q(x))&gt;] -&gt; 'a'
Det[num=sg,SEM=&lt;\P Q. exists x.(P(x) &amp; Q(x))&gt;] -&gt; 'a'
</pre>
<p>Чтобы получить лучшее представление о том, как работает правило DRT, посмотрите на это поддерево для <tt class="doctest"><span class="pre">NP</span></tt> <span class="example">a dog</span>.</p>
<pre class="literal-block">
(NP[num='sg', SEM=&lt;\Q.(([x],[dog(x)]) + Q(x))&gt;]
  (Det[num='sg', SEM=&lt;\P Q.((([x],[]) + P(x)) + Q(x))&gt;] a)
  (Nom[num='sg', SEM=&lt;\x.([],[dog(x)])&gt;]
    (N[num='sg', SEM=&lt;\x.([],[dog(x)])&gt;] dog)))))
</pre>
<p>λ абстракция неопределенного применяется в качестве функционального выражения к <tt class="doctest"><span class="pre">\х.([],[dog(х)])</span></tt>, что приводит к <tt class="doctest"><span class="pre">\Q.(([x],[]) + ([],[dog(x)]) + Q(x))</span></tt>; после упрощения мы получаем <tt class="doctest"><span class="pre">\Q.(([x],[dog(x)]) + Q(x))</span></tt> в качестве представления для <tt class="doctest"><span class="pre">NP</span></tt> в целом.</p>
<p>Для того, чтобы разобрать с помощью грамматики <tt class="doctest"><span class="pre">drt.fcfg</span></tt>, мы указываем в вызове <tt class="doctest"><span class="pre">load_parser()</span></tt>, что <tt class="doctest"><span class="pre">SEM</span></tt> значения в структурах свойств должны быть разобраны с помощью <tt class="doctest"><span class="pre">DrtParser</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; from nltk import load_parser
&gt;&gt;&gt; parser = load_parser('grammars/book_grammars/drt.fcfg', logic_parser=nltk.sem.drt.DrtParser())
&gt;&gt;&gt; trees = list(parser.parse('Angus owns a dog'.split()))
&gt;&gt;&gt; print(trees[0].label()['SEM'].simplify())
([x,z2],[Angus(x), dog(z2), own(x,z2)])</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="discourse-processing">
<h2>5.2 Обработка дискурса</h2>
<p>Когда мы интерпретируем предложение, мы используем богатый контекст для интерпретации, частично определенный предыдущим контексте и частично нашими фоновыми допущениями. DRT дает теорию о том, как смысл предложения интегрируется в представление предшествующего дискурса, но две вещи явно отсутствовали в подходе к обработке, который мы только что обсуждали. Во-первых, не было ни одной попытки включить какой-либо вид логического вывода; и во-вторых, мы обработали только отдельные предложения. Эти пробелы заполняются модулем <tt class="doctest"><span class="pre">nltk.inference.discourse</span></tt>.</p>
<!-- XXX The s_1-r_i ... s_n-r_j suggests the possibility of two sentences
sharing the same reading.  Should it be s_1-r_{1,i} ... s_n-r_{n,j} ? -->
<p>В то время как дискурс представляет собой последовательность предложений <span class="mathit">s</span><sub>1,</sub> ... <span class="mathit">s</span><sub>n</sub>, <span class="example">нить дискурса</span> представляет собой последовательность <span class="mathit">s</span><sub>1</sub><span class="mathit">-г</span><sub>i</sub>, ... <span class="mathit">s</span><sub>n</sub><span class="mathit">-r</span><sub>j</sub> чтений, по одному для каждого предложения в дискурсе.  Модуль обрабатывает предложения по возрастающей, отслеживая все возможные нити при наличии неоднозначности. Для простоты следующий пример игнорирует неоднозначность области действия.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt = nltk.DiscourseTester(['A student dances', 'Every student is a person'])
&gt;&gt;&gt; dt.readings()

s0 readings:

s0-r0: exists x.(student(x) &amp; dance(x))

s1 readings:

s1-r0: all x.(student(x) -&gt; person(x))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Когда новое предложение добавляется к текущему дискурсу, установка параметра <tt class="doctest"><span class="pre">consistchk=True</span></tt> вызывает проверку совместимости путем вызова программы проверки модели для каждой нити, т.е. последовательности допустимых чтений. В этом случае пользователь имеет возможность отбросить предложение.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt.add_sentence('No person dances', consistchk=True)
Inconsistent discourse: d0 ['s0-r0', 's1-r0', 's2-r0']:
    s0-r0: exists x.(student(x) &amp; dance(x))
    s1-r0: all x.(student(x) -&gt; person(x))
    s2-r0: -exists x.(person(x) &amp; dance(x))</pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt.retract_sentence('No person dances', verbose=True)
Current sentences are
s0: A student dances
s1: Every student is a person</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Аналогичным образом мы используем <tt class="doctest"><span class="pre">informchk=True</span></tt>, чтобы проверить, что новое предложение φ является ли информативными относительно текущего дискурса. Программа проверки теорем использует существующие предложения в ните в качестве посылок и пытается доказать φ; последнее является информативным, если ни одного такого доказательства не может быть найдено.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt.add_sentence('A person dances', informchk=True)
Sentence 'A person dances' under reading 'exists x.(person(x) &amp; dance(x))':
Not informative relative to thread 'd0'</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Кроме того, можно передать дополнительный набор посылок в качестве фоновых знаний и использовать их, чтобы отфильтровать несовместимые чтения; посмотрите HOWTO по дискурсу на <tt class="doctest"><span class="pre">http://nltk.org/howto</span></tt> для получения более подробной информации.</p>
<p>Модуль <tt class="doctest"><span class="pre">discourse</span></tt> может разрешать смысловую неоднозначность и отфильтровывать чтения, которые являются недопустимыми.
Следующий пример вызывает как Glue Semantics, так и DRT. Так как модуль Glue Semantics настроен на использование анализатора широкого охвата Malt, вход <span class="example">(Every dog chases a boy. He runs</span>.) должен быть помечен и токенизирован.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
 	
&gt;&gt;&gt; from nltk.tag import RegexpTagger
&gt;&gt;&gt; tagger = RegexpTagger(
...     [('^(chases|runs)$', 'VB'),
...      ('^(a)$', 'ex_quant'),
...      ('^(every)$', 'univ_quant'),
...      ('^(dog|boy)$', 'NN'),
...      ('^(He)$', 'PRP')
... ])
&gt;&gt;&gt; rc = nltk.DrtGlueReadingCommand(depparser=nltk.MaltParser(tagger=tagger))
&gt;&gt;&gt; dt = nltk.DiscourseTester(['Every dog chases a boy', 'He runs'], rc)
&gt;&gt;&gt; dt.readings()

s0 readings:

s0-r0: ([],[(([x],[dog(x)]) -&gt; ([z3],[boy(z3), chases(x,z3)]))])
s0-r1: ([z4],[boy(z4), (([x],[dog(x)]) -&gt; ([],[chases(x,z4)]))])

s1 readings:

s1-r0: ([x],[PRO(x), runs(x)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Первое предложение дискурса имеет два возможных чтения в зависимости от сферы действия квантификатора. Единственное чтение второго предложения представляет местоимение <span class="example">He</span> через условие <cite>PRO(х)`</cite>. Теперь давайте посмотрим на нити дискурса, которые являются результатом:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt.readings(show_thread_readings=True)
d0: ['s0-r0', 's1-r0'] : INVALID: AnaphoraResolutionException
d1: ['s0-r1', 's1-r0'] : ([z6,z10],[boy(z6), (([x],[dog(x)]) -&gt;
([],[chases(x,z6)])), (z10 = z6), runs(z10)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Когда мы исследуем нити <tt class="doctest"><span class="pre">d0</span></tt> и <tt class="doctest"><span class="pre">d1</span></tt>, мы видим, что чтение <tt class="doctest"><span class="pre">s0-r0</span></tt>, где <span class="example">every dog</span> выходит за пределы <tt class="doctest"><span class="pre">a boy</span></tt>, считается неприемлемым, поскольку местоимение во втором предложении не может быть разрешено.  В отличие от этого в нити <tt class="doctest"><span class="pre">d1</span></tt> местоимение (переобозначенное в <tt class="doctest"><span class="pre">z24)</span></tt> был связано <em>через</em> уравнение <tt class="doctest"><span class="pre">(z24 = z20)</span></tt>.</p>
<p>Недопустимые чтения могут быть отфильтрованы с помощью параметра <tt class="doctest"><span class="pre">filter=True</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
&gt;&gt;&gt; dt.readings(show_thread_readings=True, filter=True)
d1: ['s0-r1', 's1-r0'] : ([z12,z15],[boy(z12), (([x],[dog(x)]) -&gt;
([],[chases(x,z12)])), (z17 = z12), runs(z15)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Хотя этот маленький дискурс крайне ограничен он должен дать вам почувствовать, какого рода проблемы семантической обработки возникают, когда мы выходим за рамки отдельных предложений, а также какие методы могут быть применены для их решения.</p>
</div>
</div>
<div class="section" id="summary">
<h1>6 Резюме</h1>
<ul class="simple">
<li>Логика первого порядка является подходящим языком для представления смысла естественного языка в вычислительной среде, поскольку эта логика является достаточно гибкой, чтобы представить множество полезных аспектов естественного осмысления, и существуют эффективные программы доказательства теорем для рассуждений с использованием логики первого порядка. (Равно как существует множество явлений в семантике естественного языка, которые, как полагают, требуют более мощных логических механизмов.)</li>
<li>Равно как мы можем переводить предложения естественного языка на логику первого порядка, мы можем устанавливать условия истинности этих предложений путем изучения моделей формул первого порядка.</li>
<li>Для того чтобы построить представления смысла композиционно, мы дополняем логику первого порядка λ исчислением.</li>
<li>β-сокращение в λ исчислении соответствует семантически применению функции к аргументу. Синтаксически оно включает в себя замену переменной, связанной с помощью λ в функциональном выражении, на выражение, которое предоставляет аргумент в применении функции.</li>
<li>Одним из ключевых элементов создания модели заключается в построении оценки, которая назначает интерпретации нелогическим константам. Они интерпретируются либо как <em>n</em>-мерные предикаты, либо как индивидуальные константы.</li>
<li>Открытое выражение представляет собой выражение, содержащее одну или несколько свободных переменных. Открытые выражения получают интерпретацию, только когда их свободные переменные получают значения из назначения переменных.</li>
<li>Квантификаторы интерпретируются при создании для формулы φ<span class="mathit">[х]</span> открытой в переменной <span class="mathit">х</span>, множества индивидуальных объектов, которые делают φ<span class="mathit">[х]</span> истинной, когда присвоение <em>g</em> присваивает их в качестве значения <span class="mathit">х</span>. Квантификатор затем накладывает ограничения на это множество.</li>
<li>Выражение является замкнутым, если оно не имеет свободных переменных; то есть все переменные связаны. Замкнутое предложение является истинным или ложным относительно всех присвоений переменных.</li>
<li>Если две формулы отличаются только буквой переменной, связанной связующим оператором (т.е. λ или квантификатором), они называются α-эквивалентами. Результат переобозначения связанной переменной в формуле называется α-преобразованием.</li>
<li>Для данной формулы с двумя вложенными квантификаторами <em>Q</em><sub>1</sub> и <em>Q</em><sub>2</sub> самый внешний квантификатор <em>Q</em><sub>1</sub>, говорят, имеет широкую сферу (или сферу, включающую <em>Q</em><sub>2</sub>). Английские предложения часто неоднозначны относительно сферы действия квантификаторов, которые они содержат.</li>
<li>Английские предложения могут быть ассоциированы с семантическим представлением путем использования <tt class="doctest"><span class="pre">sem</span></tt> в качестве свойства в грамматике на основе свойств. Значение <tt class="doctest"><span class="pre">sem</span></tt> сложных выражений, как правило, включает в себя функциональное применение значений <tt class="doctest"><span class="pre">sem</span></tt> компонентных выражений.</li>
</ul>
</div>
<div class="section" id="further-reading">
<h1>7 Дополнительные материалы</h1>
<p>Обратитесь к <tt class="doctest"><span class="pre">http://nltk.org/</span></tt> для получения дополнительных материалов по этой главе, а также о том, как установить программу доказательства теорем Prover9 и построитель моделей Mace4. Общая информация по этим двум инструментам логического вывода дано в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#mccune" id="id5">(McCune, 2008)</a>.</p>
<p>Для получения большего количества примеров семантического анализа с помощью NLTK, пожалуйста, обратитесь к HOWTO по семантике и логике на <tt class="doctest"><span class="pre">http://nltk.org/howto</span></tt>.  Обратите внимание, что существуют реализации двух других подходов к неоднозначности сферы действия, а именно: <a name="hole_semantics_index_term"></a><span class="termdef">Hole семантика</span>, описанная в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#blackburn2005rin" id="id6">(Blackburn &amp; Bos, 2005)</a> и <a name="glue_semantics_index_term"></a><span class="termdef">Glue семантика</span>, описанная в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#dalrymple:1999:rrb" id="id7">(Dalrymple, 1999)</a>.</p>
<p>Есть много явлений в семантике естественного языка, которые не были затронуты в этой главе, в первую очередь:</p>
<ol class="lowerroman simple">
<li>события, время и аспект;</li>
<li>семантические роли;</li>
<li>обобщенные квантификаторы, такие как <span class="example">most</span>;</li>
<li>интенсиональные конструкции, включающие, например, такие глаголы, как <span class="example">may</span> и <span class="example">believe</span>.</li>
</ol>
<p>В то время как с (1) и (2) можно работать с помощью логики первого порядка, (3) и (4) требуют других логик.
Эти вопросы рассматриваются во многих работах, ссылки на которые приведены ниже.</p>
<p>Подробный обзор методов и результатов в построении интерфейсов на естественном языке к базам данных можно найти в <a class="reference external" href="http://www.nltk.org/book/bibliography.html#androutsopoulos1995nli" id="id8">(Androutsopoulos, Ritchie, &amp; Thanisch, 1995)</a>.</p>
<p>Любая вводная книга по современной логике представит логику высказываний и логику первого порядка. <a class="reference external" href="http://www.nltk.org/book/bibliography.html#hodges1977l" id="id9">(Hodges, 1977)</a> настоятельно рекомендуется в качестве развлекательного и проницательного текста со большим количеством проницательных иллюстраций из естественного языка.</p>
<p>Если вас интересует двухтомный учебник с широким охватом по логике, который также представляет современный материал по формальной семантике естественного языка, включая грамматику Монтегю и интенсиональную логику, ознакомьтесь с <a class="reference external" href="http://www.nltk.org/book/bibliography.html#gamut1991il" id="id10">(Gamut, 1991)</a> и <a class="reference external" href="http://www.nltk.org/book/bibliography.html#gamut1991illg" id="id11">(Gamut, 1991)</a>. <a class="reference external" href="http://www.nltk.org/book/bibliography.html#kampreyle1993" id="id12">(Kamp &amp; Reyle, 1993)</a> дает наиболее полный отчет по теории представления дискурса и охватывает большой и интересный фрагмент естественного языка, в том числе время, аспект (вид) и модальность. Другим всесторонним исследованием семантики многих естественно-языковых конструкций является <a class="reference external" href="http://www.nltk.org/book/bibliography.html#carpenter1997tls" id="id13">(Carpenter, 1997)</a>.</p>
<p>Есть множество работ, которые представляют логическую семантику в рамках лингвистической теории. <a class="reference external" href="http://www.nltk.org/book/bibliography.html#chierchia1990mg" id="id14">(Chierchia &amp; McConnell-Ginet, 1990)</a> является относительным агностиком по поводу синтаксиса, в то время как <a class="reference external" href="http://www.nltk.org/book/bibliography.html#heim1998sgg" id="id15">(Heim &amp; Kratzer, 1998)</a> и <a class="reference external" href="http://www.nltk.org/book/bibliography.html#larson1995km" id="id16">(Larson &amp; Segal, 1995)</a> оба более явно ориентированы на интеграцию условно-истинной семантики в рамки схемы Хомского.</p>
<p><a class="reference external" href="http://www.nltk.org/book/bibliography.html#blackburn2005rin" id="id17">(Blackburn &amp; Bos, 2005)</a> является первым учебником, посвященным вычислительной семантике, и обеспечивает превосходное введение в эту область. Он расширяет представление по многим темам, описанным в этой главе, в том числе недоспецификация неоднозначности сферы действия квантификаторов, заключения первого порядка и обработка дискурса.</p>
<p>Для того, чтобы получить представление о более продвинутых современных подходах к семантике, в том числе о методах работы с временем и обобщенными квантификаторами, попробуйте обратиться к <a class="reference external" href="http://www.nltk.org/book/bibliography.html#lappin1996hcs" id="id18">(Lappin, 1996)</a> или <a class="reference external" href="http://www.nltk.org/book/bibliography.html#vanbenthem1997hll" id="id19">(Benthem &amp; Meulen, 1997)</a>.</p>
</div>
<div class="section" id="exercises">
<h1>8 Упражнения</h1>
<ol class="arabic">
<li><p class="first">☼ Перевести следующие предложения на логике высказываний и убедитесь , что они могут быть обработаны с помощью <tt class="doctest"><span class="pre">Expression.fromstring ().</span></tt>
Предоставить ключ, который показывает, как пропозициональные переменные в переводе соответствуют выражения английского языка.</p>
<ol class="loweralpha simple">
<li>Если Энгус поет, это не тот случай, что Берти дуется.</li>
<li>Кирилл бежит и лает.</li>
<li>Это будет снег, если не идет дождь.</li>
<li>Это не тот случай, когда Ирен будет счастлив, если оливковое или Тофу приходит.</li>
<li>Пат не кашляете или чихаете.</li>
<li>Если вы не придете, если я позвоню, я не приду, если вы звоните.</li>
</ol>
</li>
<li><p class="first">☼ Перевести следующие предложения на предикат-аргумент формулы логики первого порядка.</p>
<ol class="arabic simple">
<li>Ангус любит Кирилла и Ирэн ненавидит Кирилла.</li>
<li>Тофу выше, чем Берти.</li>
<li>Брюс любит себя и Пэт делает тоже самое.</li>
<li>Кирилл увидел Берти, но Ангус не сделал.</li>
<li>Кирилл является fourlegged другом.</li>
<li>Тофу и оливковое находятся рядом друг с другом.</li>
</ol>
</li>
<li><p class="first">☼ Переведите следующие предложения в количественной оценке формул логики первого порядка.</p>
<ol class="arabic simple">
<li>Ангус любит кого-то, а кто-то любит Юлю.</li>
<li>Ангус любит собаку, которая любит его.</li>
<li>Никто не улыбается Пат.</li>
<li>Кто-то кашляет и чихает.</li>
<li>Никто не кашлянул или чихнул.</li>
<li>Брюс любит кого-то другого, чем Брюс.</li>
<li>Никто, кроме Мэтью любит кому-нибудь патент.</li>
<li>Кирилл любит всех за исключением Ирен.</li>
<li>Ровно один человек спит.</li>
</ol>
</li>
<li><p class="first">☼ Перевести следующие глагольные фразы, используя Х тезисы.
количественные формулы логики первого порядка.</p>
<ol class="arabic simple">
<li>кормить Кирилла и дать капуччино Ангуса</li>
<li>дать «Война и мир» по патенту</li>
<li>любили все</li>
<li>быть любимым или ненавистной всем</li>
<li>быть любимым всеми и ненавистной ни с кем</li>
</ol>
</li>
<li><p class="first">☼ Рассмотрим следующие утверждения:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> Read_expr = nltk.sem.Expression.fromstring <span class="pysrc-prompt">&gt;&gt;&gt;</span> e2 = read_expr ( <span class="pysrc-string">'Pat')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">существует y.love (погладить, у)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Очевидно , что - то здесь не хватает, а именно декларация о стоимости <tt class="doctest"><span class="pre">e1.</span></tt> Для того , чтобы <tt class="doctest"><span class="pre">ApplicationExpression (e1, e2)</span></tt> , чтобы быть β-конвертируемые в <tt class="doctest"><span class="pre">y.love существует (погладить, у),</span></tt> <tt class="doctest"><span class="pre">e1</span></tt> должен быть λ-абстрактное , который может принять <tt class="doctest"><span class="pre">похлопывание</span></tt> в качестве аргумента. Ваша задача состоит в том, чтобы построить такую аннотацию, привязать его к <tt class="doctest"><span class="pre">e1,</span></tt> и удовлетворить себя , что приведенные выше утверждения все удовлетворены (до алфавитного дисперсии). Кроме того, обеспечить неофициальный перевод на английский язык <tt class="doctest"><span class="pre">e3.simplify ().</span></tt></p>
<p>Теперь продолжать делать эту же задачу для дальнейших случаев <tt class="doctest"><span class="pre">e3.simplify ()</span></tt> , представленным ниже.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">Печать</span> (e3.simplify ()) <span class="pysrc-output">существует у (любовь (погладить, у) | любовь (у, погладить)).</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">Печать</span> (e3.simplify ()) <span class="pysrc-output">существует у (любовь (погладить, у) | любовь (у, погладить)).</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">Печать</span> (e3.simplify ()) <span class="pysrc-output">прогулка (Fido)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">☼ Как и в предыдущем упражнении, найти Х абстрактный <tt class="doctest"><span class="pre">e1</span></tt> , которая дает результаты , эквивалентные тем , которые показаны ниже.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'Погоня')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">\ x.all у. (Собака (у) -&gt; Погоня (х, погладить))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'Погоня')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">\ x.exists у. (Собака (у) и погоня (погладить, х))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'давать')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">\ x0 x1.exists у. (</span> В <span class="pysrc-output">настоящее</span> время <span class="pysrc-output">(у) и дать (x1, у, х0))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">☼ Как и в предыдущем упражнении, найти Х абстрактный <tt class="doctest"><span class="pre">e1</span></tt> , которая дает результаты , эквивалентные тем , которые показаны ниже.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'кора')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">существует у. (Собака (х) и кора (х))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'кора')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) <span class="pysrc-output">кора (Fido)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar" onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"> </td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt;</span> E2 = read_expr ( <span class="pysrc-string">'\\ P все х (собака (х) -..&gt; Р (х))')</span> <span class="pysrc-prompt">&gt;&gt;&gt;</span> e3 = nltk.sem.ApplicationExpression (e1, e2) <span class="pysrc-prompt">&gt;&gt;&gt;</span> <span class="pysrc-keyword">печать</span> (e3.simplify ()) для <span class="pysrc-output">всех х (собака (х) -&gt; кора (х)).</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">◑ Разработать метод перевода английских предложений в формулах с двоичным <a name="generalized_quantifiers_index_term"></a> <span class="termdef">обобщенные кванторы.</span> При таком подходе, учитывая обобщенный квантор <tt class="doctest"><span class="pre">Q,</span></tt> количественная формула имеет вид <tt class="doctest"><span class="pre">Q (А, В),</span></tt> где <tt class="doctest"><span class="pre">А</span></tt> и <tt class="doctest"><span class="pre">В</span></tt> являются выражениями типа <em>&lt;е,</em> <em>т&gt;.</em> Тогда, например, <tt class="doctest"><span class="pre">все (А, В)</span></tt> истинно тогда и только тогда <tt class="doctest"><span class="pre">А</span></tt> обозначает подмножество , что <tt class="doctest"><span class="pre">В</span></tt> означает.</p>
</li>
<li><p class="first">◑ Продлить подход в предыдущем упражнении , так что условия истинности для кванторов , как <span class="example">большинство</span> и <span class="example">ровно три</span> могут быть вычислены в модели.</p>
</li>
<li><p class="first">◑ Измените <tt class="doctest"><span class="pre">sem.evaluate</span></tt> код таким образом , что это даст сообщение об ошибке , если полезное выражение не в области функции оценки моделью с .</p>
</li>
<li><p class="first">★ Выберите три или четыре смежных предложения из книги для детей. Возможным источником примеров являются сборники рассказов в <tt class="doctest"><span class="pre">nltk.corpus.gutenberg:</span></tt> <tt class="doctest"><span class="pre">Bryant-stories.txt,</span></tt> <tt class="doctest"><span class="pre">мещанского busterbrown.txt</span></tt> и <tt class="doctest"><span class="pre">Эджворта-parents.txt.</span></tt> Разработка грамматики, которая позволит ваши предложения должны быть переведены в логике первого порядка, и построить модель, которая позволит эти переводы должны быть проверены на истинность или ложность.</p>
</li>
<li><p class="first">★ Выполните предыдущее упражнение, но использовать DRT как представление смысл.</p>
</li>
<li><p class="first">★ Взятие <a class="reference external" href="http://www.nltk.org/book/bibliography.html#warren1982eea" id="id20">(Уоррен &amp; Pereira, 1982)</a> , в качестве отправной точки, разработать методику для преобразования данных естественного языка в форму , которая может быть оценена более эффективно в качестве модели. Например, если запрос вида <tt class="doctest"><span class="pre">(Р (х) и Q (х)),</span></tt> преобразовать его в <tt class="doctest"><span class="pre">(Q (х) и Р (х))</span></tt> , если расширение <tt class="doctest"><span class="pre">Q</span></tt> меньше , чем расширение <tt class="doctest"><span class="pre">P.</span></tt></p>
</li>
</ol>
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">Об этом документе ...</p>
<p>Обновлялся для NLTK 3.0.
Это глава из книги <em>Обработка естественного языка с помощью Python</em> написанной <a class="reference external" href="http://estive.net/">Стивеном Бердом</a> , <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Эваном Клайном</a> и <a class="reference external" href="http://ed.loper.org/">Эдвардом Лопером</a> , Copyright © 2014 авторов.
Он распространяется с <em>Набором инструментов для естественного языка</em> <tt class="doctest"><span class="pre">[http://nltk.org/],</span></tt> версия 3.0 в соответствии с условиями <em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 Лицензии Соединенных Штатов</em> [ <a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">Этот документ был построен на ср 1 июля 2015 12:30:05 AEST</p>
</div>
</div>
</div>
</body>
</html>